/*
 * Please do not edit this file.
 * It was generated using rpcgen.
 */

#include "nfs3_prot.h"

bool_t
xdr_uint64(XDR *xdrs, uint64 *objp)
{

	 register int32_t *buf;

	 if (!xdr_u_longlong_t(xdrs, objp)) {
		 return (FALSE);
	 }
	return (TRUE);
}

bool_t
xdr_int64(XDR *xdrs, int64 *objp)
{

	 register int32_t *buf;

	 if (!xdr_longlong_t(xdrs, objp)) {
		 return (FALSE);
	 }
	return (TRUE);
}

bool_t
xdr_uint32(XDR *xdrs, uint32 *objp)
{

	 register int32_t *buf;

	 if (!xdr_u_int(xdrs, objp)) {
		 return (FALSE);
	 }
	return (TRUE);
}

bool_t
xdr_int32(XDR *xdrs, int32 *objp)
{

	 register int32_t *buf;

	 if (!xdr_int(xdrs, objp)) {
		 return (FALSE);
	 }
	return (TRUE);
}

bool_t
xdr_filename3(XDR *xdrs, filename3 *objp)
{

	 register int32_t *buf;

	 if (!xdr_string(xdrs, objp, ~0)) {
		 return (FALSE);
	 }
	return (TRUE);
}

bool_t
xdr_nfspath3(XDR *xdrs, nfspath3 *objp)
{

	 register int32_t *buf;

	 if (!xdr_string(xdrs, objp, ~0)) {
		 return (FALSE);
	 }
	return (TRUE);
}

bool_t
xdr_cookieverf3(XDR *xdrs, cookieverf3 objp)
{

	 register int32_t *buf;

	 if (!xdr_opaque(xdrs, objp, NFS3_COOKIEVERFSIZE)) {
		 return (FALSE);
	 }
	return (TRUE);
}

bool_t
xdr_createverf3(XDR *xdrs, createverf3 objp)
{

	 register int32_t *buf;

	 if (!xdr_opaque(xdrs, objp, NFS3_CREATEVERFSIZE)) {
		 return (FALSE);
	 }
	return (TRUE);
}

bool_t
xdr_writeverf3(XDR *xdrs, writeverf3 objp)
{

	 register int32_t *buf;

	 if (!xdr_opaque(xdrs, objp, NFS3_WRITEVERFSIZE)) {
		 return (FALSE);
	 }
	return (TRUE);
}

bool_t
xdr_nfsstat3(XDR *xdrs, nfsstat3 *objp)
{

	 register int32_t *buf;

	 if (!xdr_enum(xdrs, (enum_t *)objp)) {
		 return (FALSE);
	 }
	return (TRUE);
}

bool_t
xdr_ftype3(XDR *xdrs, ftype3 *objp)
{

	 register int32_t *buf;

	 if (!xdr_enum(xdrs, (enum_t *)objp)) {
		 return (FALSE);
	 }
	return (TRUE);
}

bool_t
xdr_specdata3(XDR *xdrs, specdata3 *objp)
{

	 register int32_t *buf;

	 if (!xdr_uint32(xdrs, &objp->major)) {
		 return (FALSE);
	 }
	 if (!xdr_uint32(xdrs, &objp->minor)) {
		 return (FALSE);
	 }
	return (TRUE);
}

bool_t
xdr_nfs_fh3(XDR *xdrs, nfs_fh3 *objp)
{

	 register int32_t *buf;

	 if (!xdr_bytes(xdrs, (char **)&objp->data.val, (u_int *)&objp->data.len, NFS3_FHSIZE)) {
		 return (FALSE);
	 }
	return (TRUE);
}

bool_t
xdr_nfstime3(XDR *xdrs, nfstime3 *objp)
{

	 register int32_t *buf;

	 if (!xdr_uint32(xdrs, &objp->seconds)) {
		 return (FALSE);
	 }
	 if (!xdr_uint32(xdrs, &objp->nseconds)) {
		 return (FALSE);
	 }
	return (TRUE);
}

bool_t
xdr_fattr3(XDR *xdrs, fattr3 *objp)
{

	 register int32_t *buf;

	 if (!xdr_ftype3(xdrs, &objp->type)) {
		 return (FALSE);
	 }
	 if (!xdr_uint32(xdrs, &objp->mode)) {
		 return (FALSE);
	 }
	 if (!xdr_uint32(xdrs, &objp->nlink)) {
		 return (FALSE);
	 }
	 if (!xdr_uint32(xdrs, &objp->uid)) {
		 return (FALSE);
	 }
	 if (!xdr_uint32(xdrs, &objp->gid)) {
		 return (FALSE);
	 }
	 if (!xdr_uint64(xdrs, &objp->size)) {
		 return (FALSE);
	 }
	 if (!xdr_uint64(xdrs, &objp->used)) {
		 return (FALSE);
	 }
	 if (!xdr_specdata3(xdrs, &objp->rdev)) {
		 return (FALSE);
	 }
	 if (!xdr_uint64(xdrs, &objp->fsid)) {
		 return (FALSE);
	 }
	 if (!xdr_uint64(xdrs, &objp->fileid)) {
		 return (FALSE);
	 }
	 if (!xdr_nfstime3(xdrs, &objp->atime)) {
		 return (FALSE);
	 }
	 if (!xdr_nfstime3(xdrs, &objp->mtime)) {
		 return (FALSE);
	 }
	 if (!xdr_nfstime3(xdrs, &objp->ctime)) {
		 return (FALSE);
	 }
	return (TRUE);
}

bool_t
xdr_post_op_attr(XDR *xdrs, post_op_attr *objp)
{

	 register int32_t *buf;

	 if (!xdr_bool(xdrs, &objp->present)) {
		 return (FALSE);
	 }
	switch (objp->present) {
	case TRUE:
		 if (!xdr_fattr3(xdrs, &objp->RPC_UNION_NAME(post_op_attr).attributes)) {
			 return (FALSE);
		 }
		break;
	case FALSE:
		break;
	default:
		return (FALSE);
	}
	return (TRUE);
}

bool_t
xdr_wcc_attr(XDR *xdrs, wcc_attr *objp)
{

	 register int32_t *buf;

	 if (!xdr_uint64(xdrs, &objp->size)) {
		 return (FALSE);
	 }
	 if (!xdr_nfstime3(xdrs, &objp->mtime)) {
		 return (FALSE);
	 }
	 if (!xdr_nfstime3(xdrs, &objp->ctime)) {
		 return (FALSE);
	 }
	return (TRUE);
}

bool_t
xdr_pre_op_attr(XDR *xdrs, pre_op_attr *objp)
{

	 register int32_t *buf;

	 if (!xdr_bool(xdrs, &objp->present)) {
		 return (FALSE);
	 }
	switch (objp->present) {
	case TRUE:
		 if (!xdr_wcc_attr(xdrs, &objp->RPC_UNION_NAME(pre_op_attr).attributes)) {
			 return (FALSE);
		 }
		break;
	case FALSE:
		break;
	default:
		return (FALSE);
	}
	return (TRUE);
}

bool_t
xdr_wcc_data(XDR *xdrs, wcc_data *objp)
{

	 register int32_t *buf;

	 if (!xdr_pre_op_attr(xdrs, &objp->before)) {
		 return (FALSE);
	 }
	 if (!xdr_post_op_attr(xdrs, &objp->after)) {
		 return (FALSE);
	 }
	return (TRUE);
}

bool_t
xdr_post_op_fh3(XDR *xdrs, post_op_fh3 *objp)
{

	 register int32_t *buf;

	 if (!xdr_bool(xdrs, &objp->present)) {
		 return (FALSE);
	 }
	switch (objp->present) {
	case TRUE:
		 if (!xdr_nfs_fh3(xdrs, &objp->RPC_UNION_NAME(post_op_fh3).handle)) {
			 return (FALSE);
		 }
		break;
	case FALSE:
		break;
	default:
		return (FALSE);
	}
	return (TRUE);
}

bool_t
xdr_set_uint32(XDR *xdrs, set_uint32 *objp)
{

	 register int32_t *buf;

	 if (!xdr_bool(xdrs, &objp->set)) {
		 return (FALSE);
	 }
	switch (objp->set) {
	case TRUE:
		 if (!xdr_uint32(xdrs, &objp->RPC_UNION_NAME(set_uint32).val)) {
			 return (FALSE);
		 }
		break;
	}
	return (TRUE);
}

bool_t
xdr_set_uint64(XDR *xdrs, set_uint64 *objp)
{

	 register int32_t *buf;

	 if (!xdr_bool(xdrs, &objp->set)) {
		 return (FALSE);
	 }
	switch (objp->set) {
	case TRUE:
		 if (!xdr_uint64(xdrs, &objp->RPC_UNION_NAME(set_uint64).val)) {
			 return (FALSE);
		 }
		break;
	}
	return (TRUE);
}

bool_t
xdr_time_how(XDR *xdrs, time_how *objp)
{

	 register int32_t *buf;

	 if (!xdr_enum(xdrs, (enum_t *)objp)) {
		 return (FALSE);
	 }
	return (TRUE);
}

bool_t
xdr_set_time(XDR *xdrs, set_time *objp)
{

	 register int32_t *buf;

	 if (!xdr_time_how(xdrs, &objp->set)) {
		 return (FALSE);
	 }
	switch (objp->set) {
	case SET_TO_CLIENT_TIME:
		 if (!xdr_nfstime3(xdrs, &objp->RPC_UNION_NAME(set_time).time)) {
			 return (FALSE);
		 }
		break;
	}
	return (TRUE);
}

bool_t
xdr_sattr3(XDR *xdrs, sattr3 *objp)
{

	 register int32_t *buf;

	 if (!xdr_set_uint32(xdrs, &objp->mode)) {
		 return (FALSE);
	 }
	 if (!xdr_set_uint32(xdrs, &objp->uid)) {
		 return (FALSE);
	 }
	 if (!xdr_set_uint32(xdrs, &objp->gid)) {
		 return (FALSE);
	 }
	 if (!xdr_set_uint64(xdrs, &objp->size)) {
		 return (FALSE);
	 }
	 if (!xdr_set_time(xdrs, &objp->atime)) {
		 return (FALSE);
	 }
	 if (!xdr_set_time(xdrs, &objp->mtime)) {
		 return (FALSE);
	 }
	return (TRUE);
}

bool_t
xdr_diropargs3(XDR *xdrs, diropargs3 *objp)
{

	 register int32_t *buf;

	 if (!xdr_nfs_fh3(xdrs, &objp->dir)) {
		 return (FALSE);
	 }
	 if (!xdr_filename3(xdrs, &objp->name)) {
		 return (FALSE);
	 }
	return (TRUE);
}

bool_t
xdr_diropres3ok(XDR *xdrs, diropres3ok *objp)
{

	 register int32_t *buf;

	 if (!xdr_post_op_fh3(xdrs, &objp->obj)) {
		 return (FALSE);
	 }
	 if (!xdr_post_op_attr(xdrs, &objp->obj_attributes)) {
		 return (FALSE);
	 }
	 if (!xdr_wcc_data(xdrs, &objp->dir_wcc)) {
		 return (FALSE);
	 }
	return (TRUE);
}

bool_t
xdr_diropres3(XDR *xdrs, diropres3 *objp)
{

	 register int32_t *buf;

	 if (!xdr_nfsstat3(xdrs, &objp->status)) {
		 return (FALSE);
	 }
	switch (objp->status) {
	case NFS3_OK:
		 if (!xdr_diropres3ok(xdrs, &objp->RPC_UNION_NAME(diropres3).resok)) {
			 return (FALSE);
		 }
		break;
	default:
		 if (!xdr_wcc_data(xdrs, &objp->RPC_UNION_NAME(diropres3).resfail)) {
			 return (FALSE);
		 }
		break;
	}
	return (TRUE);
}

bool_t
xdr_wccstat3(XDR *xdrs, wccstat3 *objp)
{

	 register int32_t *buf;

	 if (!xdr_nfsstat3(xdrs, &objp->status)) {
		 return (FALSE);
	 }
	switch (objp->status) {
	case -1:
		break;
	default:
		 if (!xdr_wcc_data(xdrs, &objp->RPC_UNION_NAME(wccstat3).wcc)) {
			 return (FALSE);
		 }
		break;
	}
	return (TRUE);
}

bool_t
xdr_getattr3res(XDR *xdrs, getattr3res *objp)
{

	 register int32_t *buf;

	 if (!xdr_nfsstat3(xdrs, &objp->status)) {
		 return (FALSE);
	 }
	switch (objp->status) {
	case NFS3_OK:
		 if (!xdr_fattr3(xdrs, &objp->RPC_UNION_NAME(getattr3res).attributes)) {
			 return (FALSE);
		 }
		break;
	}
	return (TRUE);
}

bool_t
xdr_sattrguard3(XDR *xdrs, sattrguard3 *objp)
{

	 register int32_t *buf;

	 if (!xdr_bool(xdrs, &objp->check)) {
		 return (FALSE);
	 }
	switch (objp->check) {
	case TRUE:
		 if (!xdr_nfstime3(xdrs, &objp->RPC_UNION_NAME(sattrguard3).ctime)) {
			 return (FALSE);
		 }
		break;
	case FALSE:
		break;
	default:
		return (FALSE);
	}
	return (TRUE);
}

bool_t
xdr_setattr3args(XDR *xdrs, setattr3args *objp)
{

	 register int32_t *buf;

	 if (!xdr_nfs_fh3(xdrs, &objp->object)) {
		 return (FALSE);
	 }
	 if (!xdr_sattr3(xdrs, &objp->new_attributes)) {
		 return (FALSE);
	 }
	 if (!xdr_sattrguard3(xdrs, &objp->guard)) {
		 return (FALSE);
	 }
	return (TRUE);
}

bool_t
xdr_lookup3resok(XDR *xdrs, lookup3resok *objp)
{

	 register int32_t *buf;

	 if (!xdr_nfs_fh3(xdrs, &objp->object)) {
		 return (FALSE);
	 }
	 if (!xdr_post_op_attr(xdrs, &objp->obj_attributes)) {
		 return (FALSE);
	 }
	 if (!xdr_post_op_attr(xdrs, &objp->dir_attributes)) {
		 return (FALSE);
	 }
	return (TRUE);
}

bool_t
xdr_lookup3res(XDR *xdrs, lookup3res *objp)
{

	 register int32_t *buf;

	 if (!xdr_nfsstat3(xdrs, &objp->status)) {
		 return (FALSE);
	 }
	switch (objp->status) {
	case NFS3_OK:
		 if (!xdr_lookup3resok(xdrs, &objp->RPC_UNION_NAME(lookup3res).resok)) {
			 return (FALSE);
		 }
		break;
	default:
		 if (!xdr_post_op_attr(xdrs, &objp->RPC_UNION_NAME(lookup3res).resfail)) {
			 return (FALSE);
		 }
		break;
	}
	return (TRUE);
}

bool_t
xdr_access3args(XDR *xdrs, access3args *objp)
{

	 register int32_t *buf;

	 if (!xdr_nfs_fh3(xdrs, &objp->object)) {
		 return (FALSE);
	 }
	 if (!xdr_uint32(xdrs, &objp->access)) {
		 return (FALSE);
	 }
	return (TRUE);
}

bool_t
xdr_access3resok(XDR *xdrs, access3resok *objp)
{

	 register int32_t *buf;

	 if (!xdr_post_op_attr(xdrs, &objp->obj_attributes)) {
		 return (FALSE);
	 }
	 if (!xdr_uint32(xdrs, &objp->access)) {
		 return (FALSE);
	 }
	return (TRUE);
}

bool_t
xdr_access3res(XDR *xdrs, access3res *objp)
{

	 register int32_t *buf;

	 if (!xdr_nfsstat3(xdrs, &objp->status)) {
		 return (FALSE);
	 }
	switch (objp->status) {
	case NFS3_OK:
		 if (!xdr_access3resok(xdrs, &objp->RPC_UNION_NAME(access3res).resok)) {
			 return (FALSE);
		 }
		break;
	default:
		 if (!xdr_post_op_attr(xdrs, &objp->RPC_UNION_NAME(access3res).resfail)) {
			 return (FALSE);
		 }
		break;
	}
	return (TRUE);
}

bool_t
xdr_readlink3resok(XDR *xdrs, readlink3resok *objp)
{

	 register int32_t *buf;

	 if (!xdr_post_op_attr(xdrs, &objp->symlink_attributes)) {
		 return (FALSE);
	 }
	 if (!xdr_nfspath3(xdrs, &objp->data)) {
		 return (FALSE);
	 }
	return (TRUE);
}

bool_t
xdr_readlink3res(XDR *xdrs, readlink3res *objp)
{

	 register int32_t *buf;

	 if (!xdr_nfsstat3(xdrs, &objp->status)) {
		 return (FALSE);
	 }
	switch (objp->status) {
	case NFS3_OK:
		 if (!xdr_readlink3resok(xdrs, &objp->RPC_UNION_NAME(readlink3res).resok)) {
			 return (FALSE);
		 }
		break;
	default:
		 if (!xdr_post_op_attr(xdrs, &objp->RPC_UNION_NAME(readlink3res).resfail)) {
			 return (FALSE);
		 }
		break;
	}
	return (TRUE);
}

bool_t
xdr_read3args(XDR *xdrs, read3args *objp)
{

	 register int32_t *buf;

	 if (!xdr_nfs_fh3(xdrs, &objp->file)) {
		 return (FALSE);
	 }
	 if (!xdr_uint64(xdrs, &objp->offset)) {
		 return (FALSE);
	 }
	 if (!xdr_uint32(xdrs, &objp->count)) {
		 return (FALSE);
	 }
	return (TRUE);
}

bool_t
xdr_read3resok(XDR *xdrs, read3resok *objp)
{

	 register int32_t *buf;

	 if (!xdr_post_op_attr(xdrs, &objp->file_attributes)) {
		 return (FALSE);
	 }
	 if (!xdr_uint32(xdrs, &objp->count)) {
		 return (FALSE);
	 }
	 if (!xdr_bool(xdrs, &objp->eof)) {
		 return (FALSE);
	 }
	 if (!xdr_bytes(xdrs, (char **)&objp->data.val, (u_int *)&objp->data.len, ~0)) {
		 return (FALSE);
	 }
	return (TRUE);
}

bool_t
xdr_read3res(XDR *xdrs, read3res *objp)
{

	 register int32_t *buf;

	 if (!xdr_nfsstat3(xdrs, &objp->status)) {
		 return (FALSE);
	 }
	switch (objp->status) {
	case NFS3_OK:
		 if (!xdr_read3resok(xdrs, &objp->RPC_UNION_NAME(read3res).resok)) {
			 return (FALSE);
		 }
		break;
	default:
		 if (!xdr_post_op_attr(xdrs, &objp->RPC_UNION_NAME(read3res).resfail)) {
			 return (FALSE);
		 }
		break;
	}
	return (TRUE);
}

bool_t
xdr_stable_how(XDR *xdrs, stable_how *objp)
{

	 register int32_t *buf;

	 if (!xdr_enum(xdrs, (enum_t *)objp)) {
		 return (FALSE);
	 }
	return (TRUE);
}

bool_t
xdr_write3args(XDR *xdrs, write3args *objp)
{

	 register int32_t *buf;

	 if (!xdr_nfs_fh3(xdrs, &objp->file)) {
		 return (FALSE);
	 }
	 if (!xdr_uint64(xdrs, &objp->offset)) {
		 return (FALSE);
	 }
	 if (!xdr_uint32(xdrs, &objp->count)) {
		 return (FALSE);
	 }
	 if (!xdr_stable_how(xdrs, &objp->stable)) {
		 return (FALSE);
	 }
	 if (!xdr_bytes(xdrs, (char **)&objp->data.val, (u_int *)&objp->data.len, ~0)) {
		 return (FALSE);
	 }
	return (TRUE);
}

bool_t
xdr_write3resok(XDR *xdrs, write3resok *objp)
{

	 register int32_t *buf;

	 if (!xdr_wcc_data(xdrs, &objp->file_wcc)) {
		 return (FALSE);
	 }
	 if (!xdr_uint32(xdrs, &objp->count)) {
		 return (FALSE);
	 }
	 if (!xdr_stable_how(xdrs, &objp->committed)) {
		 return (FALSE);
	 }
	 if (!xdr_writeverf3(xdrs, objp->verf)) {
		 return (FALSE);
	 }
	return (TRUE);
}

bool_t
xdr_write3res(XDR *xdrs, write3res *objp)
{

	 register int32_t *buf;

	 if (!xdr_nfsstat3(xdrs, &objp->status)) {
		 return (FALSE);
	 }
	switch (objp->status) {
	case NFS3_OK:
		 if (!xdr_write3resok(xdrs, &objp->RPC_UNION_NAME(write3res).resok)) {
			 return (FALSE);
		 }
		break;
	default:
		 if (!xdr_wcc_data(xdrs, &objp->RPC_UNION_NAME(write3res).resfail)) {
			 return (FALSE);
		 }
		break;
	}
	return (TRUE);
}

bool_t
xdr_createmode3(XDR *xdrs, createmode3 *objp)
{

	 register int32_t *buf;

	 if (!xdr_enum(xdrs, (enum_t *)objp)) {
		 return (FALSE);
	 }
	return (TRUE);
}

bool_t
xdr_createhow3(XDR *xdrs, createhow3 *objp)
{

	 register int32_t *buf;

	 if (!xdr_createmode3(xdrs, &objp->mode)) {
		 return (FALSE);
	 }
	switch (objp->mode) {
	case UNCHECKED:
	case GUARDED:
		 if (!xdr_sattr3(xdrs, &objp->RPC_UNION_NAME(createhow3).obj_attributes)) {
			 return (FALSE);
		 }
		break;
	case EXCLUSIVE:
		 if (!xdr_createverf3(xdrs, objp->RPC_UNION_NAME(createhow3).verf)) {
			 return (FALSE);
		 }
		break;
	default:
		return (FALSE);
	}
	return (TRUE);
}

bool_t
xdr_create3args(XDR *xdrs, create3args *objp)
{

	 register int32_t *buf;

	 if (!xdr_diropargs3(xdrs, &objp->where)) {
		 return (FALSE);
	 }
	 if (!xdr_createhow3(xdrs, &objp->how)) {
		 return (FALSE);
	 }
	return (TRUE);
}

bool_t
xdr_mkdir3args(XDR *xdrs, mkdir3args *objp)
{

	 register int32_t *buf;

	 if (!xdr_diropargs3(xdrs, &objp->where)) {
		 return (FALSE);
	 }
	 if (!xdr_sattr3(xdrs, &objp->attributes)) {
		 return (FALSE);
	 }
	return (TRUE);
}

bool_t
xdr_symlinkdata3(XDR *xdrs, symlinkdata3 *objp)
{

	 register int32_t *buf;

	 if (!xdr_sattr3(xdrs, &objp->symlink_attributes)) {
		 return (FALSE);
	 }
	 if (!xdr_nfspath3(xdrs, &objp->symlink_data)) {
		 return (FALSE);
	 }
	return (TRUE);
}

bool_t
xdr_symlink3args(XDR *xdrs, symlink3args *objp)
{

	 register int32_t *buf;

	 if (!xdr_diropargs3(xdrs, &objp->where)) {
		 return (FALSE);
	 }
	 if (!xdr_symlinkdata3(xdrs, &objp->symlink)) {
		 return (FALSE);
	 }
	return (TRUE);
}

bool_t
xdr_devicedata3(XDR *xdrs, devicedata3 *objp)
{

	 register int32_t *buf;

	 if (!xdr_sattr3(xdrs, &objp->dev_attributes)) {
		 return (FALSE);
	 }
	 if (!xdr_specdata3(xdrs, &objp->spec)) {
		 return (FALSE);
	 }
	return (TRUE);
}

bool_t
xdr_mknoddata3(XDR *xdrs, mknoddata3 *objp)
{

	 register int32_t *buf;

	 if (!xdr_ftype3(xdrs, &objp->type)) {
		 return (FALSE);
	 }
	switch (objp->type) {
	case NF3CHR:
	case NF3BLK:
		 if (!xdr_devicedata3(xdrs, &objp->RPC_UNION_NAME(mknoddata3).device)) {
			 return (FALSE);
		 }
		break;
	case NF3SOCK:
	case NF3FIFO:
		 if (!xdr_sattr3(xdrs, &objp->RPC_UNION_NAME(mknoddata3).pipe_attributes)) {
			 return (FALSE);
		 }
		break;
	}
	return (TRUE);
}

bool_t
xdr_mknod3args(XDR *xdrs, mknod3args *objp)
{

	 register int32_t *buf;

	 if (!xdr_diropargs3(xdrs, &objp->where)) {
		 return (FALSE);
	 }
	 if (!xdr_mknoddata3(xdrs, &objp->what)) {
		 return (FALSE);
	 }
	return (TRUE);
}

bool_t
xdr_rename3args(XDR *xdrs, rename3args *objp)
{

	 register int32_t *buf;

	 if (!xdr_diropargs3(xdrs, &objp->from)) {
		 return (FALSE);
	 }
	 if (!xdr_diropargs3(xdrs, &objp->to)) {
		 return (FALSE);
	 }
	return (TRUE);
}

bool_t
xdr_rename3wcc(XDR *xdrs, rename3wcc *objp)
{

	 register int32_t *buf;

	 if (!xdr_wcc_data(xdrs, &objp->fromdir_wcc)) {
		 return (FALSE);
	 }
	 if (!xdr_wcc_data(xdrs, &objp->todir_wcc)) {
		 return (FALSE);
	 }
	return (TRUE);
}

bool_t
xdr_rename3res(XDR *xdrs, rename3res *objp)
{

	 register int32_t *buf;

	 if (!xdr_nfsstat3(xdrs, &objp->status)) {
		 return (FALSE);
	 }
	switch (objp->status) {
	case -1:
		break;
	default:
		 if (!xdr_rename3wcc(xdrs, &objp->RPC_UNION_NAME(rename3res).res)) {
			 return (FALSE);
		 }
		break;
	}
	return (TRUE);
}

bool_t
xdr_link3args(XDR *xdrs, link3args *objp)
{

	 register int32_t *buf;

	 if (!xdr_nfs_fh3(xdrs, &objp->file)) {
		 return (FALSE);
	 }
	 if (!xdr_diropargs3(xdrs, &objp->link)) {
		 return (FALSE);
	 }
	return (TRUE);
}

bool_t
xdr_link3wcc(XDR *xdrs, link3wcc *objp)
{

	 register int32_t *buf;

	 if (!xdr_post_op_attr(xdrs, &objp->file_attributes)) {
		 return (FALSE);
	 }
	 if (!xdr_wcc_data(xdrs, &objp->linkdir_wcc)) {
		 return (FALSE);
	 }
	return (TRUE);
}

bool_t
xdr_link3res(XDR *xdrs, link3res *objp)
{

	 register int32_t *buf;

	 if (!xdr_nfsstat3(xdrs, &objp->status)) {
		 return (FALSE);
	 }
	switch (objp->status) {
	case -1:
		break;
	default:
		 if (!xdr_link3wcc(xdrs, &objp->RPC_UNION_NAME(link3res).res)) {
			 return (FALSE);
		 }
		break;
	}
	return (TRUE);
}

bool_t
xdr_readdir3args(XDR *xdrs, readdir3args *objp)
{

	 register int32_t *buf;

	 if (!xdr_nfs_fh3(xdrs, &objp->dir)) {
		 return (FALSE);
	 }
	 if (!xdr_uint64(xdrs, &objp->cookie)) {
		 return (FALSE);
	 }
	 if (!xdr_cookieverf3(xdrs, objp->cookieverf)) {
		 return (FALSE);
	 }
	 if (!xdr_uint32(xdrs, &objp->count)) {
		 return (FALSE);
	 }
	return (TRUE);
}

bool_t
xdr_entry3(XDR *xdrs, entry3 *objp)
{

	 register int32_t *buf;

	 if (!xdr_uint64(xdrs, &objp->fileid)) {
		 return (FALSE);
	 }
	 if (!xdr_filename3(xdrs, &objp->name)) {
		 return (FALSE);
	 }
	 if (!xdr_uint64(xdrs, &objp->cookie)) {
		 return (FALSE);
	 }
	 if (!xdr_pointer(xdrs, (char **)&objp->nextentry, sizeof(entry3), (xdrproc_t)xdr_entry3)) {
		 return (FALSE);
	 }
	return (TRUE);
}

bool_t
xdr_dirlist3(XDR *xdrs, dirlist3 *objp)
{

	 register int32_t *buf;

	 if (!xdr_pointer(xdrs, (char **)&objp->entries, sizeof(entry3), (xdrproc_t)xdr_entry3)) {
		 return (FALSE);
	 }
	 if (!xdr_bool(xdrs, &objp->eof)) {
		 return (FALSE);
	 }
	return (TRUE);
}

bool_t
xdr_readdir3resok(XDR *xdrs, readdir3resok *objp)
{

	 register int32_t *buf;

	 if (!xdr_post_op_attr(xdrs, &objp->dir_attributes)) {
		 return (FALSE);
	 }
	 if (!xdr_cookieverf3(xdrs, objp->cookieverf)) {
		 return (FALSE);
	 }
	 if (!xdr_dirlist3(xdrs, &objp->reply)) {
		 return (FALSE);
	 }
	return (TRUE);
}

bool_t
xdr_readdir3res(XDR *xdrs, readdir3res *objp)
{

	 register int32_t *buf;

	 if (!xdr_nfsstat3(xdrs, &objp->status)) {
		 return (FALSE);
	 }
	switch (objp->status) {
	case NFS3_OK:
		 if (!xdr_readdir3resok(xdrs, &objp->RPC_UNION_NAME(readdir3res).resok)) {
			 return (FALSE);
		 }
		break;
	default:
		 if (!xdr_post_op_attr(xdrs, &objp->RPC_UNION_NAME(readdir3res).resfail)) {
			 return (FALSE);
		 }
		break;
	}
	return (TRUE);
}

bool_t
xdr_readdirplus3args(XDR *xdrs, readdirplus3args *objp)
{

	 register int32_t *buf;

	 if (!xdr_nfs_fh3(xdrs, &objp->dir)) {
		 return (FALSE);
	 }
	 if (!xdr_uint64(xdrs, &objp->cookie)) {
		 return (FALSE);
	 }
	 if (!xdr_cookieverf3(xdrs, objp->cookieverf)) {
		 return (FALSE);
	 }
	 if (!xdr_uint32(xdrs, &objp->dircount)) {
		 return (FALSE);
	 }
	 if (!xdr_uint32(xdrs, &objp->maxcount)) {
		 return (FALSE);
	 }
	return (TRUE);
}

bool_t
xdr_entryplus3(XDR *xdrs, entryplus3 *objp)
{

	 register int32_t *buf;

	 if (!xdr_uint64(xdrs, &objp->fileid)) {
		 return (FALSE);
	 }
	 if (!xdr_filename3(xdrs, &objp->name)) {
		 return (FALSE);
	 }
	 if (!xdr_uint64(xdrs, &objp->cookie)) {
		 return (FALSE);
	 }
	 if (!xdr_post_op_attr(xdrs, &objp->name_attributes)) {
		 return (FALSE);
	 }
	 if (!xdr_post_op_fh3(xdrs, &objp->name_handle)) {
		 return (FALSE);
	 }
	 if (!xdr_pointer(xdrs, (char **)&objp->nextentry, sizeof(entryplus3), (xdrproc_t)xdr_entryplus3)) {
		 return (FALSE);
	 }
	return (TRUE);
}

bool_t
xdr_dirlistplus3(XDR *xdrs, dirlistplus3 *objp)
{

	 register int32_t *buf;

	 if (!xdr_pointer(xdrs, (char **)&objp->entries, sizeof(entryplus3), (xdrproc_t)xdr_entryplus3)) {
		 return (FALSE);
	 }
	 if (!xdr_bool(xdrs, &objp->eof)) {
		 return (FALSE);
	 }
	return (TRUE);
}

bool_t
xdr_readdirplus3resok(XDR *xdrs, readdirplus3resok *objp)
{

	 register int32_t *buf;

	 if (!xdr_post_op_attr(xdrs, &objp->dir_attributes)) {
		 return (FALSE);
	 }
	 if (!xdr_cookieverf3(xdrs, objp->cookieverf)) {
		 return (FALSE);
	 }
	 if (!xdr_dirlistplus3(xdrs, &objp->reply)) {
		 return (FALSE);
	 }
	return (TRUE);
}

bool_t
xdr_readdirplus3res(XDR *xdrs, readdirplus3res *objp)
{

	 register int32_t *buf;

	 if (!xdr_nfsstat3(xdrs, &objp->status)) {
		 return (FALSE);
	 }
	switch (objp->status) {
	case NFS3_OK:
		 if (!xdr_readdirplus3resok(xdrs, &objp->RPC_UNION_NAME(readdirplus3res).resok)) {
			 return (FALSE);
		 }
		break;
	default:
		 if (!xdr_post_op_attr(xdrs, &objp->RPC_UNION_NAME(readdirplus3res).resfail)) {
			 return (FALSE);
		 }
		break;
	}
	return (TRUE);
}

bool_t
xdr_fsstat3resok(XDR *xdrs, fsstat3resok *objp)
{

	 register int32_t *buf;

	 if (!xdr_post_op_attr(xdrs, &objp->obj_attributes)) {
		 return (FALSE);
	 }
	 if (!xdr_uint64(xdrs, &objp->tbytes)) {
		 return (FALSE);
	 }
	 if (!xdr_uint64(xdrs, &objp->fbytes)) {
		 return (FALSE);
	 }
	 if (!xdr_uint64(xdrs, &objp->abytes)) {
		 return (FALSE);
	 }
	 if (!xdr_uint64(xdrs, &objp->tfiles)) {
		 return (FALSE);
	 }
	 if (!xdr_uint64(xdrs, &objp->ffiles)) {
		 return (FALSE);
	 }
	 if (!xdr_uint64(xdrs, &objp->afiles)) {
		 return (FALSE);
	 }
	 if (!xdr_uint32(xdrs, &objp->invarsec)) {
		 return (FALSE);
	 }
	return (TRUE);
}

bool_t
xdr_fsstat3res(XDR *xdrs, fsstat3res *objp)
{

	 register int32_t *buf;

	 if (!xdr_nfsstat3(xdrs, &objp->status)) {
		 return (FALSE);
	 }
	switch (objp->status) {
	case NFS3_OK:
		 if (!xdr_fsstat3resok(xdrs, &objp->RPC_UNION_NAME(fsstat3res).resok)) {
			 return (FALSE);
		 }
		break;
	default:
		 if (!xdr_post_op_attr(xdrs, &objp->RPC_UNION_NAME(fsstat3res).resfail)) {
			 return (FALSE);
		 }
		break;
	}
	return (TRUE);
}

bool_t
xdr_fsinfo3resok(XDR *xdrs, fsinfo3resok *objp)
{

	 register int32_t *buf;

	 if (!xdr_post_op_attr(xdrs, &objp->obj_attributes)) {
		 return (FALSE);
	 }
	 if (!xdr_uint32(xdrs, &objp->rtmax)) {
		 return (FALSE);
	 }
	 if (!xdr_uint32(xdrs, &objp->rtpref)) {
		 return (FALSE);
	 }
	 if (!xdr_uint32(xdrs, &objp->rtmult)) {
		 return (FALSE);
	 }
	 if (!xdr_uint32(xdrs, &objp->wtmax)) {
		 return (FALSE);
	 }
	 if (!xdr_uint32(xdrs, &objp->wtpref)) {
		 return (FALSE);
	 }
	 if (!xdr_uint32(xdrs, &objp->wtmult)) {
		 return (FALSE);
	 }
	 if (!xdr_uint32(xdrs, &objp->dtpref)) {
		 return (FALSE);
	 }
	 if (!xdr_uint64(xdrs, &objp->maxfilesize)) {
		 return (FALSE);
	 }
	 if (!xdr_nfstime3(xdrs, &objp->time_delta)) {
		 return (FALSE);
	 }
	 if (!xdr_uint32(xdrs, &objp->properties)) {
		 return (FALSE);
	 }
	return (TRUE);
}

bool_t
xdr_fsinfo3res(XDR *xdrs, fsinfo3res *objp)
{

	 register int32_t *buf;

	 if (!xdr_nfsstat3(xdrs, &objp->status)) {
		 return (FALSE);
	 }
	switch (objp->status) {
	case NFS3_OK:
		 if (!xdr_fsinfo3resok(xdrs, &objp->RPC_UNION_NAME(fsinfo3res).resok)) {
			 return (FALSE);
		 }
		break;
	default:
		 if (!xdr_post_op_attr(xdrs, &objp->RPC_UNION_NAME(fsinfo3res).resfail)) {
			 return (FALSE);
		 }
		break;
	}
	return (TRUE);
}

bool_t
xdr_pathconf3resok(XDR *xdrs, pathconf3resok *objp)
{

	 register int32_t *buf;


	 if (xdrs->x_op == XDR_ENCODE) {
	 if (!xdr_post_op_attr(xdrs, &objp->obj_attributes)) {
		 return (FALSE);
	 }
	 if (!xdr_uint32(xdrs, &objp->linkmax)) {
		 return (FALSE);
	 }
	 if (!xdr_uint32(xdrs, &objp->name_max)) {
		 return (FALSE);
	 }
		buf = (int32_t *)XDR_INLINE(xdrs,4 * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
		 if (!xdr_bool(xdrs, &objp->no_trunc)) {
			 return (FALSE);
		 }
		 if (!xdr_bool(xdrs, &objp->chown_restricted)) {
			 return (FALSE);
		 }
		 if (!xdr_bool(xdrs, &objp->case_insensitive)) {
			 return (FALSE);
		 }
		 if (!xdr_bool(xdrs, &objp->case_preserving)) {
			 return (FALSE);
		 }

	  }
	  else {
		 IXDR_PUT_BOOL(buf,objp->no_trunc);
		 IXDR_PUT_BOOL(buf,objp->chown_restricted);
		 IXDR_PUT_BOOL(buf,objp->case_insensitive);
		 IXDR_PUT_BOOL(buf,objp->case_preserving);
	  }

 	 return (TRUE);
	} else if (xdrs->x_op == XDR_DECODE) {
	 if (!xdr_post_op_attr(xdrs, &objp->obj_attributes)) {
		 return (FALSE);
	 }
	 if (!xdr_uint32(xdrs, &objp->linkmax)) {
		 return (FALSE);
	 }
	 if (!xdr_uint32(xdrs, &objp->name_max)) {
		 return (FALSE);
	 }
		buf = (int32_t *)XDR_INLINE(xdrs,4 * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
		 if (!xdr_bool(xdrs, &objp->no_trunc)) {
			 return (FALSE);
		 }
		 if (!xdr_bool(xdrs, &objp->chown_restricted)) {
			 return (FALSE);
		 }
		 if (!xdr_bool(xdrs, &objp->case_insensitive)) {
			 return (FALSE);
		 }
		 if (!xdr_bool(xdrs, &objp->case_preserving)) {
			 return (FALSE);
		 }

	  }
	  else {
		 objp->no_trunc = IXDR_GET_BOOL(buf);
		 objp->chown_restricted = IXDR_GET_BOOL(buf);
		 objp->case_insensitive = IXDR_GET_BOOL(buf);
		 objp->case_preserving = IXDR_GET_BOOL(buf);
	  }
	 return(TRUE);
	}

	 if (!xdr_post_op_attr(xdrs, &objp->obj_attributes)) {
		 return (FALSE);
	 }
	 if (!xdr_uint32(xdrs, &objp->linkmax)) {
		 return (FALSE);
	 }
	 if (!xdr_uint32(xdrs, &objp->name_max)) {
		 return (FALSE);
	 }
	 if (!xdr_bool(xdrs, &objp->no_trunc)) {
		 return (FALSE);
	 }
	 if (!xdr_bool(xdrs, &objp->chown_restricted)) {
		 return (FALSE);
	 }
	 if (!xdr_bool(xdrs, &objp->case_insensitive)) {
		 return (FALSE);
	 }
	 if (!xdr_bool(xdrs, &objp->case_preserving)) {
		 return (FALSE);
	 }
	return (TRUE);
}

bool_t
xdr_pathconf3res(XDR *xdrs, pathconf3res *objp)
{

	 register int32_t *buf;

	 if (!xdr_nfsstat3(xdrs, &objp->status)) {
		 return (FALSE);
	 }
	switch (objp->status) {
	case NFS3_OK:
		 if (!xdr_pathconf3resok(xdrs, &objp->RPC_UNION_NAME(pathconf3res).resok)) {
			 return (FALSE);
		 }
		break;
	default:
		 if (!xdr_post_op_attr(xdrs, &objp->RPC_UNION_NAME(pathconf3res).resfail)) {
			 return (FALSE);
		 }
		break;
	}
	return (TRUE);
}

bool_t
xdr_commit3args(XDR *xdrs, commit3args *objp)
{

	 register int32_t *buf;

	 if (!xdr_nfs_fh3(xdrs, &objp->file)) {
		 return (FALSE);
	 }
	 if (!xdr_uint64(xdrs, &objp->offset)) {
		 return (FALSE);
	 }
	 if (!xdr_uint32(xdrs, &objp->count)) {
		 return (FALSE);
	 }
	return (TRUE);
}

bool_t
xdr_commit3resok(XDR *xdrs, commit3resok *objp)
{

	 register int32_t *buf;

	 if (!xdr_wcc_data(xdrs, &objp->file_wcc)) {
		 return (FALSE);
	 }
	 if (!xdr_writeverf3(xdrs, objp->verf)) {
		 return (FALSE);
	 }
	return (TRUE);
}

bool_t
xdr_commit3res(XDR *xdrs, commit3res *objp)
{

	 register int32_t *buf;

	 if (!xdr_nfsstat3(xdrs, &objp->status)) {
		 return (FALSE);
	 }
	switch (objp->status) {
	case NFS3_OK:
		 if (!xdr_commit3resok(xdrs, &objp->RPC_UNION_NAME(commit3res).resok)) {
			 return (FALSE);
		 }
		break;
	default:
		 if (!xdr_wcc_data(xdrs, &objp->RPC_UNION_NAME(commit3res).resfail)) {
			 return (FALSE);
		 }
		break;
	}
	return (TRUE);
}

const struct rpcgen_table nfs_program_3_table[] = {
    {
	(char *(*)())RPCGEN_ACTION(nfsproc3_null_3_svc),
	(xdrproc_t) xdr_void,		0,
	(xdrproc_t) xdr_void,		0,
    },
    {
	(char *(*)())RPCGEN_ACTION(nfsproc3_getattr_3_svc),
	(xdrproc_t) xdr_nfs_fh3,	sizeof ( nfs_fh3 ),
	(xdrproc_t) xdr_getattr3res,	sizeof ( getattr3res ),
    },
    {
	(char *(*)())RPCGEN_ACTION(nfsproc3_setattr_3_svc),
	(xdrproc_t) xdr_setattr3args,	sizeof ( setattr3args ),
	(xdrproc_t) xdr_wccstat3,	sizeof ( wccstat3 ),
    },
    {
	(char *(*)())RPCGEN_ACTION(nfsproc3_lookup_3_svc),
	(xdrproc_t) xdr_diropargs3,	sizeof ( diropargs3 ),
	(xdrproc_t) xdr_lookup3res,	sizeof ( lookup3res ),
    },
    {
	(char *(*)())RPCGEN_ACTION(nfsproc3_access_3_svc),
	(xdrproc_t) xdr_access3args,	sizeof ( access3args ),
	(xdrproc_t) xdr_access3res,	sizeof ( access3res ),
    },
    {
	(char *(*)())RPCGEN_ACTION(nfsproc3_readlink_3_svc),
	(xdrproc_t) xdr_nfs_fh3,	sizeof ( nfs_fh3 ),
	(xdrproc_t) xdr_readlink3res,	sizeof ( readlink3res ),
    },
    {
	(char *(*)())RPCGEN_ACTION(nfsproc3_read_3_svc),
	(xdrproc_t) xdr_read3args,	sizeof ( read3args ),
	(xdrproc_t) xdr_read3res,	sizeof ( read3res ),
    },
    {
	(char *(*)())RPCGEN_ACTION(nfsproc3_write_3_svc),
	(xdrproc_t) xdr_write3args,	sizeof ( write3args ),
	(xdrproc_t) xdr_write3res,	sizeof ( write3res ),
    },
    {
	(char *(*)())RPCGEN_ACTION(nfsproc3_create_3_svc),
	(xdrproc_t) xdr_create3args,	sizeof ( create3args ),
	(xdrproc_t) xdr_diropres3,	sizeof ( diropres3 ),
    },
    {
	(char *(*)())RPCGEN_ACTION(nfsproc3_mkdir_3_svc),
	(xdrproc_t) xdr_mkdir3args,	sizeof ( mkdir3args ),
	(xdrproc_t) xdr_diropres3,	sizeof ( diropres3 ),
    },
    {
	(char *(*)())RPCGEN_ACTION(nfsproc3_symlink_3_svc),
	(xdrproc_t) xdr_symlink3args,	sizeof ( symlink3args ),
	(xdrproc_t) xdr_diropres3,	sizeof ( diropres3 ),
    },
    {
	(char *(*)())RPCGEN_ACTION(nfsproc3_mknod_3_svc),
	(xdrproc_t) xdr_mknod3args,	sizeof ( mknod3args ),
	(xdrproc_t) xdr_diropres3,	sizeof ( diropres3 ),
    },
    {
	(char *(*)())RPCGEN_ACTION(nfsproc3_remove_3_svc),
	(xdrproc_t) xdr_diropargs3,	sizeof ( diropargs3 ),
	(xdrproc_t) xdr_wccstat3,	sizeof ( wccstat3 ),
    },
    {
	(char *(*)())RPCGEN_ACTION(nfsproc3_rmdir_3_svc),
	(xdrproc_t) xdr_diropargs3,	sizeof ( diropargs3 ),
	(xdrproc_t) xdr_wccstat3,	sizeof ( wccstat3 ),
    },
    {
	(char *(*)())RPCGEN_ACTION(nfsproc3_rename_3_svc),
	(xdrproc_t) xdr_rename3args,	sizeof ( rename3args ),
	(xdrproc_t) xdr_rename3res,	sizeof ( rename3res ),
    },
    {
	(char *(*)())RPCGEN_ACTION(nfsproc3_link_3_svc),
	(xdrproc_t) xdr_link3args,	sizeof ( link3args ),
	(xdrproc_t) xdr_link3res,	sizeof ( link3res ),
    },
    {
	(char *(*)())RPCGEN_ACTION(nfsproc3_readdir_3_svc),
	(xdrproc_t) xdr_readdir3args,	sizeof ( readdir3args ),
	(xdrproc_t) xdr_readdir3res,	sizeof ( readdir3res ),
    },
    {
	(char *(*)())RPCGEN_ACTION(nfsproc3_readdirplus_3_svc),
	(xdrproc_t) xdr_readdirplus3args,sizeof ( readdirplus3args ),
	(xdrproc_t) xdr_readdirplus3res,sizeof ( readdirplus3res ),
    },
    {
	(char *(*)())RPCGEN_ACTION(nfsproc3_fsstat_3_svc),
	(xdrproc_t) xdr_nfs_fh3,	sizeof ( nfs_fh3 ),
	(xdrproc_t) xdr_fsstat3res,	sizeof ( fsstat3res ),
    },
    {
	(char *(*)())RPCGEN_ACTION(nfsproc3_fsinfo_3_svc),
	(xdrproc_t) xdr_nfs_fh3,	sizeof ( nfs_fh3 ),
	(xdrproc_t) xdr_fsinfo3res,	sizeof ( fsinfo3res ),
    },
    {
	(char *(*)())RPCGEN_ACTION(nfsproc3_pathconf_3_svc),
	(xdrproc_t) xdr_nfs_fh3,	sizeof ( nfs_fh3 ),
	(xdrproc_t) xdr_pathconf3res,	sizeof ( pathconf3res ),
    },
    {
	(char *(*)())RPCGEN_ACTION(nfsproc3_commit_3_svc),
	(xdrproc_t) xdr_commit3args,	sizeof ( commit3args ),
	(xdrproc_t) xdr_commit3res,	sizeof ( commit3res ),
    },
};
const int nfs_program_3_nproc =
	sizeof(nfs_program_3_table)/sizeof(nfs_program_3_table[0]);
const struct rpc_program nfs_program_3 = {
	NFS_PROGRAM, 3, nfs_program_3_table,
	sizeof (nfs_program_3_table) / sizeof (nfs_program_3_table[0])
};

