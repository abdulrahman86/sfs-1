// -*-c++-*-
/* This file was automatically generated by rpcc. */

#include "nfs3_prot.h"

#ifdef MAINTAINER

void
print_uint64 (const void *_objp, const strbuf *_sbp, int _recdepth,
              const char *_name, const char *_prefix)
{
  rpc_print (_sbp ? *_sbp : warnx, *static_cast<const uint64 *> (_objp),
             _recdepth, _name, _prefix);
}
void
dump_uint64 (const uint64 *objp)
{
  rpc_print (warnx, *objp);
}

void
print_int64 (const void *_objp, const strbuf *_sbp, int _recdepth,
             const char *_name, const char *_prefix)
{
  rpc_print (_sbp ? *_sbp : warnx, *static_cast<const int64 *> (_objp),
             _recdepth, _name, _prefix);
}
void
dump_int64 (const int64 *objp)
{
  rpc_print (warnx, *objp);
}

void
print_uint32 (const void *_objp, const strbuf *_sbp, int _recdepth,
              const char *_name, const char *_prefix)
{
  rpc_print (_sbp ? *_sbp : warnx, *static_cast<const uint32 *> (_objp),
             _recdepth, _name, _prefix);
}
void
dump_uint32 (const uint32 *objp)
{
  rpc_print (warnx, *objp);
}

void
print_int32 (const void *_objp, const strbuf *_sbp, int _recdepth,
             const char *_name, const char *_prefix)
{
  rpc_print (_sbp ? *_sbp : warnx, *static_cast<const int32 *> (_objp),
             _recdepth, _name, _prefix);
}
void
dump_int32 (const int32 *objp)
{
  rpc_print (warnx, *objp);
}

void
print_filename3 (const void *_objp, const strbuf *_sbp, int _recdepth,
                 const char *_name, const char *_prefix)
{
  rpc_print (_sbp ? *_sbp : warnx, *static_cast<const filename3 *> (_objp),
             _recdepth, _name, _prefix);
}
void
dump_filename3 (const filename3 *objp)
{
  rpc_print (warnx, *objp);
}

void
print_nfspath3 (const void *_objp, const strbuf *_sbp, int _recdepth,
                const char *_name, const char *_prefix)
{
  rpc_print (_sbp ? *_sbp : warnx, *static_cast<const nfspath3 *> (_objp),
             _recdepth, _name, _prefix);
}
void
dump_nfspath3 (const nfspath3 *objp)
{
  rpc_print (warnx, *objp);
}

void
print_cookieverf3 (const void *_objp, const strbuf *_sbp, int _recdepth,
                   const char *_name, const char *_prefix)
{
  rpc_print (_sbp ? *_sbp : warnx, *static_cast<const cookieverf3 *> (_objp),
             _recdepth, _name, _prefix);
}
void
dump_cookieverf3 (const cookieverf3 *objp)
{
  rpc_print (warnx, *objp);
}

void
print_createverf3 (const void *_objp, const strbuf *_sbp, int _recdepth,
                   const char *_name, const char *_prefix)
{
  rpc_print (_sbp ? *_sbp : warnx, *static_cast<const createverf3 *> (_objp),
             _recdepth, _name, _prefix);
}
void
dump_createverf3 (const createverf3 *objp)
{
  rpc_print (warnx, *objp);
}

void
print_writeverf3 (const void *_objp, const strbuf *_sbp, int _recdepth,
                  const char *_name, const char *_prefix)
{
  rpc_print (_sbp ? *_sbp : warnx, *static_cast<const writeverf3 *> (_objp),
             _recdepth, _name, _prefix);
}
void
dump_writeverf3 (const writeverf3 *objp)
{
  rpc_print (warnx, *objp);
}

const strbuf &
rpc_print (const strbuf &sb, const nfsstat3 &obj, int recdepth,
           const char *name, const char *prefix)
{
  char *p;
  switch (obj) {
  case NFS3_OK:
    p = "NFS3_OK";
    break;
  case NFS3ERR_PERM:
    p = "NFS3ERR_PERM";
    break;
  case NFS3ERR_NOENT:
    p = "NFS3ERR_NOENT";
    break;
  case NFS3ERR_IO:
    p = "NFS3ERR_IO";
    break;
  case NFS3ERR_NXIO:
    p = "NFS3ERR_NXIO";
    break;
  case NFS3ERR_ACCES:
    p = "NFS3ERR_ACCES";
    break;
  case NFS3ERR_EXIST:
    p = "NFS3ERR_EXIST";
    break;
  case NFS3ERR_XDEV:
    p = "NFS3ERR_XDEV";
    break;
  case NFS3ERR_NODEV:
    p = "NFS3ERR_NODEV";
    break;
  case NFS3ERR_NOTDIR:
    p = "NFS3ERR_NOTDIR";
    break;
  case NFS3ERR_ISDIR:
    p = "NFS3ERR_ISDIR";
    break;
  case NFS3ERR_INVAL:
    p = "NFS3ERR_INVAL";
    break;
  case NFS3ERR_FBIG:
    p = "NFS3ERR_FBIG";
    break;
  case NFS3ERR_NOSPC:
    p = "NFS3ERR_NOSPC";
    break;
  case NFS3ERR_ROFS:
    p = "NFS3ERR_ROFS";
    break;
  case NFS3ERR_MLINK:
    p = "NFS3ERR_MLINK";
    break;
  case NFS3ERR_NAMETOOLONG:
    p = "NFS3ERR_NAMETOOLONG";
    break;
  case NFS3ERR_NOTEMPTY:
    p = "NFS3ERR_NOTEMPTY";
    break;
  case NFS3ERR_DQUOT:
    p = "NFS3ERR_DQUOT";
    break;
  case NFS3ERR_STALE:
    p = "NFS3ERR_STALE";
    break;
  case NFS3ERR_REMOTE:
    p = "NFS3ERR_REMOTE";
    break;
  case NFS3ERR_BADHANDLE:
    p = "NFS3ERR_BADHANDLE";
    break;
  case NFS3ERR_NOT_SYNC:
    p = "NFS3ERR_NOT_SYNC";
    break;
  case NFS3ERR_BAD_COOKIE:
    p = "NFS3ERR_BAD_COOKIE";
    break;
  case NFS3ERR_NOTSUPP:
    p = "NFS3ERR_NOTSUPP";
    break;
  case NFS3ERR_TOOSMALL:
    p = "NFS3ERR_TOOSMALL";
    break;
  case NFS3ERR_SERVERFAULT:
    p = "NFS3ERR_SERVERFAULT";
    break;
  case NFS3ERR_BADTYPE:
    p = "NFS3ERR_BADTYPE";
    break;
  case NFS3ERR_JUKEBOX:
    p = "NFS3ERR_JUKEBOX";
    break;
  default:
    p = NULL;
    break;
  }
  if (name) {
    if (prefix)
      sb << prefix;
    sb << "nfsstat3 " << name << " = ";
  };
  if (p)
    sb << p;
  else
    sb << int (obj);
  if (prefix)
    sb << ";\n";
  return sb;
};
void
print_nfsstat3 (const void *_objp, const strbuf *_sbp, int _recdepth,
                const char *_name, const char *_prefix)
{
  rpc_print (_sbp ? *_sbp : warnx, *static_cast<const nfsstat3 *> (_objp),
             _recdepth, _name, _prefix);
}
void
dump_nfsstat3 (const nfsstat3 *objp)
{
  rpc_print (warnx, *objp);
}

const strbuf &
rpc_print (const strbuf &sb, const ftype3 &obj, int recdepth,
           const char *name, const char *prefix)
{
  char *p;
  switch (obj) {
  case NF3REG:
    p = "NF3REG";
    break;
  case NF3DIR:
    p = "NF3DIR";
    break;
  case NF3BLK:
    p = "NF3BLK";
    break;
  case NF3CHR:
    p = "NF3CHR";
    break;
  case NF3LNK:
    p = "NF3LNK";
    break;
  case NF3SOCK:
    p = "NF3SOCK";
    break;
  case NF3FIFO:
    p = "NF3FIFO";
    break;
  default:
    p = NULL;
    break;
  }
  if (name) {
    if (prefix)
      sb << prefix;
    sb << "ftype3 " << name << " = ";
  };
  if (p)
    sb << p;
  else
    sb << int (obj);
  if (prefix)
    sb << ";\n";
  return sb;
};
void
print_ftype3 (const void *_objp, const strbuf *_sbp, int _recdepth,
              const char *_name, const char *_prefix)
{
  rpc_print (_sbp ? *_sbp : warnx, *static_cast<const ftype3 *> (_objp),
             _recdepth, _name, _prefix);
}
void
dump_ftype3 (const ftype3 *objp)
{
  rpc_print (warnx, *objp);
}

const strbuf &
rpc_print (const strbuf &sb, const specdata3 &obj, int recdepth,
           const char *name, const char *prefix)
{
  if (name) {
    if (prefix)
      sb << prefix;
    sb << "specdata3 " << name << " = ";
  };
  const char *sep;
  str npref;
  if (prefix) {
    npref = strbuf ("%s  ", prefix);
    sep = "";
    sb << "{\n";
  }
  else {
    sep = ", ";
    sb << "{ ";
  }
  rpc_print (sb, obj.major, recdepth, "major", npref);
  sb << sep;
  rpc_print (sb, obj.minor, recdepth, "minor", npref);
  if (prefix)
    sb << prefix << "};\n";
  else
    sb << " }";
  return sb;
}
void
print_specdata3 (const void *_objp, const strbuf *_sbp, int _recdepth,
                 const char *_name, const char *_prefix)
{
  rpc_print (_sbp ? *_sbp : warnx, *static_cast<const specdata3 *> (_objp),
             _recdepth, _name, _prefix);
}
void
dump_specdata3 (const specdata3 *objp)
{
  rpc_print (warnx, *objp);
}

const strbuf &
rpc_print (const strbuf &sb, const nfs_fh3 &obj, int recdepth,
           const char *name, const char *prefix)
{
  if (name) {
    if (prefix)
      sb << prefix;
    sb << "nfs_fh3 " << name << " = ";
  };
  const char *sep;
  str npref;
  if (prefix) {
    npref = strbuf ("%s  ", prefix);
    sep = "";
    sb << "{\n";
  }
  else {
    sep = ", ";
    sb << "{ ";
  }
  rpc_print (sb, obj.data, recdepth, "data", npref);
  if (prefix)
    sb << prefix << "};\n";
  else
    sb << " }";
  return sb;
}
void
print_nfs_fh3 (const void *_objp, const strbuf *_sbp, int _recdepth,
               const char *_name, const char *_prefix)
{
  rpc_print (_sbp ? *_sbp : warnx, *static_cast<const nfs_fh3 *> (_objp),
             _recdepth, _name, _prefix);
}
void
dump_nfs_fh3 (const nfs_fh3 *objp)
{
  rpc_print (warnx, *objp);
}

const strbuf &
rpc_print (const strbuf &sb, const nfstime3 &obj, int recdepth,
           const char *name, const char *prefix)
{
  if (name) {
    if (prefix)
      sb << prefix;
    sb << "nfstime3 " << name << " = ";
  };
  const char *sep;
  str npref;
  if (prefix) {
    npref = strbuf ("%s  ", prefix);
    sep = "";
    sb << "{\n";
  }
  else {
    sep = ", ";
    sb << "{ ";
  }
  rpc_print (sb, obj.seconds, recdepth, "seconds", npref);
  sb << sep;
  rpc_print (sb, obj.nseconds, recdepth, "nseconds", npref);
  if (prefix)
    sb << prefix << "};\n";
  else
    sb << " }";
  return sb;
}
void
print_nfstime3 (const void *_objp, const strbuf *_sbp, int _recdepth,
                const char *_name, const char *_prefix)
{
  rpc_print (_sbp ? *_sbp : warnx, *static_cast<const nfstime3 *> (_objp),
             _recdepth, _name, _prefix);
}
void
dump_nfstime3 (const nfstime3 *objp)
{
  rpc_print (warnx, *objp);
}

const strbuf &
rpc_print (const strbuf &sb, const fattr3 &obj, int recdepth,
           const char *name, const char *prefix)
{
  if (name) {
    if (prefix)
      sb << prefix;
    sb << "fattr3 " << name << " = ";
  };
  const char *sep;
  str npref;
  if (prefix) {
    npref = strbuf ("%s  ", prefix);
    sep = "";
    sb << "{\n";
  }
  else {
    sep = ", ";
    sb << "{ ";
  }
  rpc_print (sb, obj.type, recdepth, "type", npref);
  sb << sep;
  rpc_print (sb, obj.mode, recdepth, "mode", npref);
  sb << sep;
  rpc_print (sb, obj.nlink, recdepth, "nlink", npref);
  sb << sep;
  rpc_print (sb, obj.uid, recdepth, "uid", npref);
  sb << sep;
  rpc_print (sb, obj.gid, recdepth, "gid", npref);
  sb << sep;
  rpc_print (sb, obj.size, recdepth, "size", npref);
  sb << sep;
  rpc_print (sb, obj.used, recdepth, "used", npref);
  sb << sep;
  rpc_print (sb, obj.rdev, recdepth, "rdev", npref);
  sb << sep;
  rpc_print (sb, obj.fsid, recdepth, "fsid", npref);
  sb << sep;
  rpc_print (sb, obj.fileid, recdepth, "fileid", npref);
  sb << sep;
  rpc_print (sb, obj.atime, recdepth, "atime", npref);
  sb << sep;
  rpc_print (sb, obj.mtime, recdepth, "mtime", npref);
  sb << sep;
  rpc_print (sb, obj.ctime, recdepth, "ctime", npref);
  if (prefix)
    sb << prefix << "};\n";
  else
    sb << " }";
  return sb;
}
void
print_fattr3 (const void *_objp, const strbuf *_sbp, int _recdepth,
              const char *_name, const char *_prefix)
{
  rpc_print (_sbp ? *_sbp : warnx, *static_cast<const fattr3 *> (_objp),
             _recdepth, _name, _prefix);
}
void
dump_fattr3 (const fattr3 *objp)
{
  rpc_print (warnx, *objp);
}

const strbuf &
rpc_print (const strbuf &sb, const post_op_attr &obj, int recdepth,
           const char *name, const char *prefix)
{
  if (name) {
    if (prefix)
      sb << prefix;
    sb << "post_op_attr " << name << " = ";
  };
  const char *sep;
  str npref;
  if (prefix) {
    npref = strbuf ("%s  ", prefix);
    sep = "";
    sb << "{\n";
  }
  else {
    sep = ", ";
    sb << "{ ";
  }
  rpc_print (sb, obj.present, recdepth, "present", npref);
  switch (obj.present) {
  case true:
    sb << sep;
    rpc_print (sb, *obj.attributes,  recdepth, "attributes", npref);
    break;
  case false:
    break;
  default:
    break;
  }
  if (prefix)
    sb << prefix << "};\n";
  else
    sb << " }";
  return sb;
}
void
print_post_op_attr (const void *_objp, const strbuf *_sbp, int _recdepth,
                    const char *_name, const char *_prefix)
{
  rpc_print (_sbp ? *_sbp : warnx, *static_cast<const post_op_attr *> (_objp),
             _recdepth, _name, _prefix);
}
void
dump_post_op_attr (const post_op_attr *objp)
{
  rpc_print (warnx, *objp);
}

const strbuf &
rpc_print (const strbuf &sb, const wcc_attr &obj, int recdepth,
           const char *name, const char *prefix)
{
  if (name) {
    if (prefix)
      sb << prefix;
    sb << "wcc_attr " << name << " = ";
  };
  const char *sep;
  str npref;
  if (prefix) {
    npref = strbuf ("%s  ", prefix);
    sep = "";
    sb << "{\n";
  }
  else {
    sep = ", ";
    sb << "{ ";
  }
  rpc_print (sb, obj.size, recdepth, "size", npref);
  sb << sep;
  rpc_print (sb, obj.mtime, recdepth, "mtime", npref);
  sb << sep;
  rpc_print (sb, obj.ctime, recdepth, "ctime", npref);
  if (prefix)
    sb << prefix << "};\n";
  else
    sb << " }";
  return sb;
}
void
print_wcc_attr (const void *_objp, const strbuf *_sbp, int _recdepth,
                const char *_name, const char *_prefix)
{
  rpc_print (_sbp ? *_sbp : warnx, *static_cast<const wcc_attr *> (_objp),
             _recdepth, _name, _prefix);
}
void
dump_wcc_attr (const wcc_attr *objp)
{
  rpc_print (warnx, *objp);
}

const strbuf &
rpc_print (const strbuf &sb, const pre_op_attr &obj, int recdepth,
           const char *name, const char *prefix)
{
  if (name) {
    if (prefix)
      sb << prefix;
    sb << "pre_op_attr " << name << " = ";
  };
  const char *sep;
  str npref;
  if (prefix) {
    npref = strbuf ("%s  ", prefix);
    sep = "";
    sb << "{\n";
  }
  else {
    sep = ", ";
    sb << "{ ";
  }
  rpc_print (sb, obj.present, recdepth, "present", npref);
  switch (obj.present) {
  case true:
    sb << sep;
    rpc_print (sb, *obj.attributes,  recdepth, "attributes", npref);
    break;
  case false:
    break;
  default:
    break;
  }
  if (prefix)
    sb << prefix << "};\n";
  else
    sb << " }";
  return sb;
}
void
print_pre_op_attr (const void *_objp, const strbuf *_sbp, int _recdepth,
                   const char *_name, const char *_prefix)
{
  rpc_print (_sbp ? *_sbp : warnx, *static_cast<const pre_op_attr *> (_objp),
             _recdepth, _name, _prefix);
}
void
dump_pre_op_attr (const pre_op_attr *objp)
{
  rpc_print (warnx, *objp);
}

const strbuf &
rpc_print (const strbuf &sb, const wcc_data &obj, int recdepth,
           const char *name, const char *prefix)
{
  if (name) {
    if (prefix)
      sb << prefix;
    sb << "wcc_data " << name << " = ";
  };
  const char *sep;
  str npref;
  if (prefix) {
    npref = strbuf ("%s  ", prefix);
    sep = "";
    sb << "{\n";
  }
  else {
    sep = ", ";
    sb << "{ ";
  }
  rpc_print (sb, obj.before, recdepth, "before", npref);
  sb << sep;
  rpc_print (sb, obj.after, recdepth, "after", npref);
  if (prefix)
    sb << prefix << "};\n";
  else
    sb << " }";
  return sb;
}
void
print_wcc_data (const void *_objp, const strbuf *_sbp, int _recdepth,
                const char *_name, const char *_prefix)
{
  rpc_print (_sbp ? *_sbp : warnx, *static_cast<const wcc_data *> (_objp),
             _recdepth, _name, _prefix);
}
void
dump_wcc_data (const wcc_data *objp)
{
  rpc_print (warnx, *objp);
}

const strbuf &
rpc_print (const strbuf &sb, const post_op_fh3 &obj, int recdepth,
           const char *name, const char *prefix)
{
  if (name) {
    if (prefix)
      sb << prefix;
    sb << "post_op_fh3 " << name << " = ";
  };
  const char *sep;
  str npref;
  if (prefix) {
    npref = strbuf ("%s  ", prefix);
    sep = "";
    sb << "{\n";
  }
  else {
    sep = ", ";
    sb << "{ ";
  }
  rpc_print (sb, obj.present, recdepth, "present", npref);
  switch (obj.present) {
  case true:
    sb << sep;
    rpc_print (sb, *obj.handle,  recdepth, "handle", npref);
    break;
  case false:
    break;
  default:
    break;
  }
  if (prefix)
    sb << prefix << "};\n";
  else
    sb << " }";
  return sb;
}
void
print_post_op_fh3 (const void *_objp, const strbuf *_sbp, int _recdepth,
                   const char *_name, const char *_prefix)
{
  rpc_print (_sbp ? *_sbp : warnx, *static_cast<const post_op_fh3 *> (_objp),
             _recdepth, _name, _prefix);
}
void
dump_post_op_fh3 (const post_op_fh3 *objp)
{
  rpc_print (warnx, *objp);
}

const strbuf &
rpc_print (const strbuf &sb, const set_uint32 &obj, int recdepth,
           const char *name, const char *prefix)
{
  if (name) {
    if (prefix)
      sb << prefix;
    sb << "set_uint32 " << name << " = ";
  };
  const char *sep;
  str npref;
  if (prefix) {
    npref = strbuf ("%s  ", prefix);
    sep = "";
    sb << "{\n";
  }
  else {
    sep = ", ";
    sb << "{ ";
  }
  rpc_print (sb, obj.set, recdepth, "set", npref);
  switch (obj.set) {
  case true:
    sb << sep;
    rpc_print (sb, *obj.val,  recdepth, "val", npref);
    break;
  default:
    break;
  }
  if (prefix)
    sb << prefix << "};\n";
  else
    sb << " }";
  return sb;
}
void
print_set_uint32 (const void *_objp, const strbuf *_sbp, int _recdepth,
                  const char *_name, const char *_prefix)
{
  rpc_print (_sbp ? *_sbp : warnx, *static_cast<const set_uint32 *> (_objp),
             _recdepth, _name, _prefix);
}
void
dump_set_uint32 (const set_uint32 *objp)
{
  rpc_print (warnx, *objp);
}

const strbuf &
rpc_print (const strbuf &sb, const set_uint64 &obj, int recdepth,
           const char *name, const char *prefix)
{
  if (name) {
    if (prefix)
      sb << prefix;
    sb << "set_uint64 " << name << " = ";
  };
  const char *sep;
  str npref;
  if (prefix) {
    npref = strbuf ("%s  ", prefix);
    sep = "";
    sb << "{\n";
  }
  else {
    sep = ", ";
    sb << "{ ";
  }
  rpc_print (sb, obj.set, recdepth, "set", npref);
  switch (obj.set) {
  case true:
    sb << sep;
    rpc_print (sb, *obj.val,  recdepth, "val", npref);
    break;
  default:
    break;
  }
  if (prefix)
    sb << prefix << "};\n";
  else
    sb << " }";
  return sb;
}
void
print_set_uint64 (const void *_objp, const strbuf *_sbp, int _recdepth,
                  const char *_name, const char *_prefix)
{
  rpc_print (_sbp ? *_sbp : warnx, *static_cast<const set_uint64 *> (_objp),
             _recdepth, _name, _prefix);
}
void
dump_set_uint64 (const set_uint64 *objp)
{
  rpc_print (warnx, *objp);
}

const strbuf &
rpc_print (const strbuf &sb, const time_how &obj, int recdepth,
           const char *name, const char *prefix)
{
  char *p;
  switch (obj) {
  case DONT_CHANGE:
    p = "DONT_CHANGE";
    break;
  case SET_TO_SERVER_TIME:
    p = "SET_TO_SERVER_TIME";
    break;
  case SET_TO_CLIENT_TIME:
    p = "SET_TO_CLIENT_TIME";
    break;
  default:
    p = NULL;
    break;
  }
  if (name) {
    if (prefix)
      sb << prefix;
    sb << "time_how " << name << " = ";
  };
  if (p)
    sb << p;
  else
    sb << int (obj);
  if (prefix)
    sb << ";\n";
  return sb;
};
void
print_time_how (const void *_objp, const strbuf *_sbp, int _recdepth,
                const char *_name, const char *_prefix)
{
  rpc_print (_sbp ? *_sbp : warnx, *static_cast<const time_how *> (_objp),
             _recdepth, _name, _prefix);
}
void
dump_time_how (const time_how *objp)
{
  rpc_print (warnx, *objp);
}

const strbuf &
rpc_print (const strbuf &sb, const set_time &obj, int recdepth,
           const char *name, const char *prefix)
{
  if (name) {
    if (prefix)
      sb << prefix;
    sb << "set_time " << name << " = ";
  };
  const char *sep;
  str npref;
  if (prefix) {
    npref = strbuf ("%s  ", prefix);
    sep = "";
    sb << "{\n";
  }
  else {
    sep = ", ";
    sb << "{ ";
  }
  rpc_print (sb, obj.set, recdepth, "set", npref);
  switch (obj.set) {
  case SET_TO_CLIENT_TIME:
    sb << sep;
    rpc_print (sb, *obj.time,  recdepth, "time", npref);
    break;
  default:
    break;
  }
  if (prefix)
    sb << prefix << "};\n";
  else
    sb << " }";
  return sb;
}
void
print_set_time (const void *_objp, const strbuf *_sbp, int _recdepth,
                const char *_name, const char *_prefix)
{
  rpc_print (_sbp ? *_sbp : warnx, *static_cast<const set_time *> (_objp),
             _recdepth, _name, _prefix);
}
void
dump_set_time (const set_time *objp)
{
  rpc_print (warnx, *objp);
}

const strbuf &
rpc_print (const strbuf &sb, const sattr3 &obj, int recdepth,
           const char *name, const char *prefix)
{
  if (name) {
    if (prefix)
      sb << prefix;
    sb << "sattr3 " << name << " = ";
  };
  const char *sep;
  str npref;
  if (prefix) {
    npref = strbuf ("%s  ", prefix);
    sep = "";
    sb << "{\n";
  }
  else {
    sep = ", ";
    sb << "{ ";
  }
  rpc_print (sb, obj.mode, recdepth, "mode", npref);
  sb << sep;
  rpc_print (sb, obj.uid, recdepth, "uid", npref);
  sb << sep;
  rpc_print (sb, obj.gid, recdepth, "gid", npref);
  sb << sep;
  rpc_print (sb, obj.size, recdepth, "size", npref);
  sb << sep;
  rpc_print (sb, obj.atime, recdepth, "atime", npref);
  sb << sep;
  rpc_print (sb, obj.mtime, recdepth, "mtime", npref);
  if (prefix)
    sb << prefix << "};\n";
  else
    sb << " }";
  return sb;
}
void
print_sattr3 (const void *_objp, const strbuf *_sbp, int _recdepth,
              const char *_name, const char *_prefix)
{
  rpc_print (_sbp ? *_sbp : warnx, *static_cast<const sattr3 *> (_objp),
             _recdepth, _name, _prefix);
}
void
dump_sattr3 (const sattr3 *objp)
{
  rpc_print (warnx, *objp);
}

const strbuf &
rpc_print (const strbuf &sb, const diropargs3 &obj, int recdepth,
           const char *name, const char *prefix)
{
  if (name) {
    if (prefix)
      sb << prefix;
    sb << "diropargs3 " << name << " = ";
  };
  const char *sep;
  str npref;
  if (prefix) {
    npref = strbuf ("%s  ", prefix);
    sep = "";
    sb << "{\n";
  }
  else {
    sep = ", ";
    sb << "{ ";
  }
  rpc_print (sb, obj.dir, recdepth, "dir", npref);
  sb << sep;
  rpc_print (sb, obj.name, recdepth, "name", npref);
  if (prefix)
    sb << prefix << "};\n";
  else
    sb << " }";
  return sb;
}
void
print_diropargs3 (const void *_objp, const strbuf *_sbp, int _recdepth,
                  const char *_name, const char *_prefix)
{
  rpc_print (_sbp ? *_sbp : warnx, *static_cast<const diropargs3 *> (_objp),
             _recdepth, _name, _prefix);
}
void
dump_diropargs3 (const diropargs3 *objp)
{
  rpc_print (warnx, *objp);
}

const strbuf &
rpc_print (const strbuf &sb, const diropres3ok &obj, int recdepth,
           const char *name, const char *prefix)
{
  if (name) {
    if (prefix)
      sb << prefix;
    sb << "diropres3ok " << name << " = ";
  };
  const char *sep;
  str npref;
  if (prefix) {
    npref = strbuf ("%s  ", prefix);
    sep = "";
    sb << "{\n";
  }
  else {
    sep = ", ";
    sb << "{ ";
  }
  rpc_print (sb, obj.obj, recdepth, "obj", npref);
  sb << sep;
  rpc_print (sb, obj.obj_attributes, recdepth, "obj_attributes", npref);
  sb << sep;
  rpc_print (sb, obj.dir_wcc, recdepth, "dir_wcc", npref);
  if (prefix)
    sb << prefix << "};\n";
  else
    sb << " }";
  return sb;
}
void
print_diropres3ok (const void *_objp, const strbuf *_sbp, int _recdepth,
                   const char *_name, const char *_prefix)
{
  rpc_print (_sbp ? *_sbp : warnx, *static_cast<const diropres3ok *> (_objp),
             _recdepth, _name, _prefix);
}
void
dump_diropres3ok (const diropres3ok *objp)
{
  rpc_print (warnx, *objp);
}

const strbuf &
rpc_print (const strbuf &sb, const diropres3 &obj, int recdepth,
           const char *name, const char *prefix)
{
  if (name) {
    if (prefix)
      sb << prefix;
    sb << "diropres3 " << name << " = ";
  };
  const char *sep;
  str npref;
  if (prefix) {
    npref = strbuf ("%s  ", prefix);
    sep = "";
    sb << "{\n";
  }
  else {
    sep = ", ";
    sb << "{ ";
  }
  rpc_print (sb, obj.status, recdepth, "status", npref);
  switch (obj.status) {
  case NFS3_OK:
    sb << sep;
    rpc_print (sb, *obj.resok,  recdepth, "resok", npref);
    break;
  default:
    sb << sep;
    rpc_print (sb, *obj.resfail,  recdepth, "resfail", npref);
    break;
  }
  if (prefix)
    sb << prefix << "};\n";
  else
    sb << " }";
  return sb;
}
void
print_diropres3 (const void *_objp, const strbuf *_sbp, int _recdepth,
                 const char *_name, const char *_prefix)
{
  rpc_print (_sbp ? *_sbp : warnx, *static_cast<const diropres3 *> (_objp),
             _recdepth, _name, _prefix);
}
void
dump_diropres3 (const diropres3 *objp)
{
  rpc_print (warnx, *objp);
}

const strbuf &
rpc_print (const strbuf &sb, const wccstat3 &obj, int recdepth,
           const char *name, const char *prefix)
{
  if (name) {
    if (prefix)
      sb << prefix;
    sb << "wccstat3 " << name << " = ";
  };
  const char *sep;
  str npref;
  if (prefix) {
    npref = strbuf ("%s  ", prefix);
    sep = "";
    sb << "{\n";
  }
  else {
    sep = ", ";
    sb << "{ ";
  }
  rpc_print (sb, obj.status, recdepth, "status", npref);
  switch (obj.status) {
  case -1:
    break;
  default:
    sb << sep;
    rpc_print (sb, *obj.wcc,  recdepth, "wcc", npref);
    break;
  }
  if (prefix)
    sb << prefix << "};\n";
  else
    sb << " }";
  return sb;
}
void
print_wccstat3 (const void *_objp, const strbuf *_sbp, int _recdepth,
                const char *_name, const char *_prefix)
{
  rpc_print (_sbp ? *_sbp : warnx, *static_cast<const wccstat3 *> (_objp),
             _recdepth, _name, _prefix);
}
void
dump_wccstat3 (const wccstat3 *objp)
{
  rpc_print (warnx, *objp);
}

const strbuf &
rpc_print (const strbuf &sb, const getattr3res &obj, int recdepth,
           const char *name, const char *prefix)
{
  if (name) {
    if (prefix)
      sb << prefix;
    sb << "getattr3res " << name << " = ";
  };
  const char *sep;
  str npref;
  if (prefix) {
    npref = strbuf ("%s  ", prefix);
    sep = "";
    sb << "{\n";
  }
  else {
    sep = ", ";
    sb << "{ ";
  }
  rpc_print (sb, obj.status, recdepth, "status", npref);
  switch (obj.status) {
  case NFS3_OK:
    sb << sep;
    rpc_print (sb, *obj.attributes,  recdepth, "attributes", npref);
    break;
  default:
    break;
  }
  if (prefix)
    sb << prefix << "};\n";
  else
    sb << " }";
  return sb;
}
void
print_getattr3res (const void *_objp, const strbuf *_sbp, int _recdepth,
                   const char *_name, const char *_prefix)
{
  rpc_print (_sbp ? *_sbp : warnx, *static_cast<const getattr3res *> (_objp),
             _recdepth, _name, _prefix);
}
void
dump_getattr3res (const getattr3res *objp)
{
  rpc_print (warnx, *objp);
}

const strbuf &
rpc_print (const strbuf &sb, const sattrguard3 &obj, int recdepth,
           const char *name, const char *prefix)
{
  if (name) {
    if (prefix)
      sb << prefix;
    sb << "sattrguard3 " << name << " = ";
  };
  const char *sep;
  str npref;
  if (prefix) {
    npref = strbuf ("%s  ", prefix);
    sep = "";
    sb << "{\n";
  }
  else {
    sep = ", ";
    sb << "{ ";
  }
  rpc_print (sb, obj.check, recdepth, "check", npref);
  switch (obj.check) {
  case true:
    sb << sep;
    rpc_print (sb, *obj.ctime,  recdepth, "ctime", npref);
    break;
  case false:
    break;
  default:
    break;
  }
  if (prefix)
    sb << prefix << "};\n";
  else
    sb << " }";
  return sb;
}
void
print_sattrguard3 (const void *_objp, const strbuf *_sbp, int _recdepth,
                   const char *_name, const char *_prefix)
{
  rpc_print (_sbp ? *_sbp : warnx, *static_cast<const sattrguard3 *> (_objp),
             _recdepth, _name, _prefix);
}
void
dump_sattrguard3 (const sattrguard3 *objp)
{
  rpc_print (warnx, *objp);
}

const strbuf &
rpc_print (const strbuf &sb, const setattr3args &obj, int recdepth,
           const char *name, const char *prefix)
{
  if (name) {
    if (prefix)
      sb << prefix;
    sb << "setattr3args " << name << " = ";
  };
  const char *sep;
  str npref;
  if (prefix) {
    npref = strbuf ("%s  ", prefix);
    sep = "";
    sb << "{\n";
  }
  else {
    sep = ", ";
    sb << "{ ";
  }
  rpc_print (sb, obj.object, recdepth, "object", npref);
  sb << sep;
  rpc_print (sb, obj.new_attributes, recdepth, "new_attributes", npref);
  sb << sep;
  rpc_print (sb, obj.guard, recdepth, "guard", npref);
  if (prefix)
    sb << prefix << "};\n";
  else
    sb << " }";
  return sb;
}
void
print_setattr3args (const void *_objp, const strbuf *_sbp, int _recdepth,
                    const char *_name, const char *_prefix)
{
  rpc_print (_sbp ? *_sbp : warnx, *static_cast<const setattr3args *> (_objp),
             _recdepth, _name, _prefix);
}
void
dump_setattr3args (const setattr3args *objp)
{
  rpc_print (warnx, *objp);
}

const strbuf &
rpc_print (const strbuf &sb, const lookup3resok &obj, int recdepth,
           const char *name, const char *prefix)
{
  if (name) {
    if (prefix)
      sb << prefix;
    sb << "lookup3resok " << name << " = ";
  };
  const char *sep;
  str npref;
  if (prefix) {
    npref = strbuf ("%s  ", prefix);
    sep = "";
    sb << "{\n";
  }
  else {
    sep = ", ";
    sb << "{ ";
  }
  rpc_print (sb, obj.object, recdepth, "object", npref);
  sb << sep;
  rpc_print (sb, obj.obj_attributes, recdepth, "obj_attributes", npref);
  sb << sep;
  rpc_print (sb, obj.dir_attributes, recdepth, "dir_attributes", npref);
  if (prefix)
    sb << prefix << "};\n";
  else
    sb << " }";
  return sb;
}
void
print_lookup3resok (const void *_objp, const strbuf *_sbp, int _recdepth,
                    const char *_name, const char *_prefix)
{
  rpc_print (_sbp ? *_sbp : warnx, *static_cast<const lookup3resok *> (_objp),
             _recdepth, _name, _prefix);
}
void
dump_lookup3resok (const lookup3resok *objp)
{
  rpc_print (warnx, *objp);
}

const strbuf &
rpc_print (const strbuf &sb, const lookup3res &obj, int recdepth,
           const char *name, const char *prefix)
{
  if (name) {
    if (prefix)
      sb << prefix;
    sb << "lookup3res " << name << " = ";
  };
  const char *sep;
  str npref;
  if (prefix) {
    npref = strbuf ("%s  ", prefix);
    sep = "";
    sb << "{\n";
  }
  else {
    sep = ", ";
    sb << "{ ";
  }
  rpc_print (sb, obj.status, recdepth, "status", npref);
  switch (obj.status) {
  case NFS3_OK:
    sb << sep;
    rpc_print (sb, *obj.resok,  recdepth, "resok", npref);
    break;
  default:
    sb << sep;
    rpc_print (sb, *obj.resfail,  recdepth, "resfail", npref);
    break;
  }
  if (prefix)
    sb << prefix << "};\n";
  else
    sb << " }";
  return sb;
}
void
print_lookup3res (const void *_objp, const strbuf *_sbp, int _recdepth,
                  const char *_name, const char *_prefix)
{
  rpc_print (_sbp ? *_sbp : warnx, *static_cast<const lookup3res *> (_objp),
             _recdepth, _name, _prefix);
}
void
dump_lookup3res (const lookup3res *objp)
{
  rpc_print (warnx, *objp);
}

const strbuf &
rpc_print (const strbuf &sb, const access3args &obj, int recdepth,
           const char *name, const char *prefix)
{
  if (name) {
    if (prefix)
      sb << prefix;
    sb << "access3args " << name << " = ";
  };
  const char *sep;
  str npref;
  if (prefix) {
    npref = strbuf ("%s  ", prefix);
    sep = "";
    sb << "{\n";
  }
  else {
    sep = ", ";
    sb << "{ ";
  }
  rpc_print (sb, obj.object, recdepth, "object", npref);
  sb << sep;
  rpc_print (sb, obj.access, recdepth, "access", npref);
  if (prefix)
    sb << prefix << "};\n";
  else
    sb << " }";
  return sb;
}
void
print_access3args (const void *_objp, const strbuf *_sbp, int _recdepth,
                   const char *_name, const char *_prefix)
{
  rpc_print (_sbp ? *_sbp : warnx, *static_cast<const access3args *> (_objp),
             _recdepth, _name, _prefix);
}
void
dump_access3args (const access3args *objp)
{
  rpc_print (warnx, *objp);
}

const strbuf &
rpc_print (const strbuf &sb, const access3resok &obj, int recdepth,
           const char *name, const char *prefix)
{
  if (name) {
    if (prefix)
      sb << prefix;
    sb << "access3resok " << name << " = ";
  };
  const char *sep;
  str npref;
  if (prefix) {
    npref = strbuf ("%s  ", prefix);
    sep = "";
    sb << "{\n";
  }
  else {
    sep = ", ";
    sb << "{ ";
  }
  rpc_print (sb, obj.obj_attributes, recdepth, "obj_attributes", npref);
  sb << sep;
  rpc_print (sb, obj.access, recdepth, "access", npref);
  if (prefix)
    sb << prefix << "};\n";
  else
    sb << " }";
  return sb;
}
void
print_access3resok (const void *_objp, const strbuf *_sbp, int _recdepth,
                    const char *_name, const char *_prefix)
{
  rpc_print (_sbp ? *_sbp : warnx, *static_cast<const access3resok *> (_objp),
             _recdepth, _name, _prefix);
}
void
dump_access3resok (const access3resok *objp)
{
  rpc_print (warnx, *objp);
}

const strbuf &
rpc_print (const strbuf &sb, const access3res &obj, int recdepth,
           const char *name, const char *prefix)
{
  if (name) {
    if (prefix)
      sb << prefix;
    sb << "access3res " << name << " = ";
  };
  const char *sep;
  str npref;
  if (prefix) {
    npref = strbuf ("%s  ", prefix);
    sep = "";
    sb << "{\n";
  }
  else {
    sep = ", ";
    sb << "{ ";
  }
  rpc_print (sb, obj.status, recdepth, "status", npref);
  switch (obj.status) {
  case NFS3_OK:
    sb << sep;
    rpc_print (sb, *obj.resok,  recdepth, "resok", npref);
    break;
  default:
    sb << sep;
    rpc_print (sb, *obj.resfail,  recdepth, "resfail", npref);
    break;
  }
  if (prefix)
    sb << prefix << "};\n";
  else
    sb << " }";
  return sb;
}
void
print_access3res (const void *_objp, const strbuf *_sbp, int _recdepth,
                  const char *_name, const char *_prefix)
{
  rpc_print (_sbp ? *_sbp : warnx, *static_cast<const access3res *> (_objp),
             _recdepth, _name, _prefix);
}
void
dump_access3res (const access3res *objp)
{
  rpc_print (warnx, *objp);
}

const strbuf &
rpc_print (const strbuf &sb, const readlink3resok &obj, int recdepth,
           const char *name, const char *prefix)
{
  if (name) {
    if (prefix)
      sb << prefix;
    sb << "readlink3resok " << name << " = ";
  };
  const char *sep;
  str npref;
  if (prefix) {
    npref = strbuf ("%s  ", prefix);
    sep = "";
    sb << "{\n";
  }
  else {
    sep = ", ";
    sb << "{ ";
  }
  rpc_print (sb, obj.symlink_attributes, recdepth, "symlink_attributes", npref);
  sb << sep;
  rpc_print (sb, obj.data, recdepth, "data", npref);
  if (prefix)
    sb << prefix << "};\n";
  else
    sb << " }";
  return sb;
}
void
print_readlink3resok (const void *_objp, const strbuf *_sbp, int _recdepth,
                      const char *_name, const char *_prefix)
{
  rpc_print (_sbp ? *_sbp : warnx, *static_cast<const readlink3resok *> (_objp),
             _recdepth, _name, _prefix);
}
void
dump_readlink3resok (const readlink3resok *objp)
{
  rpc_print (warnx, *objp);
}

const strbuf &
rpc_print (const strbuf &sb, const readlink3res &obj, int recdepth,
           const char *name, const char *prefix)
{
  if (name) {
    if (prefix)
      sb << prefix;
    sb << "readlink3res " << name << " = ";
  };
  const char *sep;
  str npref;
  if (prefix) {
    npref = strbuf ("%s  ", prefix);
    sep = "";
    sb << "{\n";
  }
  else {
    sep = ", ";
    sb << "{ ";
  }
  rpc_print (sb, obj.status, recdepth, "status", npref);
  switch (obj.status) {
  case NFS3_OK:
    sb << sep;
    rpc_print (sb, *obj.resok,  recdepth, "resok", npref);
    break;
  default:
    sb << sep;
    rpc_print (sb, *obj.resfail,  recdepth, "resfail", npref);
    break;
  }
  if (prefix)
    sb << prefix << "};\n";
  else
    sb << " }";
  return sb;
}
void
print_readlink3res (const void *_objp, const strbuf *_sbp, int _recdepth,
                    const char *_name, const char *_prefix)
{
  rpc_print (_sbp ? *_sbp : warnx, *static_cast<const readlink3res *> (_objp),
             _recdepth, _name, _prefix);
}
void
dump_readlink3res (const readlink3res *objp)
{
  rpc_print (warnx, *objp);
}

const strbuf &
rpc_print (const strbuf &sb, const read3args &obj, int recdepth,
           const char *name, const char *prefix)
{
  if (name) {
    if (prefix)
      sb << prefix;
    sb << "read3args " << name << " = ";
  };
  const char *sep;
  str npref;
  if (prefix) {
    npref = strbuf ("%s  ", prefix);
    sep = "";
    sb << "{\n";
  }
  else {
    sep = ", ";
    sb << "{ ";
  }
  rpc_print (sb, obj.file, recdepth, "file", npref);
  sb << sep;
  rpc_print (sb, obj.offset, recdepth, "offset", npref);
  sb << sep;
  rpc_print (sb, obj.count, recdepth, "count", npref);
  if (prefix)
    sb << prefix << "};\n";
  else
    sb << " }";
  return sb;
}
void
print_read3args (const void *_objp, const strbuf *_sbp, int _recdepth,
                 const char *_name, const char *_prefix)
{
  rpc_print (_sbp ? *_sbp : warnx, *static_cast<const read3args *> (_objp),
             _recdepth, _name, _prefix);
}
void
dump_read3args (const read3args *objp)
{
  rpc_print (warnx, *objp);
}

const strbuf &
rpc_print (const strbuf &sb, const read3resok &obj, int recdepth,
           const char *name, const char *prefix)
{
  if (name) {
    if (prefix)
      sb << prefix;
    sb << "read3resok " << name << " = ";
  };
  const char *sep;
  str npref;
  if (prefix) {
    npref = strbuf ("%s  ", prefix);
    sep = "";
    sb << "{\n";
  }
  else {
    sep = ", ";
    sb << "{ ";
  }
  rpc_print (sb, obj.file_attributes, recdepth, "file_attributes", npref);
  sb << sep;
  rpc_print (sb, obj.count, recdepth, "count", npref);
  sb << sep;
  rpc_print (sb, obj.eof, recdepth, "eof", npref);
  sb << sep;
  rpc_print (sb, obj.data, recdepth, "data", npref);
  if (prefix)
    sb << prefix << "};\n";
  else
    sb << " }";
  return sb;
}
void
print_read3resok (const void *_objp, const strbuf *_sbp, int _recdepth,
                  const char *_name, const char *_prefix)
{
  rpc_print (_sbp ? *_sbp : warnx, *static_cast<const read3resok *> (_objp),
             _recdepth, _name, _prefix);
}
void
dump_read3resok (const read3resok *objp)
{
  rpc_print (warnx, *objp);
}

const strbuf &
rpc_print (const strbuf &sb, const read3res &obj, int recdepth,
           const char *name, const char *prefix)
{
  if (name) {
    if (prefix)
      sb << prefix;
    sb << "read3res " << name << " = ";
  };
  const char *sep;
  str npref;
  if (prefix) {
    npref = strbuf ("%s  ", prefix);
    sep = "";
    sb << "{\n";
  }
  else {
    sep = ", ";
    sb << "{ ";
  }
  rpc_print (sb, obj.status, recdepth, "status", npref);
  switch (obj.status) {
  case NFS3_OK:
    sb << sep;
    rpc_print (sb, *obj.resok,  recdepth, "resok", npref);
    break;
  default:
    sb << sep;
    rpc_print (sb, *obj.resfail,  recdepth, "resfail", npref);
    break;
  }
  if (prefix)
    sb << prefix << "};\n";
  else
    sb << " }";
  return sb;
}
void
print_read3res (const void *_objp, const strbuf *_sbp, int _recdepth,
                const char *_name, const char *_prefix)
{
  rpc_print (_sbp ? *_sbp : warnx, *static_cast<const read3res *> (_objp),
             _recdepth, _name, _prefix);
}
void
dump_read3res (const read3res *objp)
{
  rpc_print (warnx, *objp);
}

const strbuf &
rpc_print (const strbuf &sb, const stable_how &obj, int recdepth,
           const char *name, const char *prefix)
{
  char *p;
  switch (obj) {
  case UNSTABLE:
    p = "UNSTABLE";
    break;
  case DATA_SYNC:
    p = "DATA_SYNC";
    break;
  case FILE_SYNC:
    p = "FILE_SYNC";
    break;
  default:
    p = NULL;
    break;
  }
  if (name) {
    if (prefix)
      sb << prefix;
    sb << "stable_how " << name << " = ";
  };
  if (p)
    sb << p;
  else
    sb << int (obj);
  if (prefix)
    sb << ";\n";
  return sb;
};
void
print_stable_how (const void *_objp, const strbuf *_sbp, int _recdepth,
                  const char *_name, const char *_prefix)
{
  rpc_print (_sbp ? *_sbp : warnx, *static_cast<const stable_how *> (_objp),
             _recdepth, _name, _prefix);
}
void
dump_stable_how (const stable_how *objp)
{
  rpc_print (warnx, *objp);
}

const strbuf &
rpc_print (const strbuf &sb, const write3args &obj, int recdepth,
           const char *name, const char *prefix)
{
  if (name) {
    if (prefix)
      sb << prefix;
    sb << "write3args " << name << " = ";
  };
  const char *sep;
  str npref;
  if (prefix) {
    npref = strbuf ("%s  ", prefix);
    sep = "";
    sb << "{\n";
  }
  else {
    sep = ", ";
    sb << "{ ";
  }
  rpc_print (sb, obj.file, recdepth, "file", npref);
  sb << sep;
  rpc_print (sb, obj.offset, recdepth, "offset", npref);
  sb << sep;
  rpc_print (sb, obj.count, recdepth, "count", npref);
  sb << sep;
  rpc_print (sb, obj.stable, recdepth, "stable", npref);
  sb << sep;
  rpc_print (sb, obj.data, recdepth, "data", npref);
  if (prefix)
    sb << prefix << "};\n";
  else
    sb << " }";
  return sb;
}
void
print_write3args (const void *_objp, const strbuf *_sbp, int _recdepth,
                  const char *_name, const char *_prefix)
{
  rpc_print (_sbp ? *_sbp : warnx, *static_cast<const write3args *> (_objp),
             _recdepth, _name, _prefix);
}
void
dump_write3args (const write3args *objp)
{
  rpc_print (warnx, *objp);
}

const strbuf &
rpc_print (const strbuf &sb, const write3resok &obj, int recdepth,
           const char *name, const char *prefix)
{
  if (name) {
    if (prefix)
      sb << prefix;
    sb << "write3resok " << name << " = ";
  };
  const char *sep;
  str npref;
  if (prefix) {
    npref = strbuf ("%s  ", prefix);
    sep = "";
    sb << "{\n";
  }
  else {
    sep = ", ";
    sb << "{ ";
  }
  rpc_print (sb, obj.file_wcc, recdepth, "file_wcc", npref);
  sb << sep;
  rpc_print (sb, obj.count, recdepth, "count", npref);
  sb << sep;
  rpc_print (sb, obj.committed, recdepth, "committed", npref);
  sb << sep;
  rpc_print (sb, obj.verf, recdepth, "verf", npref);
  if (prefix)
    sb << prefix << "};\n";
  else
    sb << " }";
  return sb;
}
void
print_write3resok (const void *_objp, const strbuf *_sbp, int _recdepth,
                   const char *_name, const char *_prefix)
{
  rpc_print (_sbp ? *_sbp : warnx, *static_cast<const write3resok *> (_objp),
             _recdepth, _name, _prefix);
}
void
dump_write3resok (const write3resok *objp)
{
  rpc_print (warnx, *objp);
}

const strbuf &
rpc_print (const strbuf &sb, const write3res &obj, int recdepth,
           const char *name, const char *prefix)
{
  if (name) {
    if (prefix)
      sb << prefix;
    sb << "write3res " << name << " = ";
  };
  const char *sep;
  str npref;
  if (prefix) {
    npref = strbuf ("%s  ", prefix);
    sep = "";
    sb << "{\n";
  }
  else {
    sep = ", ";
    sb << "{ ";
  }
  rpc_print (sb, obj.status, recdepth, "status", npref);
  switch (obj.status) {
  case NFS3_OK:
    sb << sep;
    rpc_print (sb, *obj.resok,  recdepth, "resok", npref);
    break;
  default:
    sb << sep;
    rpc_print (sb, *obj.resfail,  recdepth, "resfail", npref);
    break;
  }
  if (prefix)
    sb << prefix << "};\n";
  else
    sb << " }";
  return sb;
}
void
print_write3res (const void *_objp, const strbuf *_sbp, int _recdepth,
                 const char *_name, const char *_prefix)
{
  rpc_print (_sbp ? *_sbp : warnx, *static_cast<const write3res *> (_objp),
             _recdepth, _name, _prefix);
}
void
dump_write3res (const write3res *objp)
{
  rpc_print (warnx, *objp);
}

const strbuf &
rpc_print (const strbuf &sb, const createmode3 &obj, int recdepth,
           const char *name, const char *prefix)
{
  char *p;
  switch (obj) {
  case UNCHECKED:
    p = "UNCHECKED";
    break;
  case GUARDED:
    p = "GUARDED";
    break;
  case EXCLUSIVE:
    p = "EXCLUSIVE";
    break;
  default:
    p = NULL;
    break;
  }
  if (name) {
    if (prefix)
      sb << prefix;
    sb << "createmode3 " << name << " = ";
  };
  if (p)
    sb << p;
  else
    sb << int (obj);
  if (prefix)
    sb << ";\n";
  return sb;
};
void
print_createmode3 (const void *_objp, const strbuf *_sbp, int _recdepth,
                   const char *_name, const char *_prefix)
{
  rpc_print (_sbp ? *_sbp : warnx, *static_cast<const createmode3 *> (_objp),
             _recdepth, _name, _prefix);
}
void
dump_createmode3 (const createmode3 *objp)
{
  rpc_print (warnx, *objp);
}

const strbuf &
rpc_print (const strbuf &sb, const createhow3 &obj, int recdepth,
           const char *name, const char *prefix)
{
  if (name) {
    if (prefix)
      sb << prefix;
    sb << "createhow3 " << name << " = ";
  };
  const char *sep;
  str npref;
  if (prefix) {
    npref = strbuf ("%s  ", prefix);
    sep = "";
    sb << "{\n";
  }
  else {
    sep = ", ";
    sb << "{ ";
  }
  rpc_print (sb, obj.mode, recdepth, "mode", npref);
  switch (obj.mode) {
  case UNCHECKED:
  case GUARDED:
    sb << sep;
    rpc_print (sb, *obj.obj_attributes,  recdepth, "obj_attributes", npref);
    break;
  case EXCLUSIVE:
    sb << sep;
    rpc_print (sb, *obj.verf,  recdepth, "verf", npref);
    break;
  default:
    break;
  }
  if (prefix)
    sb << prefix << "};\n";
  else
    sb << " }";
  return sb;
}
void
print_createhow3 (const void *_objp, const strbuf *_sbp, int _recdepth,
                  const char *_name, const char *_prefix)
{
  rpc_print (_sbp ? *_sbp : warnx, *static_cast<const createhow3 *> (_objp),
             _recdepth, _name, _prefix);
}
void
dump_createhow3 (const createhow3 *objp)
{
  rpc_print (warnx, *objp);
}

const strbuf &
rpc_print (const strbuf &sb, const create3args &obj, int recdepth,
           const char *name, const char *prefix)
{
  if (name) {
    if (prefix)
      sb << prefix;
    sb << "create3args " << name << " = ";
  };
  const char *sep;
  str npref;
  if (prefix) {
    npref = strbuf ("%s  ", prefix);
    sep = "";
    sb << "{\n";
  }
  else {
    sep = ", ";
    sb << "{ ";
  }
  rpc_print (sb, obj.where, recdepth, "where", npref);
  sb << sep;
  rpc_print (sb, obj.how, recdepth, "how", npref);
  if (prefix)
    sb << prefix << "};\n";
  else
    sb << " }";
  return sb;
}
void
print_create3args (const void *_objp, const strbuf *_sbp, int _recdepth,
                   const char *_name, const char *_prefix)
{
  rpc_print (_sbp ? *_sbp : warnx, *static_cast<const create3args *> (_objp),
             _recdepth, _name, _prefix);
}
void
dump_create3args (const create3args *objp)
{
  rpc_print (warnx, *objp);
}

const strbuf &
rpc_print (const strbuf &sb, const mkdir3args &obj, int recdepth,
           const char *name, const char *prefix)
{
  if (name) {
    if (prefix)
      sb << prefix;
    sb << "mkdir3args " << name << " = ";
  };
  const char *sep;
  str npref;
  if (prefix) {
    npref = strbuf ("%s  ", prefix);
    sep = "";
    sb << "{\n";
  }
  else {
    sep = ", ";
    sb << "{ ";
  }
  rpc_print (sb, obj.where, recdepth, "where", npref);
  sb << sep;
  rpc_print (sb, obj.attributes, recdepth, "attributes", npref);
  if (prefix)
    sb << prefix << "};\n";
  else
    sb << " }";
  return sb;
}
void
print_mkdir3args (const void *_objp, const strbuf *_sbp, int _recdepth,
                  const char *_name, const char *_prefix)
{
  rpc_print (_sbp ? *_sbp : warnx, *static_cast<const mkdir3args *> (_objp),
             _recdepth, _name, _prefix);
}
void
dump_mkdir3args (const mkdir3args *objp)
{
  rpc_print (warnx, *objp);
}

const strbuf &
rpc_print (const strbuf &sb, const symlinkdata3 &obj, int recdepth,
           const char *name, const char *prefix)
{
  if (name) {
    if (prefix)
      sb << prefix;
    sb << "symlinkdata3 " << name << " = ";
  };
  const char *sep;
  str npref;
  if (prefix) {
    npref = strbuf ("%s  ", prefix);
    sep = "";
    sb << "{\n";
  }
  else {
    sep = ", ";
    sb << "{ ";
  }
  rpc_print (sb, obj.symlink_attributes, recdepth, "symlink_attributes", npref);
  sb << sep;
  rpc_print (sb, obj.symlink_data, recdepth, "symlink_data", npref);
  if (prefix)
    sb << prefix << "};\n";
  else
    sb << " }";
  return sb;
}
void
print_symlinkdata3 (const void *_objp, const strbuf *_sbp, int _recdepth,
                    const char *_name, const char *_prefix)
{
  rpc_print (_sbp ? *_sbp : warnx, *static_cast<const symlinkdata3 *> (_objp),
             _recdepth, _name, _prefix);
}
void
dump_symlinkdata3 (const symlinkdata3 *objp)
{
  rpc_print (warnx, *objp);
}

const strbuf &
rpc_print (const strbuf &sb, const symlink3args &obj, int recdepth,
           const char *name, const char *prefix)
{
  if (name) {
    if (prefix)
      sb << prefix;
    sb << "symlink3args " << name << " = ";
  };
  const char *sep;
  str npref;
  if (prefix) {
    npref = strbuf ("%s  ", prefix);
    sep = "";
    sb << "{\n";
  }
  else {
    sep = ", ";
    sb << "{ ";
  }
  rpc_print (sb, obj.where, recdepth, "where", npref);
  sb << sep;
  rpc_print (sb, obj.symlink, recdepth, "symlink", npref);
  if (prefix)
    sb << prefix << "};\n";
  else
    sb << " }";
  return sb;
}
void
print_symlink3args (const void *_objp, const strbuf *_sbp, int _recdepth,
                    const char *_name, const char *_prefix)
{
  rpc_print (_sbp ? *_sbp : warnx, *static_cast<const symlink3args *> (_objp),
             _recdepth, _name, _prefix);
}
void
dump_symlink3args (const symlink3args *objp)
{
  rpc_print (warnx, *objp);
}

const strbuf &
rpc_print (const strbuf &sb, const devicedata3 &obj, int recdepth,
           const char *name, const char *prefix)
{
  if (name) {
    if (prefix)
      sb << prefix;
    sb << "devicedata3 " << name << " = ";
  };
  const char *sep;
  str npref;
  if (prefix) {
    npref = strbuf ("%s  ", prefix);
    sep = "";
    sb << "{\n";
  }
  else {
    sep = ", ";
    sb << "{ ";
  }
  rpc_print (sb, obj.dev_attributes, recdepth, "dev_attributes", npref);
  sb << sep;
  rpc_print (sb, obj.spec, recdepth, "spec", npref);
  if (prefix)
    sb << prefix << "};\n";
  else
    sb << " }";
  return sb;
}
void
print_devicedata3 (const void *_objp, const strbuf *_sbp, int _recdepth,
                   const char *_name, const char *_prefix)
{
  rpc_print (_sbp ? *_sbp : warnx, *static_cast<const devicedata3 *> (_objp),
             _recdepth, _name, _prefix);
}
void
dump_devicedata3 (const devicedata3 *objp)
{
  rpc_print (warnx, *objp);
}

const strbuf &
rpc_print (const strbuf &sb, const mknoddata3 &obj, int recdepth,
           const char *name, const char *prefix)
{
  if (name) {
    if (prefix)
      sb << prefix;
    sb << "mknoddata3 " << name << " = ";
  };
  const char *sep;
  str npref;
  if (prefix) {
    npref = strbuf ("%s  ", prefix);
    sep = "";
    sb << "{\n";
  }
  else {
    sep = ", ";
    sb << "{ ";
  }
  rpc_print (sb, obj.type, recdepth, "type", npref);
  switch (obj.type) {
  case NF3CHR:
  case NF3BLK:
    sb << sep;
    rpc_print (sb, *obj.device,  recdepth, "device", npref);
    break;
  case NF3SOCK:
  case NF3FIFO:
    sb << sep;
    rpc_print (sb, *obj.pipe_attributes,  recdepth, "pipe_attributes", npref);
    break;
  default:
    break;
  }
  if (prefix)
    sb << prefix << "};\n";
  else
    sb << " }";
  return sb;
}
void
print_mknoddata3 (const void *_objp, const strbuf *_sbp, int _recdepth,
                  const char *_name, const char *_prefix)
{
  rpc_print (_sbp ? *_sbp : warnx, *static_cast<const mknoddata3 *> (_objp),
             _recdepth, _name, _prefix);
}
void
dump_mknoddata3 (const mknoddata3 *objp)
{
  rpc_print (warnx, *objp);
}

const strbuf &
rpc_print (const strbuf &sb, const mknod3args &obj, int recdepth,
           const char *name, const char *prefix)
{
  if (name) {
    if (prefix)
      sb << prefix;
    sb << "mknod3args " << name << " = ";
  };
  const char *sep;
  str npref;
  if (prefix) {
    npref = strbuf ("%s  ", prefix);
    sep = "";
    sb << "{\n";
  }
  else {
    sep = ", ";
    sb << "{ ";
  }
  rpc_print (sb, obj.where, recdepth, "where", npref);
  sb << sep;
  rpc_print (sb, obj.what, recdepth, "what", npref);
  if (prefix)
    sb << prefix << "};\n";
  else
    sb << " }";
  return sb;
}
void
print_mknod3args (const void *_objp, const strbuf *_sbp, int _recdepth,
                  const char *_name, const char *_prefix)
{
  rpc_print (_sbp ? *_sbp : warnx, *static_cast<const mknod3args *> (_objp),
             _recdepth, _name, _prefix);
}
void
dump_mknod3args (const mknod3args *objp)
{
  rpc_print (warnx, *objp);
}

const strbuf &
rpc_print (const strbuf &sb, const rename3args &obj, int recdepth,
           const char *name, const char *prefix)
{
  if (name) {
    if (prefix)
      sb << prefix;
    sb << "rename3args " << name << " = ";
  };
  const char *sep;
  str npref;
  if (prefix) {
    npref = strbuf ("%s  ", prefix);
    sep = "";
    sb << "{\n";
  }
  else {
    sep = ", ";
    sb << "{ ";
  }
  rpc_print (sb, obj.from, recdepth, "from", npref);
  sb << sep;
  rpc_print (sb, obj.to, recdepth, "to", npref);
  if (prefix)
    sb << prefix << "};\n";
  else
    sb << " }";
  return sb;
}
void
print_rename3args (const void *_objp, const strbuf *_sbp, int _recdepth,
                   const char *_name, const char *_prefix)
{
  rpc_print (_sbp ? *_sbp : warnx, *static_cast<const rename3args *> (_objp),
             _recdepth, _name, _prefix);
}
void
dump_rename3args (const rename3args *objp)
{
  rpc_print (warnx, *objp);
}

const strbuf &
rpc_print (const strbuf &sb, const rename3wcc &obj, int recdepth,
           const char *name, const char *prefix)
{
  if (name) {
    if (prefix)
      sb << prefix;
    sb << "rename3wcc " << name << " = ";
  };
  const char *sep;
  str npref;
  if (prefix) {
    npref = strbuf ("%s  ", prefix);
    sep = "";
    sb << "{\n";
  }
  else {
    sep = ", ";
    sb << "{ ";
  }
  rpc_print (sb, obj.fromdir_wcc, recdepth, "fromdir_wcc", npref);
  sb << sep;
  rpc_print (sb, obj.todir_wcc, recdepth, "todir_wcc", npref);
  if (prefix)
    sb << prefix << "};\n";
  else
    sb << " }";
  return sb;
}
void
print_rename3wcc (const void *_objp, const strbuf *_sbp, int _recdepth,
                  const char *_name, const char *_prefix)
{
  rpc_print (_sbp ? *_sbp : warnx, *static_cast<const rename3wcc *> (_objp),
             _recdepth, _name, _prefix);
}
void
dump_rename3wcc (const rename3wcc *objp)
{
  rpc_print (warnx, *objp);
}

const strbuf &
rpc_print (const strbuf &sb, const rename3res &obj, int recdepth,
           const char *name, const char *prefix)
{
  if (name) {
    if (prefix)
      sb << prefix;
    sb << "rename3res " << name << " = ";
  };
  const char *sep;
  str npref;
  if (prefix) {
    npref = strbuf ("%s  ", prefix);
    sep = "";
    sb << "{\n";
  }
  else {
    sep = ", ";
    sb << "{ ";
  }
  rpc_print (sb, obj.status, recdepth, "status", npref);
  switch (obj.status) {
  case -1:
    break;
  default:
    sb << sep;
    rpc_print (sb, *obj.res,  recdepth, "res", npref);
    break;
  }
  if (prefix)
    sb << prefix << "};\n";
  else
    sb << " }";
  return sb;
}
void
print_rename3res (const void *_objp, const strbuf *_sbp, int _recdepth,
                  const char *_name, const char *_prefix)
{
  rpc_print (_sbp ? *_sbp : warnx, *static_cast<const rename3res *> (_objp),
             _recdepth, _name, _prefix);
}
void
dump_rename3res (const rename3res *objp)
{
  rpc_print (warnx, *objp);
}

const strbuf &
rpc_print (const strbuf &sb, const link3args &obj, int recdepth,
           const char *name, const char *prefix)
{
  if (name) {
    if (prefix)
      sb << prefix;
    sb << "link3args " << name << " = ";
  };
  const char *sep;
  str npref;
  if (prefix) {
    npref = strbuf ("%s  ", prefix);
    sep = "";
    sb << "{\n";
  }
  else {
    sep = ", ";
    sb << "{ ";
  }
  rpc_print (sb, obj.file, recdepth, "file", npref);
  sb << sep;
  rpc_print (sb, obj.link, recdepth, "link", npref);
  if (prefix)
    sb << prefix << "};\n";
  else
    sb << " }";
  return sb;
}
void
print_link3args (const void *_objp, const strbuf *_sbp, int _recdepth,
                 const char *_name, const char *_prefix)
{
  rpc_print (_sbp ? *_sbp : warnx, *static_cast<const link3args *> (_objp),
             _recdepth, _name, _prefix);
}
void
dump_link3args (const link3args *objp)
{
  rpc_print (warnx, *objp);
}

const strbuf &
rpc_print (const strbuf &sb, const link3wcc &obj, int recdepth,
           const char *name, const char *prefix)
{
  if (name) {
    if (prefix)
      sb << prefix;
    sb << "link3wcc " << name << " = ";
  };
  const char *sep;
  str npref;
  if (prefix) {
    npref = strbuf ("%s  ", prefix);
    sep = "";
    sb << "{\n";
  }
  else {
    sep = ", ";
    sb << "{ ";
  }
  rpc_print (sb, obj.file_attributes, recdepth, "file_attributes", npref);
  sb << sep;
  rpc_print (sb, obj.linkdir_wcc, recdepth, "linkdir_wcc", npref);
  if (prefix)
    sb << prefix << "};\n";
  else
    sb << " }";
  return sb;
}
void
print_link3wcc (const void *_objp, const strbuf *_sbp, int _recdepth,
                const char *_name, const char *_prefix)
{
  rpc_print (_sbp ? *_sbp : warnx, *static_cast<const link3wcc *> (_objp),
             _recdepth, _name, _prefix);
}
void
dump_link3wcc (const link3wcc *objp)
{
  rpc_print (warnx, *objp);
}

const strbuf &
rpc_print (const strbuf &sb, const link3res &obj, int recdepth,
           const char *name, const char *prefix)
{
  if (name) {
    if (prefix)
      sb << prefix;
    sb << "link3res " << name << " = ";
  };
  const char *sep;
  str npref;
  if (prefix) {
    npref = strbuf ("%s  ", prefix);
    sep = "";
    sb << "{\n";
  }
  else {
    sep = ", ";
    sb << "{ ";
  }
  rpc_print (sb, obj.status, recdepth, "status", npref);
  switch (obj.status) {
  case -1:
    break;
  default:
    sb << sep;
    rpc_print (sb, *obj.res,  recdepth, "res", npref);
    break;
  }
  if (prefix)
    sb << prefix << "};\n";
  else
    sb << " }";
  return sb;
}
void
print_link3res (const void *_objp, const strbuf *_sbp, int _recdepth,
                const char *_name, const char *_prefix)
{
  rpc_print (_sbp ? *_sbp : warnx, *static_cast<const link3res *> (_objp),
             _recdepth, _name, _prefix);
}
void
dump_link3res (const link3res *objp)
{
  rpc_print (warnx, *objp);
}

const strbuf &
rpc_print (const strbuf &sb, const readdir3args &obj, int recdepth,
           const char *name, const char *prefix)
{
  if (name) {
    if (prefix)
      sb << prefix;
    sb << "readdir3args " << name << " = ";
  };
  const char *sep;
  str npref;
  if (prefix) {
    npref = strbuf ("%s  ", prefix);
    sep = "";
    sb << "{\n";
  }
  else {
    sep = ", ";
    sb << "{ ";
  }
  rpc_print (sb, obj.dir, recdepth, "dir", npref);
  sb << sep;
  rpc_print (sb, obj.cookie, recdepth, "cookie", npref);
  sb << sep;
  rpc_print (sb, obj.cookieverf, recdepth, "cookieverf", npref);
  sb << sep;
  rpc_print (sb, obj.count, recdepth, "count", npref);
  if (prefix)
    sb << prefix << "};\n";
  else
    sb << " }";
  return sb;
}
void
print_readdir3args (const void *_objp, const strbuf *_sbp, int _recdepth,
                    const char *_name, const char *_prefix)
{
  rpc_print (_sbp ? *_sbp : warnx, *static_cast<const readdir3args *> (_objp),
             _recdepth, _name, _prefix);
}
void
dump_readdir3args (const readdir3args *objp)
{
  rpc_print (warnx, *objp);
}

const strbuf &
rpc_print (const strbuf &sb, const entry3 &obj, int recdepth,
           const char *name, const char *prefix)
{
  if (name) {
    if (prefix)
      sb << prefix;
    sb << "entry3 " << name << " = ";
  };
  const char *sep;
  str npref;
  if (prefix) {
    npref = strbuf ("%s  ", prefix);
    sep = "";
    sb << "{\n";
  }
  else {
    sep = ", ";
    sb << "{ ";
  }
  rpc_print (sb, obj.fileid, recdepth, "fileid", npref);
  sb << sep;
  rpc_print (sb, obj.name, recdepth, "name", npref);
  sb << sep;
  rpc_print (sb, obj.cookie, recdepth, "cookie", npref);
  sb << sep;
  rpc_print (sb, obj.nextentry, recdepth, "nextentry", npref);
  if (prefix)
    sb << prefix << "};\n";
  else
    sb << " }";
  return sb;
}
void
print_entry3 (const void *_objp, const strbuf *_sbp, int _recdepth,
              const char *_name, const char *_prefix)
{
  rpc_print (_sbp ? *_sbp : warnx, *static_cast<const entry3 *> (_objp),
             _recdepth, _name, _prefix);
}
void
dump_entry3 (const entry3 *objp)
{
  rpc_print (warnx, *objp);
}

const strbuf &
rpc_print (const strbuf &sb, const dirlist3 &obj, int recdepth,
           const char *name, const char *prefix)
{
  if (name) {
    if (prefix)
      sb << prefix;
    sb << "dirlist3 " << name << " = ";
  };
  const char *sep;
  str npref;
  if (prefix) {
    npref = strbuf ("%s  ", prefix);
    sep = "";
    sb << "{\n";
  }
  else {
    sep = ", ";
    sb << "{ ";
  }
  rpc_print (sb, obj.entries, recdepth, "entries", npref);
  sb << sep;
  rpc_print (sb, obj.eof, recdepth, "eof", npref);
  if (prefix)
    sb << prefix << "};\n";
  else
    sb << " }";
  return sb;
}
void
print_dirlist3 (const void *_objp, const strbuf *_sbp, int _recdepth,
                const char *_name, const char *_prefix)
{
  rpc_print (_sbp ? *_sbp : warnx, *static_cast<const dirlist3 *> (_objp),
             _recdepth, _name, _prefix);
}
void
dump_dirlist3 (const dirlist3 *objp)
{
  rpc_print (warnx, *objp);
}

const strbuf &
rpc_print (const strbuf &sb, const readdir3resok &obj, int recdepth,
           const char *name, const char *prefix)
{
  if (name) {
    if (prefix)
      sb << prefix;
    sb << "readdir3resok " << name << " = ";
  };
  const char *sep;
  str npref;
  if (prefix) {
    npref = strbuf ("%s  ", prefix);
    sep = "";
    sb << "{\n";
  }
  else {
    sep = ", ";
    sb << "{ ";
  }
  rpc_print (sb, obj.dir_attributes, recdepth, "dir_attributes", npref);
  sb << sep;
  rpc_print (sb, obj.cookieverf, recdepth, "cookieverf", npref);
  sb << sep;
  rpc_print (sb, obj.reply, recdepth, "reply", npref);
  if (prefix)
    sb << prefix << "};\n";
  else
    sb << " }";
  return sb;
}
void
print_readdir3resok (const void *_objp, const strbuf *_sbp, int _recdepth,
                     const char *_name, const char *_prefix)
{
  rpc_print (_sbp ? *_sbp : warnx, *static_cast<const readdir3resok *> (_objp),
             _recdepth, _name, _prefix);
}
void
dump_readdir3resok (const readdir3resok *objp)
{
  rpc_print (warnx, *objp);
}

const strbuf &
rpc_print (const strbuf &sb, const readdir3res &obj, int recdepth,
           const char *name, const char *prefix)
{
  if (name) {
    if (prefix)
      sb << prefix;
    sb << "readdir3res " << name << " = ";
  };
  const char *sep;
  str npref;
  if (prefix) {
    npref = strbuf ("%s  ", prefix);
    sep = "";
    sb << "{\n";
  }
  else {
    sep = ", ";
    sb << "{ ";
  }
  rpc_print (sb, obj.status, recdepth, "status", npref);
  switch (obj.status) {
  case NFS3_OK:
    sb << sep;
    rpc_print (sb, *obj.resok,  recdepth, "resok", npref);
    break;
  default:
    sb << sep;
    rpc_print (sb, *obj.resfail,  recdepth, "resfail", npref);
    break;
  }
  if (prefix)
    sb << prefix << "};\n";
  else
    sb << " }";
  return sb;
}
void
print_readdir3res (const void *_objp, const strbuf *_sbp, int _recdepth,
                   const char *_name, const char *_prefix)
{
  rpc_print (_sbp ? *_sbp : warnx, *static_cast<const readdir3res *> (_objp),
             _recdepth, _name, _prefix);
}
void
dump_readdir3res (const readdir3res *objp)
{
  rpc_print (warnx, *objp);
}

const strbuf &
rpc_print (const strbuf &sb, const readdirplus3args &obj, int recdepth,
           const char *name, const char *prefix)
{
  if (name) {
    if (prefix)
      sb << prefix;
    sb << "readdirplus3args " << name << " = ";
  };
  const char *sep;
  str npref;
  if (prefix) {
    npref = strbuf ("%s  ", prefix);
    sep = "";
    sb << "{\n";
  }
  else {
    sep = ", ";
    sb << "{ ";
  }
  rpc_print (sb, obj.dir, recdepth, "dir", npref);
  sb << sep;
  rpc_print (sb, obj.cookie, recdepth, "cookie", npref);
  sb << sep;
  rpc_print (sb, obj.cookieverf, recdepth, "cookieverf", npref);
  sb << sep;
  rpc_print (sb, obj.dircount, recdepth, "dircount", npref);
  sb << sep;
  rpc_print (sb, obj.maxcount, recdepth, "maxcount", npref);
  if (prefix)
    sb << prefix << "};\n";
  else
    sb << " }";
  return sb;
}
void
print_readdirplus3args (const void *_objp, const strbuf *_sbp, int _recdepth,
                        const char *_name, const char *_prefix)
{
  rpc_print (_sbp ? *_sbp : warnx, *static_cast<const readdirplus3args *> (_objp),
             _recdepth, _name, _prefix);
}
void
dump_readdirplus3args (const readdirplus3args *objp)
{
  rpc_print (warnx, *objp);
}

const strbuf &
rpc_print (const strbuf &sb, const entryplus3 &obj, int recdepth,
           const char *name, const char *prefix)
{
  if (name) {
    if (prefix)
      sb << prefix;
    sb << "entryplus3 " << name << " = ";
  };
  const char *sep;
  str npref;
  if (prefix) {
    npref = strbuf ("%s  ", prefix);
    sep = "";
    sb << "{\n";
  }
  else {
    sep = ", ";
    sb << "{ ";
  }
  rpc_print (sb, obj.fileid, recdepth, "fileid", npref);
  sb << sep;
  rpc_print (sb, obj.name, recdepth, "name", npref);
  sb << sep;
  rpc_print (sb, obj.cookie, recdepth, "cookie", npref);
  sb << sep;
  rpc_print (sb, obj.name_attributes, recdepth, "name_attributes", npref);
  sb << sep;
  rpc_print (sb, obj.name_handle, recdepth, "name_handle", npref);
  sb << sep;
  rpc_print (sb, obj.nextentry, recdepth, "nextentry", npref);
  if (prefix)
    sb << prefix << "};\n";
  else
    sb << " }";
  return sb;
}
void
print_entryplus3 (const void *_objp, const strbuf *_sbp, int _recdepth,
                  const char *_name, const char *_prefix)
{
  rpc_print (_sbp ? *_sbp : warnx, *static_cast<const entryplus3 *> (_objp),
             _recdepth, _name, _prefix);
}
void
dump_entryplus3 (const entryplus3 *objp)
{
  rpc_print (warnx, *objp);
}

const strbuf &
rpc_print (const strbuf &sb, const dirlistplus3 &obj, int recdepth,
           const char *name, const char *prefix)
{
  if (name) {
    if (prefix)
      sb << prefix;
    sb << "dirlistplus3 " << name << " = ";
  };
  const char *sep;
  str npref;
  if (prefix) {
    npref = strbuf ("%s  ", prefix);
    sep = "";
    sb << "{\n";
  }
  else {
    sep = ", ";
    sb << "{ ";
  }
  rpc_print (sb, obj.entries, recdepth, "entries", npref);
  sb << sep;
  rpc_print (sb, obj.eof, recdepth, "eof", npref);
  if (prefix)
    sb << prefix << "};\n";
  else
    sb << " }";
  return sb;
}
void
print_dirlistplus3 (const void *_objp, const strbuf *_sbp, int _recdepth,
                    const char *_name, const char *_prefix)
{
  rpc_print (_sbp ? *_sbp : warnx, *static_cast<const dirlistplus3 *> (_objp),
             _recdepth, _name, _prefix);
}
void
dump_dirlistplus3 (const dirlistplus3 *objp)
{
  rpc_print (warnx, *objp);
}

const strbuf &
rpc_print (const strbuf &sb, const readdirplus3resok &obj, int recdepth,
           const char *name, const char *prefix)
{
  if (name) {
    if (prefix)
      sb << prefix;
    sb << "readdirplus3resok " << name << " = ";
  };
  const char *sep;
  str npref;
  if (prefix) {
    npref = strbuf ("%s  ", prefix);
    sep = "";
    sb << "{\n";
  }
  else {
    sep = ", ";
    sb << "{ ";
  }
  rpc_print (sb, obj.dir_attributes, recdepth, "dir_attributes", npref);
  sb << sep;
  rpc_print (sb, obj.cookieverf, recdepth, "cookieverf", npref);
  sb << sep;
  rpc_print (sb, obj.reply, recdepth, "reply", npref);
  if (prefix)
    sb << prefix << "};\n";
  else
    sb << " }";
  return sb;
}
void
print_readdirplus3resok (const void *_objp, const strbuf *_sbp, int _recdepth,
                         const char *_name, const char *_prefix)
{
  rpc_print (_sbp ? *_sbp : warnx, *static_cast<const readdirplus3resok *> (_objp),
             _recdepth, _name, _prefix);
}
void
dump_readdirplus3resok (const readdirplus3resok *objp)
{
  rpc_print (warnx, *objp);
}

const strbuf &
rpc_print (const strbuf &sb, const readdirplus3res &obj, int recdepth,
           const char *name, const char *prefix)
{
  if (name) {
    if (prefix)
      sb << prefix;
    sb << "readdirplus3res " << name << " = ";
  };
  const char *sep;
  str npref;
  if (prefix) {
    npref = strbuf ("%s  ", prefix);
    sep = "";
    sb << "{\n";
  }
  else {
    sep = ", ";
    sb << "{ ";
  }
  rpc_print (sb, obj.status, recdepth, "status", npref);
  switch (obj.status) {
  case NFS3_OK:
    sb << sep;
    rpc_print (sb, *obj.resok,  recdepth, "resok", npref);
    break;
  default:
    sb << sep;
    rpc_print (sb, *obj.resfail,  recdepth, "resfail", npref);
    break;
  }
  if (prefix)
    sb << prefix << "};\n";
  else
    sb << " }";
  return sb;
}
void
print_readdirplus3res (const void *_objp, const strbuf *_sbp, int _recdepth,
                       const char *_name, const char *_prefix)
{
  rpc_print (_sbp ? *_sbp : warnx, *static_cast<const readdirplus3res *> (_objp),
             _recdepth, _name, _prefix);
}
void
dump_readdirplus3res (const readdirplus3res *objp)
{
  rpc_print (warnx, *objp);
}

const strbuf &
rpc_print (const strbuf &sb, const fsstat3resok &obj, int recdepth,
           const char *name, const char *prefix)
{
  if (name) {
    if (prefix)
      sb << prefix;
    sb << "fsstat3resok " << name << " = ";
  };
  const char *sep;
  str npref;
  if (prefix) {
    npref = strbuf ("%s  ", prefix);
    sep = "";
    sb << "{\n";
  }
  else {
    sep = ", ";
    sb << "{ ";
  }
  rpc_print (sb, obj.obj_attributes, recdepth, "obj_attributes", npref);
  sb << sep;
  rpc_print (sb, obj.tbytes, recdepth, "tbytes", npref);
  sb << sep;
  rpc_print (sb, obj.fbytes, recdepth, "fbytes", npref);
  sb << sep;
  rpc_print (sb, obj.abytes, recdepth, "abytes", npref);
  sb << sep;
  rpc_print (sb, obj.tfiles, recdepth, "tfiles", npref);
  sb << sep;
  rpc_print (sb, obj.ffiles, recdepth, "ffiles", npref);
  sb << sep;
  rpc_print (sb, obj.afiles, recdepth, "afiles", npref);
  sb << sep;
  rpc_print (sb, obj.invarsec, recdepth, "invarsec", npref);
  if (prefix)
    sb << prefix << "};\n";
  else
    sb << " }";
  return sb;
}
void
print_fsstat3resok (const void *_objp, const strbuf *_sbp, int _recdepth,
                    const char *_name, const char *_prefix)
{
  rpc_print (_sbp ? *_sbp : warnx, *static_cast<const fsstat3resok *> (_objp),
             _recdepth, _name, _prefix);
}
void
dump_fsstat3resok (const fsstat3resok *objp)
{
  rpc_print (warnx, *objp);
}

const strbuf &
rpc_print (const strbuf &sb, const fsstat3res &obj, int recdepth,
           const char *name, const char *prefix)
{
  if (name) {
    if (prefix)
      sb << prefix;
    sb << "fsstat3res " << name << " = ";
  };
  const char *sep;
  str npref;
  if (prefix) {
    npref = strbuf ("%s  ", prefix);
    sep = "";
    sb << "{\n";
  }
  else {
    sep = ", ";
    sb << "{ ";
  }
  rpc_print (sb, obj.status, recdepth, "status", npref);
  switch (obj.status) {
  case NFS3_OK:
    sb << sep;
    rpc_print (sb, *obj.resok,  recdepth, "resok", npref);
    break;
  default:
    sb << sep;
    rpc_print (sb, *obj.resfail,  recdepth, "resfail", npref);
    break;
  }
  if (prefix)
    sb << prefix << "};\n";
  else
    sb << " }";
  return sb;
}
void
print_fsstat3res (const void *_objp, const strbuf *_sbp, int _recdepth,
                  const char *_name, const char *_prefix)
{
  rpc_print (_sbp ? *_sbp : warnx, *static_cast<const fsstat3res *> (_objp),
             _recdepth, _name, _prefix);
}
void
dump_fsstat3res (const fsstat3res *objp)
{
  rpc_print (warnx, *objp);
}

const strbuf &
rpc_print (const strbuf &sb, const fsinfo3resok &obj, int recdepth,
           const char *name, const char *prefix)
{
  if (name) {
    if (prefix)
      sb << prefix;
    sb << "fsinfo3resok " << name << " = ";
  };
  const char *sep;
  str npref;
  if (prefix) {
    npref = strbuf ("%s  ", prefix);
    sep = "";
    sb << "{\n";
  }
  else {
    sep = ", ";
    sb << "{ ";
  }
  rpc_print (sb, obj.obj_attributes, recdepth, "obj_attributes", npref);
  sb << sep;
  rpc_print (sb, obj.rtmax, recdepth, "rtmax", npref);
  sb << sep;
  rpc_print (sb, obj.rtpref, recdepth, "rtpref", npref);
  sb << sep;
  rpc_print (sb, obj.rtmult, recdepth, "rtmult", npref);
  sb << sep;
  rpc_print (sb, obj.wtmax, recdepth, "wtmax", npref);
  sb << sep;
  rpc_print (sb, obj.wtpref, recdepth, "wtpref", npref);
  sb << sep;
  rpc_print (sb, obj.wtmult, recdepth, "wtmult", npref);
  sb << sep;
  rpc_print (sb, obj.dtpref, recdepth, "dtpref", npref);
  sb << sep;
  rpc_print (sb, obj.maxfilesize, recdepth, "maxfilesize", npref);
  sb << sep;
  rpc_print (sb, obj.time_delta, recdepth, "time_delta", npref);
  sb << sep;
  rpc_print (sb, obj.properties, recdepth, "properties", npref);
  if (prefix)
    sb << prefix << "};\n";
  else
    sb << " }";
  return sb;
}
void
print_fsinfo3resok (const void *_objp, const strbuf *_sbp, int _recdepth,
                    const char *_name, const char *_prefix)
{
  rpc_print (_sbp ? *_sbp : warnx, *static_cast<const fsinfo3resok *> (_objp),
             _recdepth, _name, _prefix);
}
void
dump_fsinfo3resok (const fsinfo3resok *objp)
{
  rpc_print (warnx, *objp);
}

const strbuf &
rpc_print (const strbuf &sb, const fsinfo3res &obj, int recdepth,
           const char *name, const char *prefix)
{
  if (name) {
    if (prefix)
      sb << prefix;
    sb << "fsinfo3res " << name << " = ";
  };
  const char *sep;
  str npref;
  if (prefix) {
    npref = strbuf ("%s  ", prefix);
    sep = "";
    sb << "{\n";
  }
  else {
    sep = ", ";
    sb << "{ ";
  }
  rpc_print (sb, obj.status, recdepth, "status", npref);
  switch (obj.status) {
  case NFS3_OK:
    sb << sep;
    rpc_print (sb, *obj.resok,  recdepth, "resok", npref);
    break;
  default:
    sb << sep;
    rpc_print (sb, *obj.resfail,  recdepth, "resfail", npref);
    break;
  }
  if (prefix)
    sb << prefix << "};\n";
  else
    sb << " }";
  return sb;
}
void
print_fsinfo3res (const void *_objp, const strbuf *_sbp, int _recdepth,
                  const char *_name, const char *_prefix)
{
  rpc_print (_sbp ? *_sbp : warnx, *static_cast<const fsinfo3res *> (_objp),
             _recdepth, _name, _prefix);
}
void
dump_fsinfo3res (const fsinfo3res *objp)
{
  rpc_print (warnx, *objp);
}

const strbuf &
rpc_print (const strbuf &sb, const pathconf3resok &obj, int recdepth,
           const char *name, const char *prefix)
{
  if (name) {
    if (prefix)
      sb << prefix;
    sb << "pathconf3resok " << name << " = ";
  };
  const char *sep;
  str npref;
  if (prefix) {
    npref = strbuf ("%s  ", prefix);
    sep = "";
    sb << "{\n";
  }
  else {
    sep = ", ";
    sb << "{ ";
  }
  rpc_print (sb, obj.obj_attributes, recdepth, "obj_attributes", npref);
  sb << sep;
  rpc_print (sb, obj.linkmax, recdepth, "linkmax", npref);
  sb << sep;
  rpc_print (sb, obj.name_max, recdepth, "name_max", npref);
  sb << sep;
  rpc_print (sb, obj.no_trunc, recdepth, "no_trunc", npref);
  sb << sep;
  rpc_print (sb, obj.chown_restricted, recdepth, "chown_restricted", npref);
  sb << sep;
  rpc_print (sb, obj.case_insensitive, recdepth, "case_insensitive", npref);
  sb << sep;
  rpc_print (sb, obj.case_preserving, recdepth, "case_preserving", npref);
  if (prefix)
    sb << prefix << "};\n";
  else
    sb << " }";
  return sb;
}
void
print_pathconf3resok (const void *_objp, const strbuf *_sbp, int _recdepth,
                      const char *_name, const char *_prefix)
{
  rpc_print (_sbp ? *_sbp : warnx, *static_cast<const pathconf3resok *> (_objp),
             _recdepth, _name, _prefix);
}
void
dump_pathconf3resok (const pathconf3resok *objp)
{
  rpc_print (warnx, *objp);
}

const strbuf &
rpc_print (const strbuf &sb, const pathconf3res &obj, int recdepth,
           const char *name, const char *prefix)
{
  if (name) {
    if (prefix)
      sb << prefix;
    sb << "pathconf3res " << name << " = ";
  };
  const char *sep;
  str npref;
  if (prefix) {
    npref = strbuf ("%s  ", prefix);
    sep = "";
    sb << "{\n";
  }
  else {
    sep = ", ";
    sb << "{ ";
  }
  rpc_print (sb, obj.status, recdepth, "status", npref);
  switch (obj.status) {
  case NFS3_OK:
    sb << sep;
    rpc_print (sb, *obj.resok,  recdepth, "resok", npref);
    break;
  default:
    sb << sep;
    rpc_print (sb, *obj.resfail,  recdepth, "resfail", npref);
    break;
  }
  if (prefix)
    sb << prefix << "};\n";
  else
    sb << " }";
  return sb;
}
void
print_pathconf3res (const void *_objp, const strbuf *_sbp, int _recdepth,
                    const char *_name, const char *_prefix)
{
  rpc_print (_sbp ? *_sbp : warnx, *static_cast<const pathconf3res *> (_objp),
             _recdepth, _name, _prefix);
}
void
dump_pathconf3res (const pathconf3res *objp)
{
  rpc_print (warnx, *objp);
}

const strbuf &
rpc_print (const strbuf &sb, const commit3args &obj, int recdepth,
           const char *name, const char *prefix)
{
  if (name) {
    if (prefix)
      sb << prefix;
    sb << "commit3args " << name << " = ";
  };
  const char *sep;
  str npref;
  if (prefix) {
    npref = strbuf ("%s  ", prefix);
    sep = "";
    sb << "{\n";
  }
  else {
    sep = ", ";
    sb << "{ ";
  }
  rpc_print (sb, obj.file, recdepth, "file", npref);
  sb << sep;
  rpc_print (sb, obj.offset, recdepth, "offset", npref);
  sb << sep;
  rpc_print (sb, obj.count, recdepth, "count", npref);
  if (prefix)
    sb << prefix << "};\n";
  else
    sb << " }";
  return sb;
}
void
print_commit3args (const void *_objp, const strbuf *_sbp, int _recdepth,
                   const char *_name, const char *_prefix)
{
  rpc_print (_sbp ? *_sbp : warnx, *static_cast<const commit3args *> (_objp),
             _recdepth, _name, _prefix);
}
void
dump_commit3args (const commit3args *objp)
{
  rpc_print (warnx, *objp);
}

const strbuf &
rpc_print (const strbuf &sb, const commit3resok &obj, int recdepth,
           const char *name, const char *prefix)
{
  if (name) {
    if (prefix)
      sb << prefix;
    sb << "commit3resok " << name << " = ";
  };
  const char *sep;
  str npref;
  if (prefix) {
    npref = strbuf ("%s  ", prefix);
    sep = "";
    sb << "{\n";
  }
  else {
    sep = ", ";
    sb << "{ ";
  }
  rpc_print (sb, obj.file_wcc, recdepth, "file_wcc", npref);
  sb << sep;
  rpc_print (sb, obj.verf, recdepth, "verf", npref);
  if (prefix)
    sb << prefix << "};\n";
  else
    sb << " }";
  return sb;
}
void
print_commit3resok (const void *_objp, const strbuf *_sbp, int _recdepth,
                    const char *_name, const char *_prefix)
{
  rpc_print (_sbp ? *_sbp : warnx, *static_cast<const commit3resok *> (_objp),
             _recdepth, _name, _prefix);
}
void
dump_commit3resok (const commit3resok *objp)
{
  rpc_print (warnx, *objp);
}

const strbuf &
rpc_print (const strbuf &sb, const commit3res &obj, int recdepth,
           const char *name, const char *prefix)
{
  if (name) {
    if (prefix)
      sb << prefix;
    sb << "commit3res " << name << " = ";
  };
  const char *sep;
  str npref;
  if (prefix) {
    npref = strbuf ("%s  ", prefix);
    sep = "";
    sb << "{\n";
  }
  else {
    sep = ", ";
    sb << "{ ";
  }
  rpc_print (sb, obj.status, recdepth, "status", npref);
  switch (obj.status) {
  case NFS3_OK:
    sb << sep;
    rpc_print (sb, *obj.resok,  recdepth, "resok", npref);
    break;
  default:
    sb << sep;
    rpc_print (sb, *obj.resfail,  recdepth, "resfail", npref);
    break;
  }
  if (prefix)
    sb << prefix << "};\n";
  else
    sb << " }";
  return sb;
}
void
print_commit3res (const void *_objp, const strbuf *_sbp, int _recdepth,
                  const char *_name, const char *_prefix)
{
  rpc_print (_sbp ? *_sbp : warnx, *static_cast<const commit3res *> (_objp),
             _recdepth, _name, _prefix);
}
void
dump_commit3res (const commit3res *objp)
{
  rpc_print (warnx, *objp);
}

#endif /* MAINTAINER*/
void *
uint64_alloc ()
{
  return New uint64;
}
bool_t
xdr_uint64 (XDR *xdrs, void *objp)
{
  switch (xdrs->x_op) {
  case XDR_ENCODE:
  case XDR_DECODE:
    return rpc_traverse (xdrs, *static_cast<uint64 *> (objp));
  case XDR_FREE:
    rpc_destruct (static_cast<uint64 *> (objp));
    return true;
  default:
    panic ("invalid xdr operation %d\n", xdrs->x_op);
  }
}

void *
int64_alloc ()
{
  return New int64;
}
bool_t
xdr_int64 (XDR *xdrs, void *objp)
{
  switch (xdrs->x_op) {
  case XDR_ENCODE:
  case XDR_DECODE:
    return rpc_traverse (xdrs, *static_cast<int64 *> (objp));
  case XDR_FREE:
    rpc_destruct (static_cast<int64 *> (objp));
    return true;
  default:
    panic ("invalid xdr operation %d\n", xdrs->x_op);
  }
}

void *
uint32_alloc ()
{
  return New uint32;
}
bool_t
xdr_uint32 (XDR *xdrs, void *objp)
{
  switch (xdrs->x_op) {
  case XDR_ENCODE:
  case XDR_DECODE:
    return rpc_traverse (xdrs, *static_cast<uint32 *> (objp));
  case XDR_FREE:
    rpc_destruct (static_cast<uint32 *> (objp));
    return true;
  default:
    panic ("invalid xdr operation %d\n", xdrs->x_op);
  }
}

void *
int32_alloc ()
{
  return New int32;
}
bool_t
xdr_int32 (XDR *xdrs, void *objp)
{
  switch (xdrs->x_op) {
  case XDR_ENCODE:
  case XDR_DECODE:
    return rpc_traverse (xdrs, *static_cast<int32 *> (objp));
  case XDR_FREE:
    rpc_destruct (static_cast<int32 *> (objp));
    return true;
  default:
    panic ("invalid xdr operation %d\n", xdrs->x_op);
  }
}

void *
filename3_alloc ()
{
  return New filename3;
}
bool_t
xdr_filename3 (XDR *xdrs, void *objp)
{
  switch (xdrs->x_op) {
  case XDR_ENCODE:
  case XDR_DECODE:
    return rpc_traverse (xdrs, *static_cast<filename3 *> (objp));
  case XDR_FREE:
    rpc_destruct (static_cast<filename3 *> (objp));
    return true;
  default:
    panic ("invalid xdr operation %d\n", xdrs->x_op);
  }
}

void *
nfspath3_alloc ()
{
  return New nfspath3;
}
bool_t
xdr_nfspath3 (XDR *xdrs, void *objp)
{
  switch (xdrs->x_op) {
  case XDR_ENCODE:
  case XDR_DECODE:
    return rpc_traverse (xdrs, *static_cast<nfspath3 *> (objp));
  case XDR_FREE:
    rpc_destruct (static_cast<nfspath3 *> (objp));
    return true;
  default:
    panic ("invalid xdr operation %d\n", xdrs->x_op);
  }
}

void *
cookieverf3_alloc ()
{
  return New cookieverf3;
}
bool_t
xdr_cookieverf3 (XDR *xdrs, void *objp)
{
  switch (xdrs->x_op) {
  case XDR_ENCODE:
  case XDR_DECODE:
    return rpc_traverse (xdrs, *static_cast<cookieverf3 *> (objp));
  case XDR_FREE:
    rpc_destruct (static_cast<cookieverf3 *> (objp));
    return true;
  default:
    panic ("invalid xdr operation %d\n", xdrs->x_op);
  }
}

void *
createverf3_alloc ()
{
  return New createverf3;
}
bool_t
xdr_createverf3 (XDR *xdrs, void *objp)
{
  switch (xdrs->x_op) {
  case XDR_ENCODE:
  case XDR_DECODE:
    return rpc_traverse (xdrs, *static_cast<createverf3 *> (objp));
  case XDR_FREE:
    rpc_destruct (static_cast<createverf3 *> (objp));
    return true;
  default:
    panic ("invalid xdr operation %d\n", xdrs->x_op);
  }
}

void *
writeverf3_alloc ()
{
  return New writeverf3;
}
bool_t
xdr_writeverf3 (XDR *xdrs, void *objp)
{
  switch (xdrs->x_op) {
  case XDR_ENCODE:
  case XDR_DECODE:
    return rpc_traverse (xdrs, *static_cast<writeverf3 *> (objp));
  case XDR_FREE:
    rpc_destruct (static_cast<writeverf3 *> (objp));
    return true;
  default:
    panic ("invalid xdr operation %d\n", xdrs->x_op);
  }
}

void *
nfsstat3_alloc ()
{
  return New nfsstat3;
}
bool_t
xdr_nfsstat3 (XDR *xdrs, void *objp)
{
  switch (xdrs->x_op) {
  case XDR_ENCODE:
  case XDR_DECODE:
    return rpc_traverse (xdrs, *static_cast<nfsstat3 *> (objp));
  case XDR_FREE:
    rpc_destruct (static_cast<nfsstat3 *> (objp));
    return true;
  default:
    panic ("invalid xdr operation %d\n", xdrs->x_op);
  }
}

void *
ftype3_alloc ()
{
  return New ftype3;
}
bool_t
xdr_ftype3 (XDR *xdrs, void *objp)
{
  switch (xdrs->x_op) {
  case XDR_ENCODE:
  case XDR_DECODE:
    return rpc_traverse (xdrs, *static_cast<ftype3 *> (objp));
  case XDR_FREE:
    rpc_destruct (static_cast<ftype3 *> (objp));
    return true;
  default:
    panic ("invalid xdr operation %d\n", xdrs->x_op);
  }
}

void *
specdata3_alloc ()
{
  return New specdata3;
}
bool_t
xdr_specdata3 (XDR *xdrs, void *objp)
{
  switch (xdrs->x_op) {
  case XDR_ENCODE:
  case XDR_DECODE:
    return rpc_traverse (xdrs, *static_cast<specdata3 *> (objp));
  case XDR_FREE:
    rpc_destruct (static_cast<specdata3 *> (objp));
    return true;
  default:
    panic ("invalid xdr operation %d\n", xdrs->x_op);
  }
}

void *
nfs_fh3_alloc ()
{
  return New nfs_fh3;
}
bool_t
xdr_nfs_fh3 (XDR *xdrs, void *objp)
{
  switch (xdrs->x_op) {
  case XDR_ENCODE:
  case XDR_DECODE:
    return rpc_traverse (xdrs, *static_cast<nfs_fh3 *> (objp));
  case XDR_FREE:
    rpc_destruct (static_cast<nfs_fh3 *> (objp));
    return true;
  default:
    panic ("invalid xdr operation %d\n", xdrs->x_op);
  }
}

void *
nfstime3_alloc ()
{
  return New nfstime3;
}
bool_t
xdr_nfstime3 (XDR *xdrs, void *objp)
{
  switch (xdrs->x_op) {
  case XDR_ENCODE:
  case XDR_DECODE:
    return rpc_traverse (xdrs, *static_cast<nfstime3 *> (objp));
  case XDR_FREE:
    rpc_destruct (static_cast<nfstime3 *> (objp));
    return true;
  default:
    panic ("invalid xdr operation %d\n", xdrs->x_op);
  }
}

void *
fattr3_alloc ()
{
  return New fattr3;
}
bool_t
xdr_fattr3 (XDR *xdrs, void *objp)
{
  switch (xdrs->x_op) {
  case XDR_ENCODE:
  case XDR_DECODE:
    return rpc_traverse (xdrs, *static_cast<fattr3 *> (objp));
  case XDR_FREE:
    rpc_destruct (static_cast<fattr3 *> (objp));
    return true;
  default:
    panic ("invalid xdr operation %d\n", xdrs->x_op);
  }
}

void *
post_op_attr_alloc ()
{
  return New post_op_attr;
}
bool_t
xdr_post_op_attr (XDR *xdrs, void *objp)
{
  switch (xdrs->x_op) {
  case XDR_ENCODE:
  case XDR_DECODE:
    return rpc_traverse (xdrs, *static_cast<post_op_attr *> (objp));
  case XDR_FREE:
    rpc_destruct (static_cast<post_op_attr *> (objp));
    return true;
  default:
    panic ("invalid xdr operation %d\n", xdrs->x_op);
  }
}

void *
wcc_attr_alloc ()
{
  return New wcc_attr;
}
bool_t
xdr_wcc_attr (XDR *xdrs, void *objp)
{
  switch (xdrs->x_op) {
  case XDR_ENCODE:
  case XDR_DECODE:
    return rpc_traverse (xdrs, *static_cast<wcc_attr *> (objp));
  case XDR_FREE:
    rpc_destruct (static_cast<wcc_attr *> (objp));
    return true;
  default:
    panic ("invalid xdr operation %d\n", xdrs->x_op);
  }
}

void *
pre_op_attr_alloc ()
{
  return New pre_op_attr;
}
bool_t
xdr_pre_op_attr (XDR *xdrs, void *objp)
{
  switch (xdrs->x_op) {
  case XDR_ENCODE:
  case XDR_DECODE:
    return rpc_traverse (xdrs, *static_cast<pre_op_attr *> (objp));
  case XDR_FREE:
    rpc_destruct (static_cast<pre_op_attr *> (objp));
    return true;
  default:
    panic ("invalid xdr operation %d\n", xdrs->x_op);
  }
}

void *
wcc_data_alloc ()
{
  return New wcc_data;
}
bool_t
xdr_wcc_data (XDR *xdrs, void *objp)
{
  switch (xdrs->x_op) {
  case XDR_ENCODE:
  case XDR_DECODE:
    return rpc_traverse (xdrs, *static_cast<wcc_data *> (objp));
  case XDR_FREE:
    rpc_destruct (static_cast<wcc_data *> (objp));
    return true;
  default:
    panic ("invalid xdr operation %d\n", xdrs->x_op);
  }
}

void *
post_op_fh3_alloc ()
{
  return New post_op_fh3;
}
bool_t
xdr_post_op_fh3 (XDR *xdrs, void *objp)
{
  switch (xdrs->x_op) {
  case XDR_ENCODE:
  case XDR_DECODE:
    return rpc_traverse (xdrs, *static_cast<post_op_fh3 *> (objp));
  case XDR_FREE:
    rpc_destruct (static_cast<post_op_fh3 *> (objp));
    return true;
  default:
    panic ("invalid xdr operation %d\n", xdrs->x_op);
  }
}

void *
set_uint32_alloc ()
{
  return New set_uint32;
}
bool_t
xdr_set_uint32 (XDR *xdrs, void *objp)
{
  switch (xdrs->x_op) {
  case XDR_ENCODE:
  case XDR_DECODE:
    return rpc_traverse (xdrs, *static_cast<set_uint32 *> (objp));
  case XDR_FREE:
    rpc_destruct (static_cast<set_uint32 *> (objp));
    return true;
  default:
    panic ("invalid xdr operation %d\n", xdrs->x_op);
  }
}

void *
set_uint64_alloc ()
{
  return New set_uint64;
}
bool_t
xdr_set_uint64 (XDR *xdrs, void *objp)
{
  switch (xdrs->x_op) {
  case XDR_ENCODE:
  case XDR_DECODE:
    return rpc_traverse (xdrs, *static_cast<set_uint64 *> (objp));
  case XDR_FREE:
    rpc_destruct (static_cast<set_uint64 *> (objp));
    return true;
  default:
    panic ("invalid xdr operation %d\n", xdrs->x_op);
  }
}

void *
time_how_alloc ()
{
  return New time_how;
}
bool_t
xdr_time_how (XDR *xdrs, void *objp)
{
  switch (xdrs->x_op) {
  case XDR_ENCODE:
  case XDR_DECODE:
    return rpc_traverse (xdrs, *static_cast<time_how *> (objp));
  case XDR_FREE:
    rpc_destruct (static_cast<time_how *> (objp));
    return true;
  default:
    panic ("invalid xdr operation %d\n", xdrs->x_op);
  }
}

void *
set_time_alloc ()
{
  return New set_time;
}
bool_t
xdr_set_time (XDR *xdrs, void *objp)
{
  switch (xdrs->x_op) {
  case XDR_ENCODE:
  case XDR_DECODE:
    return rpc_traverse (xdrs, *static_cast<set_time *> (objp));
  case XDR_FREE:
    rpc_destruct (static_cast<set_time *> (objp));
    return true;
  default:
    panic ("invalid xdr operation %d\n", xdrs->x_op);
  }
}

void *
sattr3_alloc ()
{
  return New sattr3;
}
bool_t
xdr_sattr3 (XDR *xdrs, void *objp)
{
  switch (xdrs->x_op) {
  case XDR_ENCODE:
  case XDR_DECODE:
    return rpc_traverse (xdrs, *static_cast<sattr3 *> (objp));
  case XDR_FREE:
    rpc_destruct (static_cast<sattr3 *> (objp));
    return true;
  default:
    panic ("invalid xdr operation %d\n", xdrs->x_op);
  }
}

void *
diropargs3_alloc ()
{
  return New diropargs3;
}
bool_t
xdr_diropargs3 (XDR *xdrs, void *objp)
{
  switch (xdrs->x_op) {
  case XDR_ENCODE:
  case XDR_DECODE:
    return rpc_traverse (xdrs, *static_cast<diropargs3 *> (objp));
  case XDR_FREE:
    rpc_destruct (static_cast<diropargs3 *> (objp));
    return true;
  default:
    panic ("invalid xdr operation %d\n", xdrs->x_op);
  }
}

void *
diropres3ok_alloc ()
{
  return New diropres3ok;
}
bool_t
xdr_diropres3ok (XDR *xdrs, void *objp)
{
  switch (xdrs->x_op) {
  case XDR_ENCODE:
  case XDR_DECODE:
    return rpc_traverse (xdrs, *static_cast<diropres3ok *> (objp));
  case XDR_FREE:
    rpc_destruct (static_cast<diropres3ok *> (objp));
    return true;
  default:
    panic ("invalid xdr operation %d\n", xdrs->x_op);
  }
}

void *
diropres3_alloc ()
{
  return New diropres3;
}
bool_t
xdr_diropres3 (XDR *xdrs, void *objp)
{
  switch (xdrs->x_op) {
  case XDR_ENCODE:
  case XDR_DECODE:
    return rpc_traverse (xdrs, *static_cast<diropres3 *> (objp));
  case XDR_FREE:
    rpc_destruct (static_cast<diropres3 *> (objp));
    return true;
  default:
    panic ("invalid xdr operation %d\n", xdrs->x_op);
  }
}

void *
wccstat3_alloc ()
{
  return New wccstat3;
}
bool_t
xdr_wccstat3 (XDR *xdrs, void *objp)
{
  switch (xdrs->x_op) {
  case XDR_ENCODE:
  case XDR_DECODE:
    return rpc_traverse (xdrs, *static_cast<wccstat3 *> (objp));
  case XDR_FREE:
    rpc_destruct (static_cast<wccstat3 *> (objp));
    return true;
  default:
    panic ("invalid xdr operation %d\n", xdrs->x_op);
  }
}

void *
getattr3res_alloc ()
{
  return New getattr3res;
}
bool_t
xdr_getattr3res (XDR *xdrs, void *objp)
{
  switch (xdrs->x_op) {
  case XDR_ENCODE:
  case XDR_DECODE:
    return rpc_traverse (xdrs, *static_cast<getattr3res *> (objp));
  case XDR_FREE:
    rpc_destruct (static_cast<getattr3res *> (objp));
    return true;
  default:
    panic ("invalid xdr operation %d\n", xdrs->x_op);
  }
}

void *
sattrguard3_alloc ()
{
  return New sattrguard3;
}
bool_t
xdr_sattrguard3 (XDR *xdrs, void *objp)
{
  switch (xdrs->x_op) {
  case XDR_ENCODE:
  case XDR_DECODE:
    return rpc_traverse (xdrs, *static_cast<sattrguard3 *> (objp));
  case XDR_FREE:
    rpc_destruct (static_cast<sattrguard3 *> (objp));
    return true;
  default:
    panic ("invalid xdr operation %d\n", xdrs->x_op);
  }
}

void *
setattr3args_alloc ()
{
  return New setattr3args;
}
bool_t
xdr_setattr3args (XDR *xdrs, void *objp)
{
  switch (xdrs->x_op) {
  case XDR_ENCODE:
  case XDR_DECODE:
    return rpc_traverse (xdrs, *static_cast<setattr3args *> (objp));
  case XDR_FREE:
    rpc_destruct (static_cast<setattr3args *> (objp));
    return true;
  default:
    panic ("invalid xdr operation %d\n", xdrs->x_op);
  }
}

void *
lookup3resok_alloc ()
{
  return New lookup3resok;
}
bool_t
xdr_lookup3resok (XDR *xdrs, void *objp)
{
  switch (xdrs->x_op) {
  case XDR_ENCODE:
  case XDR_DECODE:
    return rpc_traverse (xdrs, *static_cast<lookup3resok *> (objp));
  case XDR_FREE:
    rpc_destruct (static_cast<lookup3resok *> (objp));
    return true;
  default:
    panic ("invalid xdr operation %d\n", xdrs->x_op);
  }
}

void *
lookup3res_alloc ()
{
  return New lookup3res;
}
bool_t
xdr_lookup3res (XDR *xdrs, void *objp)
{
  switch (xdrs->x_op) {
  case XDR_ENCODE:
  case XDR_DECODE:
    return rpc_traverse (xdrs, *static_cast<lookup3res *> (objp));
  case XDR_FREE:
    rpc_destruct (static_cast<lookup3res *> (objp));
    return true;
  default:
    panic ("invalid xdr operation %d\n", xdrs->x_op);
  }
}

void *
access3args_alloc ()
{
  return New access3args;
}
bool_t
xdr_access3args (XDR *xdrs, void *objp)
{
  switch (xdrs->x_op) {
  case XDR_ENCODE:
  case XDR_DECODE:
    return rpc_traverse (xdrs, *static_cast<access3args *> (objp));
  case XDR_FREE:
    rpc_destruct (static_cast<access3args *> (objp));
    return true;
  default:
    panic ("invalid xdr operation %d\n", xdrs->x_op);
  }
}

void *
access3resok_alloc ()
{
  return New access3resok;
}
bool_t
xdr_access3resok (XDR *xdrs, void *objp)
{
  switch (xdrs->x_op) {
  case XDR_ENCODE:
  case XDR_DECODE:
    return rpc_traverse (xdrs, *static_cast<access3resok *> (objp));
  case XDR_FREE:
    rpc_destruct (static_cast<access3resok *> (objp));
    return true;
  default:
    panic ("invalid xdr operation %d\n", xdrs->x_op);
  }
}

void *
access3res_alloc ()
{
  return New access3res;
}
bool_t
xdr_access3res (XDR *xdrs, void *objp)
{
  switch (xdrs->x_op) {
  case XDR_ENCODE:
  case XDR_DECODE:
    return rpc_traverse (xdrs, *static_cast<access3res *> (objp));
  case XDR_FREE:
    rpc_destruct (static_cast<access3res *> (objp));
    return true;
  default:
    panic ("invalid xdr operation %d\n", xdrs->x_op);
  }
}

void *
readlink3resok_alloc ()
{
  return New readlink3resok;
}
bool_t
xdr_readlink3resok (XDR *xdrs, void *objp)
{
  switch (xdrs->x_op) {
  case XDR_ENCODE:
  case XDR_DECODE:
    return rpc_traverse (xdrs, *static_cast<readlink3resok *> (objp));
  case XDR_FREE:
    rpc_destruct (static_cast<readlink3resok *> (objp));
    return true;
  default:
    panic ("invalid xdr operation %d\n", xdrs->x_op);
  }
}

void *
readlink3res_alloc ()
{
  return New readlink3res;
}
bool_t
xdr_readlink3res (XDR *xdrs, void *objp)
{
  switch (xdrs->x_op) {
  case XDR_ENCODE:
  case XDR_DECODE:
    return rpc_traverse (xdrs, *static_cast<readlink3res *> (objp));
  case XDR_FREE:
    rpc_destruct (static_cast<readlink3res *> (objp));
    return true;
  default:
    panic ("invalid xdr operation %d\n", xdrs->x_op);
  }
}

void *
read3args_alloc ()
{
  return New read3args;
}
bool_t
xdr_read3args (XDR *xdrs, void *objp)
{
  switch (xdrs->x_op) {
  case XDR_ENCODE:
  case XDR_DECODE:
    return rpc_traverse (xdrs, *static_cast<read3args *> (objp));
  case XDR_FREE:
    rpc_destruct (static_cast<read3args *> (objp));
    return true;
  default:
    panic ("invalid xdr operation %d\n", xdrs->x_op);
  }
}

void *
read3resok_alloc ()
{
  return New read3resok;
}
bool_t
xdr_read3resok (XDR *xdrs, void *objp)
{
  switch (xdrs->x_op) {
  case XDR_ENCODE:
  case XDR_DECODE:
    return rpc_traverse (xdrs, *static_cast<read3resok *> (objp));
  case XDR_FREE:
    rpc_destruct (static_cast<read3resok *> (objp));
    return true;
  default:
    panic ("invalid xdr operation %d\n", xdrs->x_op);
  }
}

void *
read3res_alloc ()
{
  return New read3res;
}
bool_t
xdr_read3res (XDR *xdrs, void *objp)
{
  switch (xdrs->x_op) {
  case XDR_ENCODE:
  case XDR_DECODE:
    return rpc_traverse (xdrs, *static_cast<read3res *> (objp));
  case XDR_FREE:
    rpc_destruct (static_cast<read3res *> (objp));
    return true;
  default:
    panic ("invalid xdr operation %d\n", xdrs->x_op);
  }
}

void *
stable_how_alloc ()
{
  return New stable_how;
}
bool_t
xdr_stable_how (XDR *xdrs, void *objp)
{
  switch (xdrs->x_op) {
  case XDR_ENCODE:
  case XDR_DECODE:
    return rpc_traverse (xdrs, *static_cast<stable_how *> (objp));
  case XDR_FREE:
    rpc_destruct (static_cast<stable_how *> (objp));
    return true;
  default:
    panic ("invalid xdr operation %d\n", xdrs->x_op);
  }
}

void *
write3args_alloc ()
{
  return New write3args;
}
bool_t
xdr_write3args (XDR *xdrs, void *objp)
{
  switch (xdrs->x_op) {
  case XDR_ENCODE:
  case XDR_DECODE:
    return rpc_traverse (xdrs, *static_cast<write3args *> (objp));
  case XDR_FREE:
    rpc_destruct (static_cast<write3args *> (objp));
    return true;
  default:
    panic ("invalid xdr operation %d\n", xdrs->x_op);
  }
}

void *
write3resok_alloc ()
{
  return New write3resok;
}
bool_t
xdr_write3resok (XDR *xdrs, void *objp)
{
  switch (xdrs->x_op) {
  case XDR_ENCODE:
  case XDR_DECODE:
    return rpc_traverse (xdrs, *static_cast<write3resok *> (objp));
  case XDR_FREE:
    rpc_destruct (static_cast<write3resok *> (objp));
    return true;
  default:
    panic ("invalid xdr operation %d\n", xdrs->x_op);
  }
}

void *
write3res_alloc ()
{
  return New write3res;
}
bool_t
xdr_write3res (XDR *xdrs, void *objp)
{
  switch (xdrs->x_op) {
  case XDR_ENCODE:
  case XDR_DECODE:
    return rpc_traverse (xdrs, *static_cast<write3res *> (objp));
  case XDR_FREE:
    rpc_destruct (static_cast<write3res *> (objp));
    return true;
  default:
    panic ("invalid xdr operation %d\n", xdrs->x_op);
  }
}

void *
createmode3_alloc ()
{
  return New createmode3;
}
bool_t
xdr_createmode3 (XDR *xdrs, void *objp)
{
  switch (xdrs->x_op) {
  case XDR_ENCODE:
  case XDR_DECODE:
    return rpc_traverse (xdrs, *static_cast<createmode3 *> (objp));
  case XDR_FREE:
    rpc_destruct (static_cast<createmode3 *> (objp));
    return true;
  default:
    panic ("invalid xdr operation %d\n", xdrs->x_op);
  }
}

void *
createhow3_alloc ()
{
  return New createhow3;
}
bool_t
xdr_createhow3 (XDR *xdrs, void *objp)
{
  switch (xdrs->x_op) {
  case XDR_ENCODE:
  case XDR_DECODE:
    return rpc_traverse (xdrs, *static_cast<createhow3 *> (objp));
  case XDR_FREE:
    rpc_destruct (static_cast<createhow3 *> (objp));
    return true;
  default:
    panic ("invalid xdr operation %d\n", xdrs->x_op);
  }
}

void *
create3args_alloc ()
{
  return New create3args;
}
bool_t
xdr_create3args (XDR *xdrs, void *objp)
{
  switch (xdrs->x_op) {
  case XDR_ENCODE:
  case XDR_DECODE:
    return rpc_traverse (xdrs, *static_cast<create3args *> (objp));
  case XDR_FREE:
    rpc_destruct (static_cast<create3args *> (objp));
    return true;
  default:
    panic ("invalid xdr operation %d\n", xdrs->x_op);
  }
}

void *
mkdir3args_alloc ()
{
  return New mkdir3args;
}
bool_t
xdr_mkdir3args (XDR *xdrs, void *objp)
{
  switch (xdrs->x_op) {
  case XDR_ENCODE:
  case XDR_DECODE:
    return rpc_traverse (xdrs, *static_cast<mkdir3args *> (objp));
  case XDR_FREE:
    rpc_destruct (static_cast<mkdir3args *> (objp));
    return true;
  default:
    panic ("invalid xdr operation %d\n", xdrs->x_op);
  }
}

void *
symlinkdata3_alloc ()
{
  return New symlinkdata3;
}
bool_t
xdr_symlinkdata3 (XDR *xdrs, void *objp)
{
  switch (xdrs->x_op) {
  case XDR_ENCODE:
  case XDR_DECODE:
    return rpc_traverse (xdrs, *static_cast<symlinkdata3 *> (objp));
  case XDR_FREE:
    rpc_destruct (static_cast<symlinkdata3 *> (objp));
    return true;
  default:
    panic ("invalid xdr operation %d\n", xdrs->x_op);
  }
}

void *
symlink3args_alloc ()
{
  return New symlink3args;
}
bool_t
xdr_symlink3args (XDR *xdrs, void *objp)
{
  switch (xdrs->x_op) {
  case XDR_ENCODE:
  case XDR_DECODE:
    return rpc_traverse (xdrs, *static_cast<symlink3args *> (objp));
  case XDR_FREE:
    rpc_destruct (static_cast<symlink3args *> (objp));
    return true;
  default:
    panic ("invalid xdr operation %d\n", xdrs->x_op);
  }
}

void *
devicedata3_alloc ()
{
  return New devicedata3;
}
bool_t
xdr_devicedata3 (XDR *xdrs, void *objp)
{
  switch (xdrs->x_op) {
  case XDR_ENCODE:
  case XDR_DECODE:
    return rpc_traverse (xdrs, *static_cast<devicedata3 *> (objp));
  case XDR_FREE:
    rpc_destruct (static_cast<devicedata3 *> (objp));
    return true;
  default:
    panic ("invalid xdr operation %d\n", xdrs->x_op);
  }
}

void *
mknoddata3_alloc ()
{
  return New mknoddata3;
}
bool_t
xdr_mknoddata3 (XDR *xdrs, void *objp)
{
  switch (xdrs->x_op) {
  case XDR_ENCODE:
  case XDR_DECODE:
    return rpc_traverse (xdrs, *static_cast<mknoddata3 *> (objp));
  case XDR_FREE:
    rpc_destruct (static_cast<mknoddata3 *> (objp));
    return true;
  default:
    panic ("invalid xdr operation %d\n", xdrs->x_op);
  }
}

void *
mknod3args_alloc ()
{
  return New mknod3args;
}
bool_t
xdr_mknod3args (XDR *xdrs, void *objp)
{
  switch (xdrs->x_op) {
  case XDR_ENCODE:
  case XDR_DECODE:
    return rpc_traverse (xdrs, *static_cast<mknod3args *> (objp));
  case XDR_FREE:
    rpc_destruct (static_cast<mknod3args *> (objp));
    return true;
  default:
    panic ("invalid xdr operation %d\n", xdrs->x_op);
  }
}

void *
rename3args_alloc ()
{
  return New rename3args;
}
bool_t
xdr_rename3args (XDR *xdrs, void *objp)
{
  switch (xdrs->x_op) {
  case XDR_ENCODE:
  case XDR_DECODE:
    return rpc_traverse (xdrs, *static_cast<rename3args *> (objp));
  case XDR_FREE:
    rpc_destruct (static_cast<rename3args *> (objp));
    return true;
  default:
    panic ("invalid xdr operation %d\n", xdrs->x_op);
  }
}

void *
rename3wcc_alloc ()
{
  return New rename3wcc;
}
bool_t
xdr_rename3wcc (XDR *xdrs, void *objp)
{
  switch (xdrs->x_op) {
  case XDR_ENCODE:
  case XDR_DECODE:
    return rpc_traverse (xdrs, *static_cast<rename3wcc *> (objp));
  case XDR_FREE:
    rpc_destruct (static_cast<rename3wcc *> (objp));
    return true;
  default:
    panic ("invalid xdr operation %d\n", xdrs->x_op);
  }
}

void *
rename3res_alloc ()
{
  return New rename3res;
}
bool_t
xdr_rename3res (XDR *xdrs, void *objp)
{
  switch (xdrs->x_op) {
  case XDR_ENCODE:
  case XDR_DECODE:
    return rpc_traverse (xdrs, *static_cast<rename3res *> (objp));
  case XDR_FREE:
    rpc_destruct (static_cast<rename3res *> (objp));
    return true;
  default:
    panic ("invalid xdr operation %d\n", xdrs->x_op);
  }
}

void *
link3args_alloc ()
{
  return New link3args;
}
bool_t
xdr_link3args (XDR *xdrs, void *objp)
{
  switch (xdrs->x_op) {
  case XDR_ENCODE:
  case XDR_DECODE:
    return rpc_traverse (xdrs, *static_cast<link3args *> (objp));
  case XDR_FREE:
    rpc_destruct (static_cast<link3args *> (objp));
    return true;
  default:
    panic ("invalid xdr operation %d\n", xdrs->x_op);
  }
}

void *
link3wcc_alloc ()
{
  return New link3wcc;
}
bool_t
xdr_link3wcc (XDR *xdrs, void *objp)
{
  switch (xdrs->x_op) {
  case XDR_ENCODE:
  case XDR_DECODE:
    return rpc_traverse (xdrs, *static_cast<link3wcc *> (objp));
  case XDR_FREE:
    rpc_destruct (static_cast<link3wcc *> (objp));
    return true;
  default:
    panic ("invalid xdr operation %d\n", xdrs->x_op);
  }
}

void *
link3res_alloc ()
{
  return New link3res;
}
bool_t
xdr_link3res (XDR *xdrs, void *objp)
{
  switch (xdrs->x_op) {
  case XDR_ENCODE:
  case XDR_DECODE:
    return rpc_traverse (xdrs, *static_cast<link3res *> (objp));
  case XDR_FREE:
    rpc_destruct (static_cast<link3res *> (objp));
    return true;
  default:
    panic ("invalid xdr operation %d\n", xdrs->x_op);
  }
}

void *
readdir3args_alloc ()
{
  return New readdir3args;
}
bool_t
xdr_readdir3args (XDR *xdrs, void *objp)
{
  switch (xdrs->x_op) {
  case XDR_ENCODE:
  case XDR_DECODE:
    return rpc_traverse (xdrs, *static_cast<readdir3args *> (objp));
  case XDR_FREE:
    rpc_destruct (static_cast<readdir3args *> (objp));
    return true;
  default:
    panic ("invalid xdr operation %d\n", xdrs->x_op);
  }
}

void *
entry3_alloc ()
{
  return New entry3;
}
bool_t
xdr_entry3 (XDR *xdrs, void *objp)
{
  switch (xdrs->x_op) {
  case XDR_ENCODE:
  case XDR_DECODE:
    return rpc_traverse (xdrs, *static_cast<entry3 *> (objp));
  case XDR_FREE:
    rpc_destruct (static_cast<entry3 *> (objp));
    return true;
  default:
    panic ("invalid xdr operation %d\n", xdrs->x_op);
  }
}

void *
dirlist3_alloc ()
{
  return New dirlist3;
}
bool_t
xdr_dirlist3 (XDR *xdrs, void *objp)
{
  switch (xdrs->x_op) {
  case XDR_ENCODE:
  case XDR_DECODE:
    return rpc_traverse (xdrs, *static_cast<dirlist3 *> (objp));
  case XDR_FREE:
    rpc_destruct (static_cast<dirlist3 *> (objp));
    return true;
  default:
    panic ("invalid xdr operation %d\n", xdrs->x_op);
  }
}

void *
readdir3resok_alloc ()
{
  return New readdir3resok;
}
bool_t
xdr_readdir3resok (XDR *xdrs, void *objp)
{
  switch (xdrs->x_op) {
  case XDR_ENCODE:
  case XDR_DECODE:
    return rpc_traverse (xdrs, *static_cast<readdir3resok *> (objp));
  case XDR_FREE:
    rpc_destruct (static_cast<readdir3resok *> (objp));
    return true;
  default:
    panic ("invalid xdr operation %d\n", xdrs->x_op);
  }
}

void *
readdir3res_alloc ()
{
  return New readdir3res;
}
bool_t
xdr_readdir3res (XDR *xdrs, void *objp)
{
  switch (xdrs->x_op) {
  case XDR_ENCODE:
  case XDR_DECODE:
    return rpc_traverse (xdrs, *static_cast<readdir3res *> (objp));
  case XDR_FREE:
    rpc_destruct (static_cast<readdir3res *> (objp));
    return true;
  default:
    panic ("invalid xdr operation %d\n", xdrs->x_op);
  }
}

void *
readdirplus3args_alloc ()
{
  return New readdirplus3args;
}
bool_t
xdr_readdirplus3args (XDR *xdrs, void *objp)
{
  switch (xdrs->x_op) {
  case XDR_ENCODE:
  case XDR_DECODE:
    return rpc_traverse (xdrs, *static_cast<readdirplus3args *> (objp));
  case XDR_FREE:
    rpc_destruct (static_cast<readdirplus3args *> (objp));
    return true;
  default:
    panic ("invalid xdr operation %d\n", xdrs->x_op);
  }
}

void *
entryplus3_alloc ()
{
  return New entryplus3;
}
bool_t
xdr_entryplus3 (XDR *xdrs, void *objp)
{
  switch (xdrs->x_op) {
  case XDR_ENCODE:
  case XDR_DECODE:
    return rpc_traverse (xdrs, *static_cast<entryplus3 *> (objp));
  case XDR_FREE:
    rpc_destruct (static_cast<entryplus3 *> (objp));
    return true;
  default:
    panic ("invalid xdr operation %d\n", xdrs->x_op);
  }
}

void *
dirlistplus3_alloc ()
{
  return New dirlistplus3;
}
bool_t
xdr_dirlistplus3 (XDR *xdrs, void *objp)
{
  switch (xdrs->x_op) {
  case XDR_ENCODE:
  case XDR_DECODE:
    return rpc_traverse (xdrs, *static_cast<dirlistplus3 *> (objp));
  case XDR_FREE:
    rpc_destruct (static_cast<dirlistplus3 *> (objp));
    return true;
  default:
    panic ("invalid xdr operation %d\n", xdrs->x_op);
  }
}

void *
readdirplus3resok_alloc ()
{
  return New readdirplus3resok;
}
bool_t
xdr_readdirplus3resok (XDR *xdrs, void *objp)
{
  switch (xdrs->x_op) {
  case XDR_ENCODE:
  case XDR_DECODE:
    return rpc_traverse (xdrs, *static_cast<readdirplus3resok *> (objp));
  case XDR_FREE:
    rpc_destruct (static_cast<readdirplus3resok *> (objp));
    return true;
  default:
    panic ("invalid xdr operation %d\n", xdrs->x_op);
  }
}

void *
readdirplus3res_alloc ()
{
  return New readdirplus3res;
}
bool_t
xdr_readdirplus3res (XDR *xdrs, void *objp)
{
  switch (xdrs->x_op) {
  case XDR_ENCODE:
  case XDR_DECODE:
    return rpc_traverse (xdrs, *static_cast<readdirplus3res *> (objp));
  case XDR_FREE:
    rpc_destruct (static_cast<readdirplus3res *> (objp));
    return true;
  default:
    panic ("invalid xdr operation %d\n", xdrs->x_op);
  }
}

void *
fsstat3resok_alloc ()
{
  return New fsstat3resok;
}
bool_t
xdr_fsstat3resok (XDR *xdrs, void *objp)
{
  switch (xdrs->x_op) {
  case XDR_ENCODE:
  case XDR_DECODE:
    return rpc_traverse (xdrs, *static_cast<fsstat3resok *> (objp));
  case XDR_FREE:
    rpc_destruct (static_cast<fsstat3resok *> (objp));
    return true;
  default:
    panic ("invalid xdr operation %d\n", xdrs->x_op);
  }
}

void *
fsstat3res_alloc ()
{
  return New fsstat3res;
}
bool_t
xdr_fsstat3res (XDR *xdrs, void *objp)
{
  switch (xdrs->x_op) {
  case XDR_ENCODE:
  case XDR_DECODE:
    return rpc_traverse (xdrs, *static_cast<fsstat3res *> (objp));
  case XDR_FREE:
    rpc_destruct (static_cast<fsstat3res *> (objp));
    return true;
  default:
    panic ("invalid xdr operation %d\n", xdrs->x_op);
  }
}

void *
fsinfo3resok_alloc ()
{
  return New fsinfo3resok;
}
bool_t
xdr_fsinfo3resok (XDR *xdrs, void *objp)
{
  switch (xdrs->x_op) {
  case XDR_ENCODE:
  case XDR_DECODE:
    return rpc_traverse (xdrs, *static_cast<fsinfo3resok *> (objp));
  case XDR_FREE:
    rpc_destruct (static_cast<fsinfo3resok *> (objp));
    return true;
  default:
    panic ("invalid xdr operation %d\n", xdrs->x_op);
  }
}

void *
fsinfo3res_alloc ()
{
  return New fsinfo3res;
}
bool_t
xdr_fsinfo3res (XDR *xdrs, void *objp)
{
  switch (xdrs->x_op) {
  case XDR_ENCODE:
  case XDR_DECODE:
    return rpc_traverse (xdrs, *static_cast<fsinfo3res *> (objp));
  case XDR_FREE:
    rpc_destruct (static_cast<fsinfo3res *> (objp));
    return true;
  default:
    panic ("invalid xdr operation %d\n", xdrs->x_op);
  }
}

void *
pathconf3resok_alloc ()
{
  return New pathconf3resok;
}
bool_t
xdr_pathconf3resok (XDR *xdrs, void *objp)
{
  switch (xdrs->x_op) {
  case XDR_ENCODE:
  case XDR_DECODE:
    return rpc_traverse (xdrs, *static_cast<pathconf3resok *> (objp));
  case XDR_FREE:
    rpc_destruct (static_cast<pathconf3resok *> (objp));
    return true;
  default:
    panic ("invalid xdr operation %d\n", xdrs->x_op);
  }
}

void *
pathconf3res_alloc ()
{
  return New pathconf3res;
}
bool_t
xdr_pathconf3res (XDR *xdrs, void *objp)
{
  switch (xdrs->x_op) {
  case XDR_ENCODE:
  case XDR_DECODE:
    return rpc_traverse (xdrs, *static_cast<pathconf3res *> (objp));
  case XDR_FREE:
    rpc_destruct (static_cast<pathconf3res *> (objp));
    return true;
  default:
    panic ("invalid xdr operation %d\n", xdrs->x_op);
  }
}

void *
commit3args_alloc ()
{
  return New commit3args;
}
bool_t
xdr_commit3args (XDR *xdrs, void *objp)
{
  switch (xdrs->x_op) {
  case XDR_ENCODE:
  case XDR_DECODE:
    return rpc_traverse (xdrs, *static_cast<commit3args *> (objp));
  case XDR_FREE:
    rpc_destruct (static_cast<commit3args *> (objp));
    return true;
  default:
    panic ("invalid xdr operation %d\n", xdrs->x_op);
  }
}

void *
commit3resok_alloc ()
{
  return New commit3resok;
}
bool_t
xdr_commit3resok (XDR *xdrs, void *objp)
{
  switch (xdrs->x_op) {
  case XDR_ENCODE:
  case XDR_DECODE:
    return rpc_traverse (xdrs, *static_cast<commit3resok *> (objp));
  case XDR_FREE:
    rpc_destruct (static_cast<commit3resok *> (objp));
    return true;
  default:
    panic ("invalid xdr operation %d\n", xdrs->x_op);
  }
}

void *
commit3res_alloc ()
{
  return New commit3res;
}
bool_t
xdr_commit3res (XDR *xdrs, void *objp)
{
  switch (xdrs->x_op) {
  case XDR_ENCODE:
  case XDR_DECODE:
    return rpc_traverse (xdrs, *static_cast<commit3res *> (objp));
  case XDR_FREE:
    rpc_destruct (static_cast<commit3res *> (objp));
    return true;
  default:
    panic ("invalid xdr operation %d\n", xdrs->x_op);
  }
}

static const rpcgen_table nfs_program_3_tbl[] = {
  NFS_PROGRAM_3_APPLY (XDRTBL_DECL)
};
const rpc_program nfs_program_3 = {
  NFS_PROGRAM, NFS_V3, nfs_program_3_tbl,
  sizeof (nfs_program_3_tbl) / sizeof (nfs_program_3_tbl[0]),
  "nfs_program_3"
};


