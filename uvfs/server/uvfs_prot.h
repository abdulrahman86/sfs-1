// -*-c++-*-
/* This file was automatically generated by rpcc. */

#ifndef __RPCC_UVFS_PROT_H_INCLUDED__
#define __RPCC_UVFS_PROT_H_INCLUDED__ 1

#include "xdrmisc.h"
#include "nfs3exp_prot.h"

typedef u_int32_t uvfs_fh;
void *uvfs_fh_alloc ();
bool_t xdr_uvfs_fh (XDR *, void *);
RPC_TYPEDEF_DECL (uvfs_fh)

typedef ex_fattr3 uvfs_fattr;
void *uvfs_fattr_alloc ();
bool_t xdr_uvfs_fattr (XDR *, void *);
RPC_TYPEDEF_DECL (uvfs_fattr)

typedef ex_getattr3res uvfs_attrres;
void *uvfs_attrres_alloc ();
bool_t xdr_uvfs_attrres (XDR *, void *);
RPC_TYPEDEF_DECL (uvfs_attrres)

typedef ex_wccstat3 uvfs_wccstat;
void *uvfs_wccstat_alloc ();
bool_t xdr_uvfs_wccstat (XDR *, void *);
RPC_TYPEDEF_DECL (uvfs_wccstat)

typedef ex_access3res uvfs_accessres;
void *uvfs_accessres_alloc ();
bool_t xdr_uvfs_accessres (XDR *, void *);
RPC_TYPEDEF_DECL (uvfs_accessres)

typedef ex_readlink3res uvfs_readlinkres;
void *uvfs_readlinkres_alloc ();
bool_t xdr_uvfs_readlinkres (XDR *, void *);
RPC_TYPEDEF_DECL (uvfs_readlinkres)

typedef ex_read3res uvfs_readres;
void *uvfs_readres_alloc ();
bool_t xdr_uvfs_readres (XDR *, void *);
RPC_TYPEDEF_DECL (uvfs_readres)

typedef ex_write3res uvfs_writeres;
void *uvfs_writeres_alloc ();
bool_t xdr_uvfs_writeres (XDR *, void *);
RPC_TYPEDEF_DECL (uvfs_writeres)

typedef ex_rename3res uvfs_renameres;
void *uvfs_renameres_alloc ();
bool_t xdr_uvfs_renameres (XDR *, void *);
RPC_TYPEDEF_DECL (uvfs_renameres)

typedef ex_link3res uvfs_linkres;
void *uvfs_linkres_alloc ();
bool_t xdr_uvfs_linkres (XDR *, void *);
RPC_TYPEDEF_DECL (uvfs_linkres)

typedef ex_fsstat3res uvfs_statfsres;
void *uvfs_statfsres_alloc ();
bool_t xdr_uvfs_statfsres (XDR *, void *);
RPC_TYPEDEF_DECL (uvfs_statfsres)

typedef ex_commit3res uvfs_commitres;
void *uvfs_commitres_alloc ();
bool_t xdr_uvfs_commitres (XDR *, void *);
RPC_TYPEDEF_DECL (uvfs_commitres)

typedef filename3 uvfs_filename;
void *uvfs_filename_alloc ();
bool_t xdr_uvfs_filename (XDR *, void *);
RPC_TYPEDEF_DECL (uvfs_filename)

typedef nfspath3 uvfs_pathname;
void *uvfs_pathname_alloc ();
bool_t xdr_uvfs_pathname (XDR *, void *);
RPC_TYPEDEF_DECL (uvfs_pathname)

typedef nfstime3 uvfs_time;
void *uvfs_time_alloc ();
bool_t xdr_uvfs_time (XDR *, void *);
RPC_TYPEDEF_DECL (uvfs_time)

typedef sattr3 uvfs_sattr;
void *uvfs_sattr_alloc ();
bool_t xdr_uvfs_sattr (XDR *, void *);
RPC_TYPEDEF_DECL (uvfs_sattr)

typedef sattrguard3 uvfs_guard;
void *uvfs_guard_alloc ();
bool_t xdr_uvfs_guard (XDR *, void *);
RPC_TYPEDEF_DECL (uvfs_guard)

typedef int32_t uvfsstat;
void *uvfsstat_alloc ();
bool_t xdr_uvfsstat (XDR *, void *);
RPC_TYPEDEF_DECL (uvfsstat)


struct uvfs_readdirargs {
  uvfs_fh dir;
  u_int64_t cookie;
  u_int32_t count;
};
void *uvfs_readdirargs_alloc ();
bool_t xdr_uvfs_readdirargs (XDR *, void *);
RPC_STRUCT_DECL (uvfs_readdirargs)

template<class T> bool
rpc_traverse (T &t, uvfs_readdirargs &obj)
{
  return rpc_traverse (t, obj.dir)
    && rpc_traverse (t, obj.cookie)
    && rpc_traverse (t, obj.count);
}



struct uvfs_direntry {
  u_int64_t fileid;
  u_int64_t cookie;
  u_int32_t type;
  uvfs_filename name;
};
void *uvfs_direntry_alloc ();
bool_t xdr_uvfs_direntry (XDR *, void *);
RPC_STRUCT_DECL (uvfs_direntry)

template<class T> bool
rpc_traverse (T &t, uvfs_direntry &obj)
{
  return rpc_traverse (t, obj.fileid)
    && rpc_traverse (t, obj.cookie)
    && rpc_traverse (t, obj.type)
    && rpc_traverse (t, obj.name);
}



struct uvfs_dirlist {
  rpc_vec<uvfs_direntry, RPC_INFINITY> entries;
  bool eof;
};
void *uvfs_dirlist_alloc ();
bool_t xdr_uvfs_dirlist (XDR *, void *);
RPC_STRUCT_DECL (uvfs_dirlist)

template<class T> bool
rpc_traverse (T &t, uvfs_dirlist &obj)
{
  return rpc_traverse (t, obj.entries)
    && rpc_traverse (t, obj.eof);
}



struct uvfs_readdirres {
  const uvfsstat status;
  union {
    union_entry_base _base;
    union_entry<uvfs_dirlist> reply;
  };

#define rpcunion_tag_uvfs_readdirres status
#define rpcunion_switch_uvfs_readdirres(swarg, action, voidaction, defaction) \
  switch (swarg) { \
  case 0: \
    action (uvfs_dirlist, reply); \
    break; \
  default: \
    voidaction; \
    break; \
  }

  uvfs_readdirres (uvfsstat _tag = (uvfsstat) 0) : status (_tag)
    { _base.init (); set_status (_tag); }
  uvfs_readdirres (const uvfs_readdirres &_s)
    : status (_s.status)
    { _base.init (_s._base); }
  ~uvfs_readdirres () { _base.destroy (); }
  uvfs_readdirres &operator= (const uvfs_readdirres &_s) {
    const_cast<uvfsstat &> (status) = _s.status;
    _base.assign (_s._base);
    return *this;
  }

  void set_status (uvfsstat _tag) {
    const_cast<uvfsstat &> (status) = _tag;
    rpcunion_switch_uvfs_readdirres
      (_tag, RPCUNION_SET, _base.destroy (), _base.destroy ());
  }
};

template<class T> bool
rpc_traverse (T &t, uvfs_readdirres &obj)
{
  uvfsstat tag = obj.status;
  if (!rpc_traverse (t, tag))
    return false;
  if (tag != obj.status)
    obj.set_status (tag);

  rpcunion_switch_uvfs_readdirres
    (obj.status, RPCUNION_TRAVERSE, return true, return false);
}
inline bool
rpc_traverse (const stompcast_t &s, uvfs_readdirres &obj)
{
  rpcunion_switch_uvfs_readdirres
    (obj.status, RPCUNION_REC_STOMPCAST,
     obj._base.destroy (); return true, obj._base.destroy (); return true;);
}
void *uvfs_readdirres_alloc ();
bool_t xdr_uvfs_readdirres (XDR *, void *);
RPC_UNION_DECL (uvfs_readdirres)



struct uvfs_setattrargs {
  uvfs_fh file;
  uvfs_sattr attributes;
  uvfs_guard guard;
};
void *uvfs_setattrargs_alloc ();
bool_t xdr_uvfs_setattrargs (XDR *, void *);
RPC_STRUCT_DECL (uvfs_setattrargs)

template<class T> bool
rpc_traverse (T &t, uvfs_setattrargs &obj)
{
  return rpc_traverse (t, obj.file)
    && rpc_traverse (t, obj.attributes)
    && rpc_traverse (t, obj.guard);
}



struct post_op_uvfs_fh {
  const bool present;
  union {
    union_entry_base _base;
    union_entry<uvfs_fh> handle;
  };

#define rpcunion_tag_post_op_uvfs_fh present
#define rpcunion_switch_post_op_uvfs_fh(swarg, action, voidaction, defaction) \
  switch (swarg) { \
  case true: \
    action (uvfs_fh, handle); \
    break; \
  case false: \
    voidaction; \
    break; \
  default: \
    defaction; \
    break; \
  }

  post_op_uvfs_fh (bool _tag = (bool) 0) : present (_tag)
    { _base.init (); set_present (_tag); }
  post_op_uvfs_fh (const post_op_uvfs_fh &_s)
    : present (_s.present)
    { _base.init (_s._base); }
  ~post_op_uvfs_fh () { _base.destroy (); }
  post_op_uvfs_fh &operator= (const post_op_uvfs_fh &_s) {
    const_cast<bool &> (present) = _s.present;
    _base.assign (_s._base);
    return *this;
  }

  void set_present (bool _tag) {
    const_cast<bool &> (present) = _tag;
    rpcunion_switch_post_op_uvfs_fh
      (_tag, RPCUNION_SET, _base.destroy (), _base.destroy ());
  }
};

template<class T> bool
rpc_traverse (T &t, post_op_uvfs_fh &obj)
{
  bool tag = obj.present;
  if (!rpc_traverse (t, tag))
    return false;
  if (tag != obj.present)
    obj.set_present (tag);

  rpcunion_switch_post_op_uvfs_fh
    (obj.present, RPCUNION_TRAVERSE, return true, return false);
}
inline bool
rpc_traverse (const stompcast_t &s, post_op_uvfs_fh &obj)
{
  rpcunion_switch_post_op_uvfs_fh
    (obj.present, RPCUNION_REC_STOMPCAST,
     obj._base.destroy (); return true, obj._base.destroy (); return true;);
}
void *post_op_uvfs_fh_alloc ();
bool_t xdr_post_op_uvfs_fh (XDR *, void *);
RPC_UNION_DECL (post_op_uvfs_fh)



struct uvfs_diropargs {
  uvfs_fh dir;
  uvfs_filename name;
};
void *uvfs_diropargs_alloc ();
bool_t xdr_uvfs_diropargs (XDR *, void *);
RPC_STRUCT_DECL (uvfs_diropargs)

template<class T> bool
rpc_traverse (T &t, uvfs_diropargs &obj)
{
  return rpc_traverse (t, obj.dir)
    && rpc_traverse (t, obj.name);
}



struct uvfs_diropresok {
  post_op_uvfs_fh file;
  ex_post_op_attr attributes;
  ex_wcc_data dir_wcc;
};
void *uvfs_diropresok_alloc ();
bool_t xdr_uvfs_diropresok (XDR *, void *);
RPC_STRUCT_DECL (uvfs_diropresok)

template<class T> bool
rpc_traverse (T &t, uvfs_diropresok &obj)
{
  return rpc_traverse (t, obj.file)
    && rpc_traverse (t, obj.attributes)
    && rpc_traverse (t, obj.dir_wcc);
}



struct uvfs_diropres {
  const uvfsstat status;
  union {
    union_entry_base _base;
    union_entry<uvfs_diropresok> resok;
    union_entry<wcc_data> resfail;
  };

#define rpcunion_tag_uvfs_diropres status
#define rpcunion_switch_uvfs_diropres(swarg, action, voidaction, defaction) \
  switch (swarg) { \
  case 0: \
    action (uvfs_diropresok, resok); \
    break; \
  default: \
    action (wcc_data, resfail); \
    break; \
  }

  uvfs_diropres (uvfsstat _tag = (uvfsstat) 0) : status (_tag)
    { _base.init (); set_status (_tag); }
  uvfs_diropres (const uvfs_diropres &_s)
    : status (_s.status)
    { _base.init (_s._base); }
  ~uvfs_diropres () { _base.destroy (); }
  uvfs_diropres &operator= (const uvfs_diropres &_s) {
    const_cast<uvfsstat &> (status) = _s.status;
    _base.assign (_s._base);
    return *this;
  }

  void set_status (uvfsstat _tag) {
    const_cast<uvfsstat &> (status) = _tag;
    rpcunion_switch_uvfs_diropres
      (_tag, RPCUNION_SET, _base.destroy (), _base.destroy ());
  }
};

template<class T> bool
rpc_traverse (T &t, uvfs_diropres &obj)
{
  uvfsstat tag = obj.status;
  if (!rpc_traverse (t, tag))
    return false;
  if (tag != obj.status)
    obj.set_status (tag);

  rpcunion_switch_uvfs_diropres
    (obj.status, RPCUNION_TRAVERSE, return true, return false);
}
inline bool
rpc_traverse (const stompcast_t &s, uvfs_diropres &obj)
{
  rpcunion_switch_uvfs_diropres
    (obj.status, RPCUNION_REC_STOMPCAST,
     obj._base.destroy (); return true, obj._base.destroy (); return true;);
}
void *uvfs_diropres_alloc ();
bool_t xdr_uvfs_diropres (XDR *, void *);
RPC_UNION_DECL (uvfs_diropres)



struct uvfs_readargs {
  uvfs_fh file;
  u_int64_t offset;
  u_int32_t count;
};
void *uvfs_readargs_alloc ();
bool_t xdr_uvfs_readargs (XDR *, void *);
RPC_STRUCT_DECL (uvfs_readargs)

template<class T> bool
rpc_traverse (T &t, uvfs_readargs &obj)
{
  return rpc_traverse (t, obj.file)
    && rpc_traverse (t, obj.offset)
    && rpc_traverse (t, obj.count);
}



struct uvfs_writeargs {
  uvfs_fh file;
  u_int64_t offset;
  u_int32_t count;
  stable_how stable;
  rpc_bytes<RPC_INFINITY> data;
};
void *uvfs_writeargs_alloc ();
bool_t xdr_uvfs_writeargs (XDR *, void *);
RPC_STRUCT_DECL (uvfs_writeargs)

template<class T> bool
rpc_traverse (T &t, uvfs_writeargs &obj)
{
  return rpc_traverse (t, obj.file)
    && rpc_traverse (t, obj.offset)
    && rpc_traverse (t, obj.count)
    && rpc_traverse (t, obj.stable)
    && rpc_traverse (t, obj.data);
}



struct uvfs_createargs {
  uvfs_diropargs where;
  createhow3 how;
};
void *uvfs_createargs_alloc ();
bool_t xdr_uvfs_createargs (XDR *, void *);
RPC_STRUCT_DECL (uvfs_createargs)

template<class T> bool
rpc_traverse (T &t, uvfs_createargs &obj)
{
  return rpc_traverse (t, obj.where)
    && rpc_traverse (t, obj.how);
}



struct uvfs_mkdirargs {
  uvfs_diropargs where;
  uvfs_sattr attributes;
};
void *uvfs_mkdirargs_alloc ();
bool_t xdr_uvfs_mkdirargs (XDR *, void *);
RPC_STRUCT_DECL (uvfs_mkdirargs)

template<class T> bool
rpc_traverse (T &t, uvfs_mkdirargs &obj)
{
  return rpc_traverse (t, obj.where)
    && rpc_traverse (t, obj.attributes);
}



struct uvfs_renameargs {
  uvfs_diropargs from;
  uvfs_diropargs to;
};
void *uvfs_renameargs_alloc ();
bool_t xdr_uvfs_renameargs (XDR *, void *);
RPC_STRUCT_DECL (uvfs_renameargs)

template<class T> bool
rpc_traverse (T &t, uvfs_renameargs &obj)
{
  return rpc_traverse (t, obj.from)
    && rpc_traverse (t, obj.to);
}



struct uvfs_commitargs {
  uvfs_fh file;
  u_int64_t offset;
  u_int32_t count;
};
void *uvfs_commitargs_alloc ();
bool_t xdr_uvfs_commitargs (XDR *, void *);
RPC_STRUCT_DECL (uvfs_commitargs)

template<class T> bool
rpc_traverse (T &t, uvfs_commitargs &obj)
{
  return rpc_traverse (t, obj.file)
    && rpc_traverse (t, obj.offset)
    && rpc_traverse (t, obj.count);
}



struct uvfs_linkargs {
  uvfs_fh from;
  uvfs_diropargs to;
};
void *uvfs_linkargs_alloc ();
bool_t xdr_uvfs_linkargs (XDR *, void *);
RPC_STRUCT_DECL (uvfs_linkargs)

template<class T> bool
rpc_traverse (T &t, uvfs_linkargs &obj)
{
  return rpc_traverse (t, obj.from)
    && rpc_traverse (t, obj.to);
}



struct uvfs_symlinkargs {
  uvfs_diropargs where;
  symlinkdata3 symlink;
};
void *uvfs_symlinkargs_alloc ();
bool_t xdr_uvfs_symlinkargs (XDR *, void *);
RPC_STRUCT_DECL (uvfs_symlinkargs)

template<class T> bool
rpc_traverse (T &t, uvfs_symlinkargs &obj)
{
  return rpc_traverse (t, obj.where)
    && rpc_traverse (t, obj.symlink);
}



struct uvfs_accessargs {
  uvfs_fh object;
  u_int32_t access;
};
void *uvfs_accessargs_alloc ();
bool_t xdr_uvfs_accessargs (XDR *, void *);
RPC_STRUCT_DECL (uvfs_accessargs)

template<class T> bool
rpc_traverse (T &t, uvfs_accessargs &obj)
{
  return rpc_traverse (t, obj.object)
    && rpc_traverse (t, obj.access);
}



struct uvfs_lookupresok {
  uvfs_fh object;
  ex_post_op_attr obj_attributes;
  ex_post_op_attr dir_attributes;
};
void *uvfs_lookupresok_alloc ();
bool_t xdr_uvfs_lookupresok (XDR *, void *);
RPC_STRUCT_DECL (uvfs_lookupresok)

template<class T> bool
rpc_traverse (T &t, uvfs_lookupresok &obj)
{
  return rpc_traverse (t, obj.object)
    && rpc_traverse (t, obj.obj_attributes)
    && rpc_traverse (t, obj.dir_attributes);
}



struct uvfs_lookupres {
  const uvfsstat status;
  union {
    union_entry_base _base;
    union_entry<uvfs_lookupresok> resok;
    union_entry<ex_post_op_attr> resfail;
  };

#define rpcunion_tag_uvfs_lookupres status
#define rpcunion_switch_uvfs_lookupres(swarg, action, voidaction, defaction) \
  switch (swarg) { \
  case 0: \
    action (uvfs_lookupresok, resok); \
    break; \
  default: \
    action (ex_post_op_attr, resfail); \
    break; \
  }

  uvfs_lookupres (uvfsstat _tag = (uvfsstat) 0) : status (_tag)
    { _base.init (); set_status (_tag); }
  uvfs_lookupres (const uvfs_lookupres &_s)
    : status (_s.status)
    { _base.init (_s._base); }
  ~uvfs_lookupres () { _base.destroy (); }
  uvfs_lookupres &operator= (const uvfs_lookupres &_s) {
    const_cast<uvfsstat &> (status) = _s.status;
    _base.assign (_s._base);
    return *this;
  }

  void set_status (uvfsstat _tag) {
    const_cast<uvfsstat &> (status) = _tag;
    rpcunion_switch_uvfs_lookupres
      (_tag, RPCUNION_SET, _base.destroy (), _base.destroy ());
  }
};

template<class T> bool
rpc_traverse (T &t, uvfs_lookupres &obj)
{
  uvfsstat tag = obj.status;
  if (!rpc_traverse (t, tag))
    return false;
  if (tag != obj.status)
    obj.set_status (tag);

  rpcunion_switch_uvfs_lookupres
    (obj.status, RPCUNION_TRAVERSE, return true, return false);
}
inline bool
rpc_traverse (const stompcast_t &s, uvfs_lookupres &obj)
{
  rpcunion_switch_uvfs_lookupres
    (obj.status, RPCUNION_REC_STOMPCAST,
     obj._base.destroy (); return true, obj._base.destroy (); return true;);
}
void *uvfs_lookupres_alloc ();
bool_t xdr_uvfs_lookupres (XDR *, void *);
RPC_UNION_DECL (uvfs_lookupres)


#ifndef UVFSPROG
#define UVFSPROG 536870913
#endif /* !UVFSPROG */
extern const rpc_program uvfsprog_1;
enum { UVFSVER = 1 };
enum {
  UVFSPROC_NULL = 0,
  UVFSPROC_GETATTR = 1,
  UVFSPROC_SETATTR = 2,
  UVFSPROC_LOOKUP = 3,
  UVFSPROC_ACCESS = 4,
  UVFSPROC_READLINK = 5,
  UVFSPROC_READ = 6,
  UVFSPROC_WRITE = 7,
  UVFSPROC_CREATE = 8,
  UVFSPROC_MKDIR = 9,
  UVFSPROC_SYMLINK = 10,
  UVFSPROC_MKNOD = 11,
  UVFSPROC_REMOVE = 12,
  UVFSPROC_RMDIR = 13,
  UVFSPROC_RENAME = 14,
  UVFSPROC_LINK = 15,
  UVFSPROC_READDIR = 16,
  UVFSPROC_READDIRPLUS = 17,
  UVFSPROC_STATFS = 18,
  UVFSPROC_FSINFO = 19,
  UVFSPROC_PATHCONF = 20,
  UVFSPROC_COMMIT = 21,
  UVFSPROC_OPEN = 22,
  UVFSPROC_CLOSE = 23,
  UVFSPROC_INACTIVE = 24,
  UVFSPROC_RECLAIM = 25,
};
#define UVFSPROG_1_APPLY_NOVOID(macro, void) \
  macro (UVFSPROC_NULL, void, void) \
  macro (UVFSPROC_GETATTR, uvfs_fh, uvfs_attrres) \
  macro (UVFSPROC_SETATTR, uvfs_setattrargs, uvfs_wccstat) \
  macro (UVFSPROC_LOOKUP, uvfs_diropargs, uvfs_lookupres) \
  macro (UVFSPROC_ACCESS, uvfs_accessargs, uvfs_accessres) \
  macro (UVFSPROC_READLINK, uvfs_fh, uvfs_readlinkres) \
  macro (UVFSPROC_READ, uvfs_readargs, uvfs_readres) \
  macro (UVFSPROC_WRITE, uvfs_writeargs, uvfs_writeres) \
  macro (UVFSPROC_CREATE, uvfs_createargs, uvfs_diropres) \
  macro (UVFSPROC_MKDIR, uvfs_mkdirargs, uvfs_diropres) \
  macro (UVFSPROC_SYMLINK, uvfs_symlinkargs, uvfs_diropres) \
  macro (UVFSPROC_MKNOD, void, void) \
  macro (UVFSPROC_REMOVE, uvfs_diropargs, uvfs_wccstat) \
  macro (UVFSPROC_RMDIR, uvfs_diropargs, uvfs_wccstat) \
  macro (UVFSPROC_RENAME, uvfs_renameargs, uvfs_renameres) \
  macro (UVFSPROC_LINK, uvfs_linkargs, uvfs_linkres) \
  macro (UVFSPROC_READDIR, uvfs_readdirargs, uvfs_readdirres) \
  macro (UVFSPROC_READDIRPLUS, void, void) \
  macro (UVFSPROC_STATFS, uvfs_fh, uvfs_statfsres) \
  macro (UVFSPROC_FSINFO, void, void) \
  macro (UVFSPROC_PATHCONF, void, void) \
  macro (UVFSPROC_COMMIT, uvfs_commitargs, uvfs_commitres) \
  macro (UVFSPROC_OPEN, uvfs_fh, uvfsstat) \
  macro (UVFSPROC_CLOSE, uvfs_fh, uvfsstat) \
  macro (UVFSPROC_INACTIVE, uvfs_fh, uvfsstat) \
  macro (UVFSPROC_RECLAIM, uvfs_fh, uvfsstat)
#define UVFSPROG_1_APPLY(macro) \
  UVFSPROG_1_APPLY_NOVOID(macro, void)



struct uvfs_invalidateargs {
  uvfs_fh handle;
  ex_post_op_attr attributes;
};
void *uvfs_invalidateargs_alloc ();
bool_t xdr_uvfs_invalidateargs (XDR *, void *);
RPC_STRUCT_DECL (uvfs_invalidateargs)

template<class T> bool
rpc_traverse (T &t, uvfs_invalidateargs &obj)
{
  return rpc_traverse (t, obj.handle)
    && rpc_traverse (t, obj.attributes);
}


#ifndef UVFSCBPROG
#define UVFSCBPROG 536870914
#endif /* !UVFSCBPROG */
extern const rpc_program uvfscbprog_1;
enum { UVFSCBVER = 1 };
enum {
  UVFSCBPROC_NULL = 0,
  UVFSCBPROC_INVALIDATE = 1,
};
#define UVFSCBPROG_1_APPLY_NOVOID(macro, void) \
  macro (UVFSCBPROC_NULL, void, void) \
  macro (UVFSCBPROC_INVALIDATE, uvfs_invalidateargs, void)
#define UVFSCBPROG_1_APPLY(macro) \
  UVFSCBPROG_1_APPLY_NOVOID(macro, void)

#endif /* !__RPCC_UVFS_PROT_H_INCLUDED__ */
