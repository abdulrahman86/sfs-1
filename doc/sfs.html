<html lang="en">
<head>
<title>SFS 0.8pre Manual</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="SFS 0.8pre Manual">
<meta name="generator" content="makeinfo 4.7">
<link title="Top" rel="top" href="#Top">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc { font-variant:small-caps }
  span.roman { font-family: serif; font-weight: normal; } 
--></style>
</head>
<body>
<h1 class="settitle">SFS 0.8pre Manual</h1>
<div class="contents">
<h2>Table of Contents</h2>
<ul>
<li><a name="toc_Top" href="#Top">SFS</a>
<li><a name="toc_Overview" href="#Overview">1 Introduction</a>
<li><a name="toc_Installation" href="#Installation">2 Installation</a>
<ul>
<li><a href="#Requirements">2.1 Requirements</a>
<li><a href="#Building">2.2 Building SFS</a>
<li><a href="#Build-Problems">2.3 Problems building SFS</a>
</li></ul>
<li><a name="toc_Getting-Started" href="#Getting-Started">3 Getting Started</a>
<ul>
<li><a href="#Quick-client-setup">3.1 Quick client setup</a>
<li><a href="#Quick-server-setup">3.2 Quick server setup</a>
<li><a href="#Quick-user-setup">3.3 Getting started as an SFS user</a>
</li></ul>
<li><a name="toc_Administering-SFS" href="#Administering-SFS">4 Administering SFS</a>
<ul>
<li><a href="#System-overview">4.1 System overview</a>
<li><a href="#Managing-user-keys">4.2 Managing user keys</a>
<li><a href="#Administrative-realms">4.3 Administrative realms</a>
<li><a href="#Sharing-_003cspan-class_003d_0022file_0022_003esfs_005fusers_003c_002fspan_003e-files">4.4 Sharing <span class="file">sfs_users</span> files</a>
</li></ul>
<li><a name="toc_SFS-configuration" href="#SFS-configuration">5 SFS configuration files</a>
<ul>
<li><a href="#sfs_005fconfig">5.1 <span class="file">sfs_config</span>&mdash;system-wide configuration parameters</a>
<li><a href="#sfsrwsd_005fconfig">5.2 <span class="file">sfsrwsd_config</span>&mdash;File server configuration</a>
<li><a href="#sfsauthd_005fconfig">5.3 <span class="file">sfsauthd_config</span>&mdash;User-authentication daemon configuration</a>
<li><a href="#sfs_005fhosts">5.4 <span class="file">sfs_hosts</span>&mdash;Host to address mapping overriding DNS</a>
<li><a href="#sfs_005fusers">5.5 <span class="file">sfs_users</span>&mdash;User-authentication database</a>
<li><a href="#sfssd_005fconfig">5.6 <span class="file">sfssd_config</span>&mdash;Meta-server configuration</a>
<li><a href="#sfs_005fsrp_005fparams">5.7 <span class="file">sfs_srp_params</span>&mdash;Default parameters for SRP protocol</a>
<li><a href="#sfscd_005fconfig">5.8 <span class="file">sfscd_config</span>&mdash;Meta-client configuration</a>
</li></ul>
<li><a name="toc_Command-reference" href="#Command-reference">6 Command reference guide</a>
<ul>
<li><a href="#sfsagent">6.1 <span class="command">sfsagent</span> reference guide</a>
<li><a href="#sfskey">6.2 <span class="command">sfskey</span> reference guide</a>
<li><a href="#rex">6.3 <span class="command">rex</span> reference guide</a>
<li><a href="#dirsearch">6.4 <span class="command">dirsearch</span> command</a>
<li><a href="#newaid">6.5 <span class="command">newaid</span> command</a>
<li><a href="#ssu">6.6 <span class="command">ssu</span> command</a>
<li><a href="#sfscd">6.7 <span class="command">sfscd</span> command</a>
<li><a href="#sfssd">6.8 <span class="command">sfssd</span> command</a>
<li><a href="#vidb">6.9 <span class="command">vidb</span> command</a>
<li><a href="#funmount">6.10 <span class="command">funmount</span> command</a>
<li><a href="#sfsrwsd">6.11 <span class="command">sfsrwsd</span> daemon</a>
<li><a href="#sfsrosd">6.12 <span class="command">sfsrosd</span> daemon</a>
<li><a href="#sfsauthd">6.13 <span class="command">sfsauthd</span> daemon</a>
<li><a href="#sfsrwcd">6.14 <span class="command">sfsrwcd</span> daemon</a>
<li><a href="#nfsmounter">6.15 <span class="command">nfsmounter</span> daemon</a>
</li></ul>
<li><a name="toc_Environment-variables" href="#Environment-variables">7 Environment variables</a>
<li><a name="toc_Security" href="#Security">8 Security considerations</a>
<ul>
<li><a href="#new-vulnerabilities">8.1 Vulnerabilities created by SFS</a>
<li><a href="#exposed-vulnerabilities">8.2 Vulnerabilities exploitable because of SFS</a>
<li><a href="#implementation-vulnerabilities">8.3 Vulnerabilities in the SFS implementation</a>
</li></ul>
<li><a name="toc_Contacts" href="#Contacts">9 How to contact people involved with SFS</a>
<li><a name="toc_Concept-Index" href="#Concept-Index">Concept Index</a>
</li></ul>
</div>



<p><a name="Top"></a>

<!-- node-name,     next,           previous, up -->
<h2 class="unnumbered">SFS</h2>

<p><a name="Overview"></a>

<!-- node-name,  next,  previous,  up -->
<h2 class="chapter">1 Introduction</h2>

<p>SFS is a network file system that lets you access your files from
anywhere and share them with anyone anywhere.  SFS was designed with
three goals in mind:

     <ul>
<li><strong>Security.</strong>  SFS assumes that malicious parties entirely control
the network.  It ensures that control of the network only lets them
delay the file system's operation or conceal the existence of servers
until reliable network communication is reestablished.

     <li><strong>A global namespace.</strong>  SFS mounts all remote file systems under
the directory <span class="file">/sfs</span>.  The contents of that directory is identical
on every client in the world.  Clients have no notion of administrative
realm and no site-specific configuration options.  Servers grant access
to users, not to clients.  Thus, users can access their files wherever
they go, from any machine they trust that runs the SFS client software.

     <li><strong>Decentralized control.</strong>  SFS does not rely on any privileged
authority to manage the global namespace.  Anyone with a machine on the
Internet can set up an SFS file server without needing to obtain any
kind of certificates.  New servers are instantly accessible from all
clients in the world. 
</ul>

   <p><a name="index-_0040var_007bHostID_007d-1"></a>SFS achieves these goals by separating key management from file system
security.  It names file systems by the equivalent of their public keys. 
Every remote file server is mounted under a directory of the form:

<pre class="display">     <tt>/sfs/</tt><tt>@</tt><var>Location</var><tt>,</tt><var>HostID</var>
</pre>
   <p>or:

<pre class="display">     <tt>/sfs/</tt><tt>@</tt><var>Location</var><tt>%</tt><var>port</var><tt>,</tt><var>HostID</var>
</pre>
   <p><a name="index-Self_002dcertifying-pathname-2"></a><var>Location</var> is a DNS hostname or an IP address.  <var>HostID</var> is a
collision-resistant cryptographic hash of the file server's public
key.  <var>port</var> is an optional TCP port number (the default is 4). 
This naming scheme lets an SFS client authenticate a server given only
a file name, freeing the client from any reliance on external key
management mechanisms.  SFS calls the directories on which it mounts
file servers <dfn>self-certifying pathnames</dfn>.

   <p>Self-certifying pathnames let users authenticate servers through a
number of different techniques.  As a secure, global file system, SFS
itself provides a convenient key management infrastructure.  Symbolic
links let the file namespace double as a key certification namespace. 
Thus, users can realize many key management schemes using only standard
file utilities.  Moreover, self-certifying pathnames let people
bootstrap one key management mechanism using another, making SFS far
more versatile than any file system with built-in key management.

   <p>Through a modular implementation, SFS also pushes user authentication
out of the file system.  Untrusted user processes transparently
authenticate users to remote file servers as needed, using protocols
opaque to the file system itself.

   <p>Finally, SFS separates key revocation from key distribution.  Thus, the
flexibility SFS provides in key management in no way hinders recovery
from compromised keys.

   <p><a name="index-Caffeine-3"></a>No caffeine was used in the original production of the SFS software.

<p><a name="Installation"></a>

<!-- node-name,  next,  previous,  up -->
<h2 class="chapter">2 Installation</h2>

<p>This section describes how to build and install the SFS on your system. 
If you are too impatient to read the details, be aware of the two most
important points:

     <ul>
<li>You must create an <span class="samp">sfs</span> user and an <span class="samp">sfs</span> group on your
system.  See <a href="#_002d_002dwith_002dsfsuser">&ndash;with-sfsuser</a>, to use a name other than <span class="samp">sfs</span>.

     <li>You must use gcc version 2.95.2 or later to compile SFS. 
</ul>

<p><a name="Requirements"></a>

<!-- node-name,  next,  previous,  up -->
<h3 class="section">2.1 Requirements</h3>

<p>SFS should run with minimal porting on any system that has solid NFS3
support.  We have run SFS successfully on OpenBSD, FreeBSD, Linux,
OSF/1 4.0, and Solaris 5.7.

   <p>In order to compile SFS, you will need the following:

     <ol type=1 start=1>
<li>gcc-2.95.2 or more recent.  You can obtain this from
<a href="ftp://ftp.gnu.org/pub/gnu/gcc">ftp://ftp.gnu.org/pub/gnu/gcc</a>. 
Don't waste your time trying to compile SFS with an earlier version of
gcc.

     <li>gmp-2.0.2 or more recent.  You can obtain this from
<a href="ftp://ftp.gnu.org/pub/gnu/gmp">ftp://ftp.gnu.org/pub/gnu/gmp</a>.  Many
operating systems already ship with gmp.  Note, however, that some Linux
distributions do not include the <span class="file">gmp.h</span> header file.  Even if you
have libgmp.so, if you don't have /usr/include/gmp.h, you need to
install gmp on your system.  Note that more recent versions (4.0 and above)
allow SFS to run significantly faster than it did with previous ones.

     <li>Header files in <span class="file">/usr/include</span> that match the kernel you are
running.  Particularly on Linux where the kernel and user-land utilities
are separately maintained, it is easy to patch the kernel without
installing the correspondingly patched system header files in
<span class="file">/usr/include</span>.  SFS needs to see the patched header files to
compile properly.

     <li>128 MB of RAM.  The C++ compiler really needs a lot of memory.

     <li>550 MB of free disk space to build SFS.  (Note that on ELF targets, you
may be able to get away with considerably less.  A build tree on FreeBSD
only consumes about 200 MB.)
        </ol>

<p><a name="Building"></a>

<!-- node-name,  next,  previous,  up -->
<h3 class="section">2.2 Building SFS</h3>

<p>Once you have setup your system as described in <a href="#Requirements">Requirements</a>, you
are ready to build SFS.

     <ol type=1 start=1>
<li>Create a user, <var>sfs-user</var>, and group, <var>sfs-group</var>, for SFS on
your system.  By default, SFS expects the both <var>sfs-user</var> and
<var>sfs-group</var> to be called <span class="samp">sfs</span>.  For instance, you might add
the following line to <span class="file">/etc/passwd</span>:

     <pre class="example">          sfs:*:71:71:Self-certifying file system:/:/bin/true
     </pre>
     <p>And the following line to <span class="file">/etc/group</span>:

     <pre class="example">          sfs:*:71:
     </pre>
     <p>Do not put any users in <var>sfs-group</var>, not even <code>root</code>.  Any
user in <var>sfs-group</var> will not be able to make regular use of the
SFS file system.  Moreover, having any unprivileged users in
<var>sfs-group</var> causes a security hole.

     <li>Unpack the SFS sources.  For instance, run the commands:

     <pre class="example">          % gzip -dc sfs-0.8pre.tar.gz | tar xvf -
          % cd sfs-0.8pre
     </pre>
     <p>If you determined that you need gmp (see <a href="#Requirements">Requirements</a>), you should
unpack gmp into the top-level of the SFS source tree:

     <pre class="example">          % gzip -dc ../gmp-2.0.2.tar.gz | tar xvf -
     </pre>
     <li>Set your <span class="env">CC</span> and <span class="env">CXX</span> environment variables to point to the C
and C++ compilers you wish to use to compile SFS. Some operating systems do
not come with a recent enough version of gcc <a href="#Requirements">Requirements</a>.

     <p><a name="configure"></a>
<a name="index-_0040command_007bconfigure_007d-4"></a><li>Configure the sources for your system with the command
<span class="command">./configure</span>.  You may additionally specify the following
options:

          <dl>
<a name="_002d_002dwith_002dsfsuser"></a>
<dt><span class="option">--with-sfsuser=</span><var>sfs-user</var><dd>If the user you created for SFS is not called <span class="samp">sfs</span>.  Do not use an
existing account for <var>sfs-user</var>&mdash;even a trusted account&mdash;as
processes running with that user ID will not be able to access SFS. 
[Note:  If you later change your mind about <var>user-name</var>, you do not
need to recompile SFS, <a href="#sfs_005fconfig">sfs_config</a>.]

          <br><dt><span class="option">--with-sfsgroup=</span><var>sfs-group</var><dd><a name="_002d_002dwith_002dsfsgroup"></a>
If the user you created for SFS does not have the same name as
<var>sfs-user</var>.  [Note:  If you later change your mind about
<var>sfs-group</var>, you do not need to recompile SFS.]

          <br><dt><span class="option">--with-gmp=</span><var>gmp-path</var><dd>To specify where <span class="command">configure</span> should look for gmp (for example,
<var>gmp-path</var> might be <span class="file">/usr/local</span>).  Note, if you unpacked gmp
into a subdirectory of the SFS source code, you do not need to specify
this option.  <span class="command">configure</span> should notice the directory and
compile gmp automatically.

          <br><dt><span class="option">--with-sfsdir=</span><var>sfsdir</var><dd>To specify a location for SFS to put its working files.  The default is
<span class="file">/var/sfs</span>.  [You can change this later, <a href="#sfs_005fconfig">sfs_config</a>.]

          <br><dt><span class="option">--with-etcdir=</span><var>etcdir</var><dd>To specify where SFS should search for host-specific configuration
files.  The default is <span class="file">/etc/sfs</span>.

          <br><dt><span class="option">--datadir=</span><var>datadir</var><dd>Where SFS places its data files.  The default is
<span class="file">/usr/local/share</span>. 
</dl>

     <p><span class="command">configure</span> accepts all the traditional GNU configuration
options such as <span class="option">--prefix</span>.  It also has several options that
are only for developers.  <strong>Do not use the
</strong><span class="option">--enable-repo</span><strong> or </strong><span class="option">--enable-shlib</span><strong> options</strong> (unless you
are a gcc maintainer looking for some wicked test cases for your
compiler).  Also, <strong>Do not use the </strong><span class="option">--with-openssl</span><strong>
option</strong>&ndash;it is only for use by the developers in compiling some
benchmark code that is not part of the release.

     <li>Build the sources by running <span class="samp">make</span>.

     <li>Install the binaries by running <span class="samp">make install</span>.  If you are short
on disk space, you can alternatively install stripped binaries by
running <span class="samp">make install-strip</span>.

     <li>That's it.  Fire up the client daemon by running <span class="command">sfscd</span>.
        </ol>

<p><a name="Build-Problems"></a>

<!-- node-name,  next,  previous,  up -->
<h3 class="section">2.3 Problems building SFS</h3>

<p><a name="index-Internal-compiler-error-5"></a>The most common problem you will encounter is an internal compiler error
from gcc.  If you are not running gcc-2.95.2 or later, you will very
likely experience internal compiler errors when building SFS and need to
upgrade the compiler.  You must <code>make clean</code> after upgrading the
compiler.  You cannot link object files together if they have been
created by different versions of the C++ compiler.

   <p>On OSF/1 for the alpha, certain functions using a gcc extension called
<code>__attribute__((noreturn))</code> tend to cause internal compiler errors. 
If you experience internal compiler errors when compiling SFS for the
alpha, try building with the command <code>make
ECXXFLAGS='-D__attribute__\(x\)='</code> instead of simply <code>make</code>.

   <p>Sometimes, a particular source file will give particularly stubborn
internal compiler errors on some architectures.  These can be very hard
to work around by just modifying the SFS source code.  If you get an
internal compiler error you cannot obviously fix, try compiling the
particular source file with a different level of debugging.  (For
example, using a command like <code>make sfsagent.o CXXDEBUG=-g</code> in the
appropriate subdirectory.)

   <p><a name="index-Disk-Full-6"></a>If your <span class="file">/tmp</span> file system is too small, you may also end up
running out of temporary disk space while compiling SFS.  Set your
<span class="env">TMPDIR</span> environment variable to point to a directory on a file
system with more free space (e.g., <span class="file">/var/tmp</span>).

   <p><a name="index-Virtual-memory-exhausted-7"></a>You may need to increase your heap size for the compiler to work.  If
you use a csh-derived shell, run the command <code>unlimit datasize</code>. 
If you use a Bourne-like shell, run <code>ulimit -d `ulimit -H -d`</code>.

   <p><a name="index-_0040code_007b_005f_005f_005fgmp_005fdefault_005fallocate_007d-8"></a>On some operating systems, some versions of GMP do not install the
library properly.  If you get linker errors about symbols with names
like <code>___gmp_default_allocate</code>, try running the command
<code>ranlib /usr/local/lib/libgmp.a</code>
(substituting wherever your GMP library is installed for
<code>/usr/local</code>).

<p><a name="Getting-Started"></a>

<!-- node-name,  next,  previous,  up -->
<h2 class="chapter">3 Getting Started</h2>

<p>This chapter gives a brief overview of how to set up an SFS client and
server once you have compiled and installed the software.

<p><a name="Quick-client-setup"></a>

<!-- node-name,  next,  previous,  up -->
<h3 class="section">3.1 Quick client setup</h3>

<p>SFS clients require no configuration.  Simply run the program
<span class="command">sfscd</span>, and a directory <span class="file">/sfs</span> should appear on your
system.  To test your client, access our SFS test server.  Type the
following commands:

<pre class="example">     % cd /sfs/@sfs.fs.net,uzwadtctbjb3dg596waiyru8cx5kb4an
     % cat CONGRATULATIONS
     You have set up a working SFS client.
     %
</pre>
   <p class="noindent">Note that the <span class="file">/sfs/@sfs.fs.net,...</span> directory does not need to
exist before you run the <span class="command">cd</span> command.  SFS transparently mounts
new servers as you access them.

<p><a name="Quick-server-setup"></a>

<!-- node-name,  next,  previous,  up -->
<h3 class="section">3.2 Quick server setup</h3>

<p>Setting up an SFS server is a slightly more complicated process.  You
must perform at least three steps:

     <ol type=1 start=1>
<li>Create a public/private key pair for your server.

     <li>Create an <span class="file">/etc/sfs/sfsrwsd_config</span> configuration file.

     <li>Configure your machine as an NFS server and export all necessary
directories to <span class="samp">localhost</span>.
        </ol>

   <p>Before you begin, be sure that SFS can figure out your host's
fully-qualified domain name, and that the domain name exists in the
domain name system (DNS)&mdash;as opposed to just being some fake host
name listed in <span class="file">/etc/hosts</span>.  SFS will use your host's
system name (returned by the <span class="command">hostname</span> command), and if that
is not fully-qualified, will append whatever default domain is
specified in <span class="file">/etc/resolv.conf</span>.  If this does not result
in a valid DNS domain name, you can either reconfigure your system
such that <span class="command">hostname</span> returns a fully-qualified and valid DNS
domain name (recommended), or set the environment variable
<span class="env">SFS_HOSTNAME</span> to the fully-qualified DNS name SFS should use
see <a href="#SFS_005fHOSTNAME">SFS_HOSTNAME</a>.  If you don't have a DNS name pointing to your
IP address, set <span class="env">SFS_HOSTNAME</span> to be the host's IP address.

   <p>Now, to create a public/private key pair for your server, run the
commands:
<pre class="example">     mkdir /etc/sfs
     sfskey gen -P /etc/sfs/sfs_host_key
</pre>
   <p>Then you must create an <span class="file">/etc/sfs/sfsrwsd_config</span> file based on
which local directories you wish to export and what names those
directories should have on clients.  This information takes the form of
one or more <span class="command">Export</span> directives in the configuration file.  Each
export directive is a line of the form:

<pre class="example">     Export <var>local-directory</var> <var>sfs-name</var>
</pre>
   <p><var>local-directory</var> is the name of a local directory on your system
you wish to export.  <var>sfs-name</var> is the name you wish that directory
to have in SFS, relative to the previous <span class="command">Export</span> directives. 
The <var>sfs-name</var> of the first <span class="command">Export</span> directive must be
<span class="file">/</span>.  Subsequent <var>sfs-name</var>s must correspond to pathnames that
already exist in the previously exported directories.

   <p>Suppose, for instance, that you wish to export two directories,
<span class="file">/disk/u1</span> and <span class="file">/disk/u2</span> as <span class="file">/usr1</span> and <span class="file">/usr2</span>,
respectively.  You should create a directory to be the root of the
exported namespace, say <span class="file">/var/sfs/root</span>, create the
necessary <var>sfs-name</var> subdirectories, and create a corresponding
<span class="file">sfsrwsd_config</span> file.  You might run the following commands to
do this:

<pre class="example">     % mkdir /var/sfs/root
     % mkdir /var/sfs/root/usr1
     % mkdir /var/sfs/root/usr2
</pre>
   <p class="noindent">and create the following <span class="file">sfsrwsd_config</span> file:

<pre class="example">     Export /var/sfs/root /
     Export /disk/u1 /usr1
     Export /disk/u2 /usr2
</pre>
   <p><a name="index-_0040file_007b_002fetc_002fexports_007d-9"></a>Finally, you must export all the <var>local-directory</var>s in your
<span class="file">sfsrwsd_config</span> to <span class="samp">localhost</span> via NFS version 3.  The
details of doing this depend heavily on your operating system.  For
instance, in OpenBSD you must add the following lines to the file
<span class="file">/etc/exports</span> and run the command <span class="samp">kill -HUP `cat
/var/run/mountd.pid`</span>:

<pre class="example">     /var/sfs/root localhost
     /disk/u1 localhost
     /disk/u2 localhost
</pre>
   <p>On Linux, the syntax for the exports file is:

<pre class="example">     /var/sfs/root localhost(rw)
     /disk/u1 localhost(rw)
     /disk/u2 localhost(rw)
</pre>
   <p>On Solaris, add the following lines to the file <span class="file">/etc/dfs/dfstab</span>
and run <span class="samp">exportfs -a</span>:

<pre class="example">     share -F nfs -o -rw=localhost /var/sfs/root
     share -F nfs -o -rw=localhost /disk/u1
     share -F nfs -o -rw=localhost /disk/u2
</pre>
   <p>In general, the procedure for exporting NFS file systems varies
greatly between operating systems.  Check your operating system's NFS
documentation for details.  (The manual page for <span class="command">mountd</span> is a
good place to start.)  You can test to see if your NFS server is
configured as expected (independently or running SFS) by running
<span class="command">showmount</span> with the <span class="option">-e</span> option.  With the example
configuration, you should see something like this:

<pre class="example">     % shouwmount -e
     /var/sfs/root           localhost.your.domain
     /disk/u1                localhost.your.domain
     /disk/u2                localhost.your.domain
</pre>
   <p>Once you have generated a host key, created an <span class="file">sfsrwsd_config</span>
file, and reconfigured your NFS server, you can start the SFS server by
running <span class="command">sfssd</span>.  Note that a lot can go wrong in setting up an
SFS server.  Thus, we recommend that you first run <span class="samp">sfssd -d</span>.  The
<span class="option">-d</span> switch will leave <span class="command">sfssd</span> in the foreground and send
error messages to your terminal.  If there are problems, you can then
easily kill <span class="command">sfssd</span> from your terminal, fix the problems, and
start again.  Once things are working, omit the <span class="option">-d</span> flag;
<span class="command">sfssd</span> will run in the background and send its output to the
system log.

   <p>Note: <strong>You will not be able to access an SFS server running on
the same machine as the client</strong> unless you run <span class="command">sfscd</span> with
the <span class="option">-l</span> flag, <a href="#sfscd">sfscd</a>.  Attempts to SFS mount a machine on
itself will return the error <code>EDEADLK</code> (Resource deadlock
avoided).

<p><a name="Quick-user-setup"></a>

<!-- node-name,  next,  previous,  up -->
<h3 class="section">3.3 Getting started as an SFS user</h3>

<p>To access an SFS server, you must first register a public key with the
server, then run the program <span class="command">sfsagent</span> on your SFS client to
authenticate you.

   <p>To register a public key, log into the file server and run the command:

<pre class="example">     sfskey register
</pre>
   <p>This should produce something similar to the following output:

<pre class="example">     % sfskey register
     sfskey: /home/user/.sfs/random_seed: No such file or directory
     sfskey: creating directory /home/user/.sfs
     sfskey: creating directory /home/user/.sfs/authkeys
     Creating new key: user@server.com#1 (Rabin)
            Key Label: user@server.com#1
</pre>
   <p>Press &lt;RET&gt; to accept the default key label.  You will then see:

<pre class="example">     Enter passphrase:
                Again:
     
     sfskey needs secret bits with which to seed the random number generator.
     Please type some random or unguessable text until you hear a beep:
       64
</pre>
   <p>At this point, type 64 random characters to seed the random number
generator, until you hear a bell.  You will then be prompted for your
UNIX password.  If all goes well you should see a message line:

<pre class="example">       UNIX password:
     wrote key: /home/user/.sfs/authkeys/user@server.com#1
     %
</pre>
   <p class="noindent">The above procedure creates a public/private key pair for you and
registers it with the server.  (Note that if you already have a public
key on another server, you can reuse that public key by giving
<span class="command">sfskey</span> your address at that server, e.g., <span class="samp">sfskey
register user@other.server.com</span>.)

   <p>After registering your public key with an SFS server, you can use the
<span class="samp">sfskey login</span> command to access the server.  Get a shell on a
different client machine from the server, and run the command:

<pre class="example">     sfskey login <var>usr</var>@<var>server</var>
</pre>
   <!-- @command{sfsagent} program on an SFS client to access the server.  On -->
<!-- the client, run the command: -->
<!-- @example -->
<!-- sfsagent @var{user}@@@var{server} -->
<!-- @end example -->
<p class="noindent"><var>server</var> is the name of the server on which you registered, and
<var>user</var> is your logname on that server.  You should be prompted for
a password, and see something like the following:

<pre class="example">     Passphrase for dm@server.com/1024:
     SFS Login as dm@server.com
</pre>
   <p class="noindent">The <span class="samp">sfskey login</span> command does three things:  It starts the
<span class="command">sfsagent</span> program, which persists in the background to
authenticate you to file servers as needed.  It fetches your private
key from <var>server</var> and decrypts it using your passphrase.  Finally,
it fetches the server's public key, and creates a symbolic link from
<span class="file">/sfs/</span><var>server</var> to <span class="file">/sfs/@</span><var>server</var><span class="file">,</span><var>HostID</var>. 
(The passphrase you type is also used to authenticate the server to
the client, so that <span class="command">sfskey</span> can fetch the server's public key
securely.)

   <p>If, after your agent is already running, you wish to fetch a private
key from another server or download another server's public key, you
can run <span class="samp">sfskey login</span> multiple times.  You will be able to
access all the servers you have logged into simultaneously.

<!-- However, in general you need not explicitly log in to every server you -->
<!-- wish to access.  If you register the same public key on every server, -->
<!-- you can access all servers after logging into any one of them-so -->
<!-- long as you have some secure way of retrieving the self-certifying -->
<!-- pathname of the server. -->
<p>While <span class="command">sfskey</span> provides a convenient way of authenticating
oneself to servers and obtaining their self-certifying pathnames, it
is by no means the only way.  If you use the same public key on all
servers, you will only need to type your password once to download
your private key; <span class="command">sfsagent</span> will automatically authenticate
you to whatever file servers you touch.  Moreover, once you have
access to one SFS file server, you can use it to store symbolic links
to other servers' self-certifying pathnames.

   <p>When you are done using SFS, you should run the command

<pre class="example">     sfskey kill
</pre>
   <p class="noindent">before logging out.  This will kill your <span class="command">sfsagent</span> process
running in the background and get rid of the private keys it was holding
for you in memory.

<p><a name="Administering-SFS"></a>

<!-- node-name,  next,  previous,  up -->
<h2 class="chapter">4 Administering SFS</h2>

<p><a name="System-overview"></a>

<!-- node-name,  next,  previous,  up -->
<h3 class="section">4.1 System overview</h3>

<pre class="example">        sfskey--+---------------- - - - -----------+
                |                                  |
              agent--+                             |
          agent------+                             |
                     |                             |
        +---------------+                       +-------------+
        |         sfscd |-------- - - - --------| sfssd       |
        |            |  |                       |  |          |
        |    sfsrwcd-+  |                       |  +-sfsrwsd--+-+
        |    sfsrocd-+  |                       |  +-sfsrosd  | |
        | nfsmounter-+  |                       |  +-sfsauthd | |
        +---------------+                       +-------------+ |
                     |                                          V
     +--------+      |                                   +--------+
     | kernel |      |                                   | kernel |
     |  NFS3  |&lt;-----+                                   |  NFS3  |
     | client |                                          | server |
     +--------+                                          +--------+
     
               CLIENT                               SERVER
</pre>
<p>SFS consists of a number interacting programs on both the client and the
server side.

   <p>On the client side, SFS implements a file system by pretending to be an
NFS server and talking to the local operating system's NFS3 client.  The
program <span class="command">sfscd</span> gets run by root (typically at boot time). 
<span class="command">sfscd</span> spawns two other daemons&mdash;<span class="command">nfsmounter</span> and
<span class="command">sfsrwcd</span>.

   <p><a name="index-_0040command_007bnfsmounter_007d-10"></a><span class="command">nfsmounter</span> handles the mounting and unmounting of NFS file
systems.  In the event that <span class="command">sfscd</span> dies, <span class="command">nfsmounter</span>
takes over being the NFS server to prevent file system operations from
blocking as it tries to unmount all file systems.  <strong>Never send
</strong><span class="command">nfsmounter</span><strong> a </strong><code>SIGKILL</code><strong> signal (i.e., </strong><span class="samp">kill -9</span><strong>).</strong>
<span class="command">nfsmounter</span>'s main purpose is to clean up the mess if any
other part of the SFS client software fails.  Whatever bad situation
SFS has gotten your machine into, killing <span class="command">nfsmounter</span> will
likely only make matters worse.

   <p><span class="command">sfsrwcd</span> implements the ordinary read-write file system
protocol.  As other dialects of the SFS protocol become available, they
will be implemented as daemons running alongside <span class="command">sfsrwcd</span>.

   <p><span class="command">sfsrocd</span> implements the client-side of the read-only dialect of
SFS.  This program synthesizes a file system by reading blocks
from an <span class="command">sfsrosd</span> replica.

   <p>Each user of an SFS client machine must run an instance of the
<span class="command">sfsagent</span> command.  <span class="command">sfsagent</span> serves several purposes. 
It handles user authentication as the user touches new file systems.  It
can fetch <var>HostID</var>s on the fly, a mechanism called <dfn>Dynamic
server authentication</dfn>.  Finally, it can perform revocation checks on
the <var>HostID</var>s of servers the user accesses, to ensure the user does
not access <var>HostID</var>s corresponding to compromised private keys.

   <p>The <span class="command">sfskey</span> utility manages both user and server keys.  It lets
users control and configure their agents.  Users can hand new private
keys to their agents using <span class="command">sfskey</span>, list keys the agent holds,
and delete keys.  <span class="command">sfskey</span> will fetch keys from remote servers
using SRP, <a href="#SRP">SRP</a>.  It lets users change their public keys on remote
servers.  Finally, <span class="command">sfskey</span> can configure the agent for dynamic
server authentication and revocation checking.

   <p>On the server side, the program <span class="command">sfssd</span> spawns two subsidiary
daemons, <span class="command">sfsrwsd</span> and <span class="command">sfsauthd</span>.  If virtual hosts or
multiple versions of the software are running, <span class="command">sfssd</span> may spawn
multiple instances of each daemon.  <span class="command">sfssd</span> listens for TCP
connections on port 4.  It then hands each connection off to one of the
subsidiary daemons, depending on the self-certifying pathname and
service requested by the client.

   <p><span class="command">sfsrwsd</span> is the server-side counterpart to <span class="command">sfsrwcd</span>. 
It communicates with client side <span class="command">sfsrwcd</span> processes using the
SFS file system protocol, and accesses the local disk by acting as a
client of the local operating system's NFS server.  <span class="command">sfsrwsd</span> is
the one program in sfs that <em>must be configured</em> before you run it,
<a href="#sfsrwsd_005fconfig">sfsrwsd_config</a>.

   <p><span class="command">sfsrosd</span> is the server-side counterpart to <span class="command">sfsrocd</span>. 
A <span class="command">sfsrosd</span> replica presents a simple interface for reading
blocks of data.  This program requires <a href="#sfsrosd_005fconfig">sfsrosd_config</a> to select
a set of read-only databases to serve.

   <p><span class="command">sfsauthd</span> handles user authentication.  It communicates
directly with <span class="command">sfsrwsd</span> to authenticate users of the file system. 
It also accepts connections over the network from <span class="command">sfskey</span> to
let users download their private keys or change their public keys.

<p><a name="Managing-user-keys"></a>

<!-- node-name,  next,  previous,  up -->
<h3 class="section">4.2 Managing user keys</h3>

<p><a name="Administrative-realms"></a>

<!-- node-name,  next,  previous,  up -->
<h3 class="section">4.3 Administrative realms</h3>

<p><a name="index-realms-11"></a>
It is inconvenient for users to run <span class="samp">sfskey login</span> once for every
server they wish to access.  Though users can register the same public
key on multiple servers, they still cannot access a server without its
self-certifying pathname.

   <p>SFS's <em>realm</em> mechanism allows one trusted server to store and
serve the self-certifying pathnames of many other servers.  By
default, SFS servers are not configured to support administrative
realms.  When a user runs <span class="samp">sfskey login</span> to a server without a
realm, a symbolic link is created from
<span class="file">sfs/</span><var>server-name</var> to the server's self-certifying
pathname.  If, instead, the server is configured to be part of an
administrative realm, <span class="file">sfs/</span><var>server-name</var> will be a
directory, and references to names in that directory will
transparently create symbolic links to self-certifying pathnames.

   <p>To set up a realm server, you must first create a publicly-readable
directory of symbolic links to self-certifying pathnames of other
servers.  For example, suppose your <span class="file">sfsrwsd_config</span> file's root
directory is publicly readable with this configuration:

<pre class="example">     Export /var/sfs/root / R
</pre>
   <p>Create a directory <span class="file">/var/sfs/root/servers</span>. 
Now populate this directory with symbolic links to self-certifying
pathnames.  For example, a server for the realm of machines in DNS
zone <span class="samp">scs.cs.nyu.edu</span> might contain the following links:

<pre class="example">     pitt -&gt; /sfs/@pitt.scs.cs.nyu.edu,rexmmr795q6enmhsemr5xt5f6jjhjm6h
     fdr -&gt; /sfs/@fdr.scs.cs.nyu.edu,hki6vgn6gwkuknve7xqrv4a5mbv76uui
     ludlow -&gt; /sfs/@ludlow.scs.cs.nyu.edu,hcbafipmin3eqmsgak2m6heequppitiz
     orchard -&gt; /sfs/@orchard.scs.cs.nyu.edu,4ttg7gvinyxrfe2zgv8mefmjbb3z7iur
</pre>
   <p>These links should now also be available in the subdirectory
<span class="file">servers</span> of the server's self-certifying pathname.

   <p>Finally, to configure your server to support realms, you must add the
following two lines to <span class="file">/etc/sfs/sfsauthd_config</span>. 
(If that file does not exist, copy the default file
<span class="file">/usr/local/share/sfs/sfsauthd_config</span> to
<span class="file">/etc/sfs</span> to add the lines.)

<pre class="example">     realm <var>realm-name</var>
     certpath /servers
</pre>
   <p>The <var>realm-name</var> can be the name of your primary server, or it
might be your domain name instead (e.g., in the example you can chose
realm name <span class="samp">scs.cs.nyu.edu</span> to authenticate a bunch of servers
ending <span class="samp">.scs.cs.nyu.edu</span>).

   <p>After editing <span class="file">sfsauthd_config</span>, you must restart
<span class="command">sfsauthd</span> on the server.  The easiest way to do this is to
run the following command as root:

<pre class="example">     # kill -1 `cat /var/run/sfssd.pid`
</pre>
   <p>Note that if the new <var>realm-name</var> is not the same as the server
name (or if you ever change <var>realm-name</var>), then users who have
already registered will see a message like the following when they
next log in:

<pre class="example">     sfskey: Warning: host for dm@ludlow.scs.cs.nyu.edu is actually server
             @ludlow.scs.cs.nyu.edu,hcbafipmin3eqmsgak2m6heequppitiz
             This server is claiming to serve host (or realm) scs.cs.nyu.edu,
             but you originally registered on host (or in realm) ludlow.scs.cs.nyu.edu
     sfskey: fatal: Invalid connection to authserver.
</pre>
   <p>The reason for this error is that, unfortunately, users often chose
the same passwords in multiple administrative realms.  To prevent one
realm from impersonating another in the event that users have recycled
passwords, SFS cryptographically embeds the realm name in the SRP
password information stored at the server.

   <p>To correct the problem after changing <var>realm-name</var>, users need
only run the command:

<pre class="example">     % sfskey update -r [<var>user</var>]<var>server-name</var>
</pre>
   <p>This command will prompt users for their passwords and then ask them
to confirm the change of realm name.

   <p>Once your realm is configured and you have updated your account at the
server, you can log into the server with <span class="samp">sfskey login</span>.  You
should now see <span class="file">/sfs/</span><var>realm-name</var> as an empty
directory on your system.  However, if you access a file name like
<span class="file">/sfs/</span><var>realm-name</var><span class="file">/ludlow</span> and <span class="file">ludlow</span>
is a symbolic link in the <span class="file">servers</span> directory, then name
<span class="file">/sfs/</span><var>realm-name</var><span class="file">/ludlow</span> will automatically
spring into existence as the appropriate symbolic link.

   <p>Note that SFS could immediately populate the directory
<span class="file">/sfs/</span><var>realm-name</var> with symbolic links before users
even access the names.  However, many users alias the <span class="command">ls</span>
command to <span class="command">ls -F</span>, and many versions of Linux ship with an
<span class="command">ls</span> command that colorizes output by default.  These
<span class="command">ls</span> commands execute a <code>stat</code> system call for every file
in a directory, which would be quite expensive in a directory of links
to self-certifying pathnames, as each <code>stat</code> call would trigger a
file system mount (and unavailable servers would introduce serious
delays).

<p><a name="Sharing-_003cspan-class_003d_0022file_0022_003esfs_005fusers_003c_002fspan_003e-files"></a>

<!-- node-name,  next,  previous,  up -->
<h3 class="section">4.4 Sharing <span class="file">sfs_users</span> files</h3>

<p>One often wishes to set up multiple servers to be part of a single
administrative realm and recognize the same set of users.  In such
cases, users can access all servers in the realm by executing a single
<span class="samp">sfs login</span> command.  Moreover, users only need to change their
public keys and passwords on a single server for the changes to
propagate to the other ones.

   <p>Within an administrative realm, one can classify servers as either
trusted or untrusted.  A trusted server is a machine that all servers
trust to specify the identities of users and servers in the realm.  In
each realm, one of the trusted servers, designated the <em>primary</em>,
is the one on which users update their accounts.  Every administrative
realm must have a primary server.  An untrusted server recognizes all
users in the realm, but is not necessarily trusted by users or other
servers in the realm.

   <p>As a concrete example, consider a research group with two central file
servers, A and B, and a number of clients C1, C2, <small class="dots">...</small>, on users'
desks.  Everyone in the group may trust the administrators of servers
A and B, but individual users may have superuser privileges on their
own clients and not be trusted by the rest of the realm.  In
particular, the user of client C1 may wish to set up a file server
accessible to other users in the realm (and possibly also accessible
to some local maintained guest accounts on C1).  C1's owner must be
able to set up this server without it being trusted by the rest of the
realm.

   <p>To configure SFS servers as part of a realm, you must first understand
what information a server stores about users.  Each SFS server has one
or more <span class="file">sfs_users</span> databases of users on the system.  A database
may contain, among other things, the following information for each
user:

     <ul>
<li>The user's name.

     <li>The user's numeric user ID and login group ID.

     <li>The user's public key.

     <p><a name="index-SRP-12"></a><li>The user's &ldquo;SRP information.&rdquo;
<a href="http://srp.stanford.edu/">SRP</a> is the password
authentication protocol used by the <span class="samp">sfskey login</span> command.  The
SRP information stored by the server serves two purposes.  First, it
allows the server to verify that a user running <span class="samp">sfskey login</span>
knows the right password to access the account.  Second, and equally
important, it allows the server to prove its own identity to the
client executing <span class="samp">sfskey login</span>.  Thus, though not equivalent to
the user's password, the SRP information is a secret derived from the
password with which the server can prove its own identity.

     <li>An encrypted copy of the user's private key. 
</ul>

   <p>The first three pieces of information

<p><a name="SFS-configuration"></a>

<!-- node-name,  next,  previous,  up -->
<h2 class="chapter">5 SFS configuration files</h2>

<p>SFS consists of a number of programs, many of which have configuration
files.  All programs look for configuration files in two
directories&mdash;first <span class="file">/etc/sfs</span>, then, if they don't find the file
there, in <span class="file">/usr/local/share/sfs</span>.  You can change these locations
using the <span class="option">--with-etcdir</span> and <span class="option">--datadir</span> options to
the <span class="command">configure</span> command, <a href="#configure">configure</a>.

   <p>The SFS software distribution installs reasonable defaults in
<span class="file">/usr/local/share/sfs</span> for all necessary configuration files except
<span class="file">sfsrwsd_config</span>.  On particular hosts where you wish to change
the default behavior, you can override the default configuration file
by creating a new file of the same name in <span class="file">/etc/sfs</span>.

   <p>The <span class="file">sfs_config</span> file contains system-wide configuration
parameters for most of the programs comprising SFS.  Note that
<span class="file">/usr/local/share/sfs/sfs_config</span> is always parsed, even if
<span class="file">/etc/sfs/sfs_config</span> exists.  Options in
<span class="file">/etc/sfs/sfs_config</span> simply override the defaults
in <span class="file">/usr/local/share/sfs/sfs_config</span>.  For all other
configuration files, a file in <span class="file">/etc/sfs</span> entirely
overrides the version in <span class="file">/usr/local/share/sfs</span>.

   <p>If you are running a server, you will need to create an
<span class="file">sfsrwsd_config</span> file to tell SFS what directories to export, and
possibly an <span class="file">sfsauthd_config</span> if you wish to share the database of
user public keys across several file servers.

   <p>The <span class="file">sfssd_config</span> file contains information about which protocols
and services to route to which daemons on an SFS server, including
support for backwards compatibility across several versions of SFS.  You
probably don't need to change this file.

   <p>To run an SFS read-only server, you must create an <a href="#sfsrosd_005fconfig">sfsrosd_config</a>
file to tell SFS which read-only databsses to serve.

   <p><span class="file">sfs_srp_params</span> contains some cryptographic parameters for
retrieving keys securely over the network with a passphrase (as with the
<span class="samp">sfskey add </span><var>usr</var><span class="samp">@</span><var>server</var> command).

   <p><span class="file">sfscd_config</span> Contains information about extensions to the SFS
protocol and which kinds of file servers to route to which daemons.  You
almost certainly should not touch this file unless you are developing
new versions of the SFS software.

   <p>Note that configuration command names are case-insensitive in all
configuration files (though the arguments are not).

<p><a name="sfs_005fconfig"></a>

<!-- node-name,  next,  previous,  up -->
<h3 class="section">5.1 <span class="file">sfs_config</span>&mdash;system-wide configuration parameters</h3>

<p><a name="index-_0040file_007bsfs_005fconfig_007d-13"></a>
<!-- @mp -->
<!-- @mp @conffile{sfs_config}{system-wide configuration parameters} -->
<!-- @mp @description -->
The <span class="file">sfs_config</span> file lets you set the following system-wide
parameters:

     <dl>
<dt><span class="samp">sfsdir </span><var>directory</var><dd>The directory in which SFS stores its working files.  The default is
<span class="file">/var/sfs</span>, unless you changed this with the <span class="option">--with-sfsdir</span>
option to <span class="command">configure</span>.

     <br><dt><span class="samp">sfsuser </span><var>sfs-user</var><span class="samp"> [</span><var>sfs-group</var><span class="samp">]</span><dd>As described in <a href="#Building">Building</a>, SFS needs its own user and group to
run.  This configuration directive lets you set the user and group IDs
SFS should use. By default, <var>sfs-user</var> is <span class="samp">sfs</span> and
<var>sfs-group</var> is the same as <var>sfs-user</var>.  The <span class="samp">sfsuser</span>
directive lets you supply either a user and group name, or numeric IDs
to change the default.  Note:  <strong>If you change </strong><var>sfs-group</var><strong>,
you must make sure the the program
</strong><span class="file">/usr/local/lib/sfs-0.8pre/suidconnect</span><strong> is setgid to the new
</strong><var>sfs-group</var><strong>.</strong>

     <br><dt><span class="samp">anonuser {</span><var>user</var><span class="samp"> | </span><var>uid</var> <var>gid</var><span class="samp">}</span><dd><a name="anonuser"></a>
Specifies an unprivileged user id to be used for anonymous file access. 
If specified as <var>user</var>, the name <var>user</var> will be looked up in the
password file, and the login group of that user used as the group id. 
Can alternatively be specified as a numeric <var>uid</var> and <var>gid</var>. 
The default is to use -1 for both the <var>uid</var> and <var>gid</var>, though
the default <span class="file">sfs_config</span> file specifies the user name nobody.

     <br><dt><span class="samp">ResvGids </span><var>low-gid</var> <var>high-gid</var><dd><a name="resvgids"></a>
SFS lets users run multiple instances of the <span class="command">sfsagent</span> program. 
However, it needs to modify processes' group lists so as to know which
file system requests correspond to which agents.  The <span class="samp">ResvGids</span>
directive gives SFS a range of group IDs it can use to tag processes
corresponding to a particular agent.  (Typically, a range of 16 gids
should be plenty.)  Note that the range is inclusive&mdash;both
<var>low-gid</var> and <var>high-gid</var> are considered reserved gids.

     <p>The setuid root program <span class="command">newaid</span> lets users take on any of
these group IDs, <a href="#newaid">newaid</a>.  Thus, make sure these groups are not
used for anything else, or you will create a security hole.  There is
no default for <span class="samp">ResvGids</span>.

     <p>Note that after changing <span class="samp">ResvGids</span>, you must kill and restart
<span class="command">sfscd</span> for things to work properly.

     <br><dt><span class="samp">RSASize </span><var>bits</var><dd>Sets the default size of public keys for cryptosystems that are based
on the difficulty of factoring integers.  The Rabin public keys used in
self-certifying pathnames are affected by this parameter.  The default
value of <var>bits</var> is 1280.

     <br><dt><span class="samp">DlogSize </span><var>bits</var><dd>Sets the default size of public keys for cryptosystems that are based
on the difficulty of taking discrete logs in subgroups of
<strong>Z</strong><em>p</em>*.  This parameter affects SRP parameter and
2-Schnorr key generation.  The default value of <var>bits</var> is 1024.

     <br><dt><span class="samp">PwdCost </span><var>cost</var><dd><a name="pwdcost"></a>
Sets the computational cost of processing a user-chosen password.  SFS
uses passwords to encrypt users' private keys.  Unfortunately, users
tend to choose poor passwords.  As computers get faster, guessing
passwords gets easier.  By increasing the <var>cost</var> parameter, you
can maintain the cost of guessing passwords as hardware improves.  The
change will apply to new keys, and to old keys after people run
<span class="samp">sfskey edit</span>.

     <p>The default value is 12.  <var>cost</var> is an exponential parameter. 
Thus, you probably don't want anything too much larger.  The maximum
value is 32&mdash;at which point password hashing will not terminate in
any tractable amount of time and the <span class="command">sfskey</span> command will be
unusable.

     <br><dt><span class="samp">LogPriority </span><var>facility</var><span class="samp">.</span><var>level</var><dd>Sets the syslog facility and level at which SFS should log activity. 
The default is <span class="samp">daemon.notice</span>. 
</dl>
   <!-- @mp @end description -->
<!-- @mp @end conffile -->
<!-- @mp @end -->

<p><a name="sfsrwsd_005fconfig"></a>

<!-- node-name,  next,  previous,  up -->
<h3 class="section">5.2 <span class="file">sfsrwsd_config</span>&mdash;File server configuration</h3>

<p><a name="index-_0040file_007bsfsrwsd_005fconfig_007d-14"></a>
<!-- @mp -->
<!-- @mp @conffile{sfsrwsd_config}{file server configuration} -->
<!-- @mp @description -->
     <dl>
<dt><span class="samp">Hostname </span><var>name</var><dd>Set the <var>Location</var> part of the server's self-certifying pathname. 
The default is the current host's fully-qualified hostname.

     <br><dt><span class="samp">Keyfile </span><var>path</var><dd>Tells <span class="command">sfsrwsd</span> to look for its private key in file <var>path</var>. 
The default is <span class="file">sfs_host_key</span>.  SFS looks for file names that do
not start with <span class="file">/</span> in <span class="file">/etc/sfs</span>, or whatever directory you
specified if you used the <span class="option">--with-etcdir</span> option to
<span class="command">configure</span> (see <a href="#configure">configure</a>).

     <br><dt><span class="samp">Export </span><var>local-directory</var> <var>sfs-name</var><span class="samp"> [R|W]</span><dd><a name="export"></a>
Tells <span class="command">sfsrwsd</span> to export <var>local-directory</var>, giving it the
name <var>sfs-name</var> with respect to the server's self-certifying
pathname.  Appending <span class="samp">R</span> to an export directive gives anonymous
users read-only access to the file system under the anonymous user
group IDs specified in <span class="file">sfs_config</span>, <a href="#anonuser">anonuser</a>. 
Appending
<span class="samp">W</span> gives anonymous users both read and write access. 
<!-- @mp @ignore -->
See <a href="#Quick-server-setup">Quick server setup</a>,
<!-- @mp @end ignore -->
for an example of the <span class="samp">Export</span> directive.

     <p>There is almost no reason to use the <span class="samp">W</span> flag.  The <span class="samp">R</span> flag
lets anyone on the Internet issue NFS calls to your kernel as the
anonymous user.  SFS filters these calls; it makes sure that they
operate on files covered by the export directive, and it blocks any
calls that would modify the file system.  This approach is safe given
a perfect NFS3 implementation.  If, however, there are bugs in your
NFS code, attackers may exploit them if you have the <span class="samp">R</span>
option&mdash;probably just crashing your server but possibly doing worse.

     <br><dt><span class="samp">LeaseTime </span><var>seconds</var><dd>Specifies the amount of time for which SFS clients can cache file
attributes.  During this period, if a file is modified, the server
will call back to the client to let it know that the file's attributes
have changed.  Unfortunately, if a file is modified not through SFS
(e.g., through the local file system interface on the server), the
server may not realize the attributes have changed, and clients may
see stale data for the lease period.  The default lease term is 60
seconds.

   </dl>
   <!-- @mp @end description -->
<!-- @mp @end conffile -->
<!-- @mp @end -->

<p><a name="sfsrosd_005fconfig"></a>

<!-- node-name, next, previous, up -->
<!-- @mp -->
<!-- @mp @conffile{sfsrosd_config}{read-only file server configuration} -->
<!-- @mp @description -->
<dl>
<dt><span class="samp">Publishfile </span><var>path</var><dd>Tells <span class="command">sfsrosd</span> to serve the SFS read-only database
contained in file <var>path</var>.

   </dl>
   <!-- @mp @end description -->
<!-- @mp @end conffile -->
<!-- @mp @end -->

<p><a name="sfsauthd_005fconfig"></a>

<!-- node-name,  next,  previous,  up -->
<h3 class="section">5.3 <span class="file">sfsauthd_config</span>&mdash;User-authentication daemon configuration</h3>

<p><a name="index-_0040file_007bsfsauthd_005fconfig_007d-15"></a>
<!-- @mp -->
<!-- @mp @conffile{sfsauthd_config}{user-authentication daemon configuration} -->
<!-- @mp @description -->
     <dl>
<dt><span class="samp">Hostname </span><var>name</var><dd>Set the <var>Location</var> part of the server's self-certifying pathname. 
The default is the current host's fully-qualified hostname.

     <br><dt><span class="samp">Keyfile </span><var>path</var><dd>Tells <span class="command">sfsrwsd</span> to look for its private key in file <var>path</var>. 
The default is <span class="file">sfs_host_key</span>.  SFS looks for file names that do
not start with <span class="file">/</span> in <span class="file">/etc/sfs</span>, or whatever directory you
specified if you used the <span class="option">--with-etcdir</span> option to
<span class="command">configure</span> (see <a href="#configure">configure</a>).

     <br><dt><span class="samp">Userfile [-update] [-create] [-passwd] [-admin] [-hideusers] [-pub=</span><var>pubpath</var><span class="samp">] [-prefix=</span><var>prefix</var><span class="samp">] [-uid=</span><var>uid</var><span class="samp"> | -uidmap=</span><var>u1</var><span class="samp">-</span><var>u2</var><span class="samp">+</span><var>u3</var><span class="samp">] [-gid=</span><var>gid</var><span class="samp"> | -gidmap=</span><var>g1</var><span class="samp">-</span><var>g2</var><span class="samp">+</span><var>g3</var><span class="samp">] [-groups=</span><var>g1</var><span class="samp">-</span><var>g2</var><span class="samp">] [-groupquota=</span><var>limit</var><span class="samp">] [-refresh=</span><var>seconds</var><span class="samp">] [-timeout=</span><var>seconds</var><span class="samp">] </span><var>path</var><dd>This specifies a file in which <span class="command">sfsauthd</span> should look for user
public keys when authenticating users.  You can specify multiple
<span class="samp">Userfile</span> directives to use multiple files.  This can be useful in
an environment where most user accounts are centrally maintained, but a
particular server has a few locally-maintained guest (or root) accounts.

     <p>If <span class="command">sfsauthd</span> has been compiled with
<a href="http://www.sleepycat.com/">Sleepycat database</a> support, and
<var>path</var> ends in <span class="file">.db/</span>, <span class="command">vidb</span> will consider the user
authentication file to be a database directory.  This offers
considerably greater efficiency for large databases, as databases
directories most operations O(log n) rather than O(n) for flat text
files.  If <var>path</var> ends in <span class="file">.db</span>, it is assumed to be a
database file.  Database files are similar to database directories,
but can only be used for read-only databases (as they do not support
atomic transactions).  Database files should be used to export
databases via the <span class="samp">-pub=</span><var>pubpath</var> option, and to import
read-only databases (by omitting the <span class="samp">-update</span> option).

     <p>Userfile has the following options:

          <dl>
<dt><span class="option">-update</span><dd>Specifies a user database as updatable.  Users can register new public
keys, update their public keys, and change their server key
information on writable databases.  If this command is not given, the
database is assumed to be read-only and possibly on a remote machine. 
Thus, <span class="command">sfsauthd</span> maintains local copies of read-only databases
in <span class="file">/var/sfs/authdb</span>.  This process ensures that
temporarily unavailable file servers never disrupt
<span class="command">sfsauthd</span>'s operation.

          <br><dt><span class="option">-create</span><dd>Create an empty <span class="file">sfs_users</span> file if no such file exists.

          <br><dt><span class="option">-passwd</span><dd>Treat the Unix passwd file (<span class="file">/etc/passwd</span> on most machines) as
part of this userfile.  Use password, shell and home directory
information.  Allows users who do not exist in the database to log
into <span class="command">sfsauthd</span> with their UNIX password, so that they
might register an SFS key (note this also requires the
<span class="option">-update</span> flag).  See <a href="#sfskey-register">sfskey register</a>, for details on
this. Also important for proper functioning of <span class="command">rexd</span>.

          <br><dt><span class="option">-admin</span><dd>Allow an SFS administrator to make changes to user records that have
the admin flag set in their <span class="option">privs</span> field.

          <br><dt><span class="option">-hideusers</span><dd>When replying to group queries, replace local user names (that appear in
the ownership or membership lists) with a hash of the user's public key.

          <br><dt><span class="option">-pub=</span><var>pubpath</var><dd><span class="command">sfsauthd</span> supports the secure remote password protocol, or SRP. 
SRP lets users connect securely to <span class="command">sfsauthd</span> with their
passwords, without needing to remember the server's public key.  To
prove its identity through SRP, the server must store secret data
derived from a user's password.  The file <var>path</var> specified in
<span class="samp">Userfile</span> contains these secrets for users opting to use SRP.  The
<span class="option">-pub</span> option tells <span class="command">sfsauthd</span> to maintain in
<var>pubpath</var> a separate copy of the database without secret
information.  <var>pubpath</var> might reside on an anonymously readable SFS
file system&mdash;other machines can then import the file as a read-only
database using a <span class="command">Userfile</span> line with the <span class="option">-update</span>
flag.

          <br><dt><span class="option">-prefix=</span><var>prefix</var><dd>Prepend the prefix <var>prefix</var> to usernames in the given userfile.

          <br><dt><span class="option">-uid=</span><var>uid</var><dt><span class="option">-uidmap=</span><var>u1</var><span class="option">-</span><var>u2</var><span class="option">+</span><var>u3</var><dd>These options are mutually exclusive.  The first maps every user's credentials
in the given file to the given UID, <var>uid</var>.  The second maps users in
the UID range (<var>u1</var> to <var>u2</var>) to the offset <var>u3</var>.  For example, if
you wanted to map users to 1000-2520 to 61000-62520, you would supply
-uidmap=1000-2520+60000.

          <br><dt><span class="option">-gid=</span><var>gid</var><dt><span class="option">-gidmap=</span><var>g1</var><span class="option">-</span><var>g2</var><span class="option">+</span><var>g3</var><dd>See above.  Functions the same as <span class="option">uid</span> and <span class="option">uidmap</span>, but
applies to group IDs, rather than user IDs.  Again, these options
are mutually exclusive.

          <br><dt><span class="option">-groups=</span><var>g1</var><span class="option">-</span><var>g2</var><dd>This option tells <span class="command">sfsauthd</span> to allow regular (non-admin) users
to add groups.  New group IDs will be in the range <var>g1</var> to <var>g2</var>. 
Administrators can establish per-user quotas to limit the number of
groups that a particular user can create.  User quotas are listed in
the <var>privs</var> field of user records as "groupquota"=<var>quota</var> where
<var>quota</var> is an unsigned integer.

          <br><dt><span class="option">-groupquota=</span><var>limit</var><dd>Set the default maximum number of groups that any non-administrative user
can create.  Administrative users have the `admin' keyword in the `privs'
field of their user entry.  The authentication server also looks for the
pattern `groupquota=&lt;limit&gt;' in the user record; if found, that per-user
quota takes precedence and overrides this global (UserFile-wide) setting. 
If no group quota is specified in either place, the number of groups that a
user can create is unlimited.

          <br><dt><span class="option">-refresh=</span><var>seconds</var><dd>This option allows the administrator to set a default refresh value for
newly created users and/or groups in this database.  The refresh value is
stored with the user and/or group record and is retured with the record in
response to database queries.  The refresh value tells the entity who is
fetching the record that it can continue to use its cached copy of this
record for <var>seconds</var> seconds since the last time it was successfully
updated.  That is, the record does not need refreshing for at least
<var>seconds</var> seconds.  If unspecified, the current system default is 3600
seconds (1 hour).

          <br><dt><span class="option">-timeout=</span><var>seconds</var><dd>This option allows the administrator to set a default timeout value for
newly created users and/or groups in this database.  The timeout value is
stored with the user and/or group record and is retured with the record in
response to database queries.  The timeout value tells the entity who is
fetching the record that&mdash;in the event that the authentication server is
unavailable&mdash;the entity can continue to use its cached copy of this
record for <var>seconds</var> seconds since the last time it was successfully
updated.  If unspecified, the current system default is 604800 seconds (1
week). 
</dl>

     <p>If no <span class="samp">Userfile</span> directive is specified, <span class="command">sfsauthd</span> uses
the following default (again, unqualified names are assumed to be in
<span class="file">/etc/sfs</span>):

     <pre class="example">          Userfile -update -passwd -pub=sfs_users.pub sfs_users
     </pre>
     <br><dt><span class="samp">DBcache </span><var>path</var><dd>The <var>path</var> to the database that holds the authentication server's
cache.  If unspecified, it defaults to one of the two entries shown
below.  The first applies if Sleepycat (BerkeleyDB) support was compiled
in; otherwise, the second entry applies.  If <var>path</var> begins with a
"/" (slash), it is taken to be an absolute path.  If not, it is a path
relative to <span class="file">/var/sfs/authdb</span>.

     <pre class="example">          dbcache dbcache.db/
          dbcache dbcache
     </pre>
     <br><dt><span class="samp">DBcache_refresh_delay </span><var>seconds</var><dd>Specify the frequency (in seconds) that <span class="command">sfsauthd</span>
will attempt to refresh its cache.  This value only serves as a
minimum because the server will not attempt to download a remote
user or group more frequently than its individual refresh value
(set by the remote administrator or user).  The special value
`off' disables the authentication cache as well as symbolic and/or
recursive groups.  The default is `off'.

     <pre class="example">          dbcache_refresh_delay off
          dbcache_refresh_delay 3600
     </pre>
     <br><dt><span class="samp">Logfile </span><var>path</var><dd>Use the logfile given by <var>path</var> to output the signature log
generated by <span class="command">sfsauthd</span>.  The default logfile is
<span class="file">/var/sfs/sign_log</span>.

     <br><dt><span class="samp">SRPfile </span><var>path</var><dd>Where to find default parameters for the SRP protocol.  Generate such a
file using the <span class="command">sfskey gensrp</span> command. The default is
<span class="file">sfs_srp_params</span>.  If the default file does not exist, serving
pre-generated SRP parameters is disabled.

     <br><dt><span class="samp">Denyfile </span><var>path</var><dd>Specify a file containing a list of users that are to be explicitly
denied the ability to register and update keys on the authserver.  The
default is <span class="file">sfs_deny</span>.  If the default file does not exist, we
assume an empty list.

     <br><dt><span class="samp">Realm </span><var>name</var><dd><a name="Realm"></a>
<a name="index-realms-16"></a>Define the realm to which this authserver will belong.  Authentication
information (including SRP) can be shared amongst authservers that are
in the same realm.  Thus, a user that wants to login to a realm, can
contact any authserver in that realm.

     <p>If the realm directive does NOT appear in this file, the authserver will
not join any realm.  This behavior is the default.  If the realm
directive does appear, <var>name</var> cannot be empty.

     <p>NOTE: Changing an authserver's realm after users have already registered
using SRP requires all users to update their authentication data because
the realm is bound into the stored SRP information.  Specifically, each
user will need to run

     <pre class="example">          sfskey update -r username@authserver
     </pre>
     <p>A user logged on to the authserver can use the hostname <var>-</var> to
signify the local host:

     <pre class="example">          sfskey update -r -
     </pre>
     <br><dt><span class="samp">Certpath </span><var>dir</var><span class="samp"> [</span><var>dir</var><span class="samp"> ...]</span><dd>Specify a certification path to return to the client as a result of an
<span class="command">sfskey login</span> command; this list of directories will become the
arguments to a dirsearch certprog.  That is, for a certpath "<var>dir1</var>
<var>dir2</var>" the client will add a certprog "dirsearch <var>dir1</var>
<var>dir2</var>" to the user's agent.  The certification path will be tagged
with a prefix equal to the authserver's realm (see above).

     <p>NOTE: The certpath directive only makes sense if the authserver is
part of a realm.  The certpath will be ignored if the realm directive
isn't specified.

     <p>There are three ways to specify a certpath directory:

     <pre class="example">          certpath //dir1 /dir2 @sfs.host.domain,HOSTID/dir2
     </pre>
     <p>which can also be written

     <pre class="example">          certpath //dir1
          certpath /dir2
          certpath @sfs.host.domain,HOSTID/dir2
     </pre>
     <p>A directory starting with two slashes ("//") is considered relative
to the client machine's root ("/").  A directory starting with one
slash ("/") is relative to the authserver's self-certifying pathname
(the authserver performs the substitution before is sends the dir). 
The third form is a fully specified directory on SFS.

     <p>The default certpath is empty. 
</dl>
   <!-- @mp @end description -->
<!-- @mp @end conffile -->
<!-- @mp @end -->

<p><a name="sfs_005fhosts"></a>

<!-- node-name,  next,  previous,  up -->
<h3 class="section">5.4 <span class="file">sfs_hosts</span>&mdash;Host to address mapping overriding DNS</h3>

<p><a name="index-_0040file_007bsfs_005fhosts_007d-17"></a>
<!-- @mp -->
<!-- @mp @conffile{sfs_hosts}{Host to address mapping overriding DNS} -->
<!-- @mp @description -->
All SFS client software uses DNS to locate server names.  This is
somewhat different from typical network utilities, which, often
depending on a configuration file such as <span class="file">/etc/nsswitch.conf</span>,
can sometimes combine DNS with other techniques, such as scanning the
file <span class="file">/etc/hosts</span> or querying NIS (YP) servers.

   <p>SFS relies exclusively on DNS for several reasons.  First, the file
system is designed to provide a global namespace.  Using
<span class="file">/etc/hosts</span>, for example, it is common for a machine to have two
names&mdash;for instance <span class="samp">hostname</span>, and <span class="samp">hostname.domain.com</span>. 
However, were the same file system to be available under two different
self-certifying pathnames, several things would go wrong:  First,
bookmarks to <span class="file">/sfs/@hostname,.../...</span> would only work on the
local network.  Even worse, it might be possible to lose a file by
accidentally copying it onto itself, e.g., from
<span class="file">/sfs/@hostname,.../...</span> to
<span class="file">/sfs/@hostname.domain.com,.../...</span>.  Finally, SFS allows one to
specify a TCP port number other than the default (4) using DNS SRV
records, while non-DNS mechanisms have no means of specifying port
numbers.

   <p>Though DNS is fairly ubiquitous, there are situations in which one
might like to have &ldquo;internal&rdquo; connections to SFS servers routed
differently from &ldquo;external&rdquo; ones.  For example, when running SFS
servers behind a NAT box, external connections would need to be
directed to the external IP address of the NAT box, while it would be
more efficient to route internal connections directly to the internal
IP address, without going through the NAT.  In such situations, often
the best solution is to set up a split DNS configuration.  When split
DNS is not an option, however, the <span class="file">sfs_hosts</span> mechanism will
come in handy.

   <p><span class="file">sfs_hosts</span> is a superset of the standard <span class="file">/etc/hosts</span> file
format, that additionally allows one to specify a port number by
appending it with a <span class="samp">%</span> character at the end of the address.  By
default, the port number is 4.  For example, the following two lines
both specify that <span class="samp">server.domain.com</span> is running on port 4 of IP
address <span class="samp">10.1.1.1</span>:

<pre class="example">     10.1.1.1          server.domain.com
     10.1.1.1%4        server.domain.com
</pre>
   <p>If you really want <span class="file">/etc/hosts</span> to override DNS with SFS, you can
always run <span class="samp">ln -s ../hosts /etc/sfs/sfs_hosts</span>, but this is not
recommended.  Solutions involving DNS configuration will be much more
scalable and flexible.

<!-- @mp @end description -->
<!-- @mp @end conffile -->
<!-- @mp @end -->
<p><a name="sfs_005fusers"></a>

<!-- node-name,  next,  previous,  up -->
<h3 class="section">5.5 <span class="file">sfs_users</span>&mdash;User-authentication database</h3>

<p><a name="index-_0040file_007bsfs_005fusers_007d-18"></a>
<!-- @mp -->
<!-- @mp @conffile{sfs_users}{user-authentication database} -->
<!-- @mp @description -->
The <span class="file">sfs_users</span> file, maintained and used by the
<span class="command">sfsauthd</span> program, maps public keys to local users and
groups. It is roughly analogous to the Unix <span class="file">/etc/passwd</span> and
<span class="file">/etc/group</span> files.  Each line of <span class="file">sfs_users</span> can specify a
user or a group.  Users are specified as follows (split into two
lines here only for clarity of presentation):

<pre class="example">     USER:<var>user</var>:<var>uid</var>:<var>version</var>:<var>gid</var>:<var>owner</var>:<var>pubkey</var>:<var>privs</var>
                               :<var>srp</var>:<var>privkey</var>:<var>srvprivkey</var>:<var>audit</var>
</pre>
   <p class="noindent">Note that the first <span class="samp">USER</span> is just the literal string
<span class="samp">USER</span>.  The rest of the fields have the following meanings:

     <dl>
<dt><var>user</var><dd><var>user</var> is the unique name of a public key in the database. 
Ordinarily it is the same as a username in the local password file. 
However, it is also possible to add SFS users who do not have local
Unix accounts.  It is also possible map multiple public keys to the
same local Unix account, as when several people have an account with
root privileges.  In such cases, each key should be given a unique
name (e.g., <span class="samp">dm/root</span>, <span class="samp">kaminsky/root</span>, etc.).

     <br><dt><var>uid</var><dd><var>uid</var> is the user's user ID on the given server.

     <br><dt><var>version</var><dd><var>version</var> is the version number of this record in the users database. 
Upon registration, this value is set to 1.  Upon every subsequent update,
this value is incremented by 1.

     <br><dt><var>gid</var><dd><var>gid</var> is the users's group ID on the given server.

     <br><dt><var>owner</var><dd>This field is currently ignored, but in a future version may be used
to allow users to create &ldquo;guest&rdquo; accounts.

     <br><dt><var>pubkey</var><dd><var>pubkey</var> is an ASCII, human-readable representation of the user's public
key.  Can be either a Rabin or 2-Schnorr public key.

     <br><dt><var>privs</var><dd>The <var>privs</var> field contains a comma-separated list of properties of
the account.  Possible properties are as follows:

          <dl>
<dt><span class="samp">unix=</span><var>account</var><dd>This property states that an SFS user corresponds to the local Unix
account <var>account</var>.  In many settings, it is common to use the
<span class="samp">unix=</span> property to map every SFS user to a local Unix user of
the same name.  The <span class="samp">unix=</span> property has several consequences. 
First, if there is no local Unix user named <var>account</var>, this SFS
user will not be allowed to log in.  Second, when the SFS user logs
in, SFS will search <span class="file">/etc/group</span> for additional groups the user
might belong to.  Third, the <span class="command">rexd</span> remote login daemon will
allow remote login access to this account, using the shell and home
directory specified in <span class="file">/etc/passwd</span>.  Finally, on some operating
systems, SFS enforces account expiration dates specified by
<span class="file">/etc/shadow</span> or <span class="file">/etc/spwd.db</span>.

          <br><dt><span class="samp">admin</span><dd>Indicates that this particular users has administrative privileges in
SFS.  The option has no effect unless the <span class="samp">Userfile</span> directive in
<span class="file">sfsauthd_config</span> specifies the <span class="option">-admin</span> option.  For
<span class="file">sfs_users</span> files with the <span class="option">-admin</span> option, the
<span class="samp">admin</span> privilege allows users to create and modify other user
records remotely, though currently client-side support for doing this
is limited.

          <br><dt><span class="samp">refresh</span><br><dt><span class="samp">timeout</span><dd>These properties are mostly of use with <span class="command">sfsaclsd</span>, an
experimental server that is not part of the mainline SFS distribution
yet. 
</dl>

     <br><dt><var>srp</var><dd><var>srp</var> is the server-side information for the SRP protocol,
<a href="#SRP">SRP</a>.  Unlike the previous fields, this information must be kept
secret.  If the information is disclosed, an attacker may be able to
impersonate the server by causing the <span class="command">sfskey add</span> command to
fetch the wrong <var>HostID</var>.  Note also that <var>srp</var> is specific to
a particular hostname.  If you change the <var>Location</var> of a file
server, users will need to register new <var>SRP</var>.

     <br><dt><var>privkey</var><dd><var>privkey</var> is actually opaque to <span class="command">sfsauthd</span>.  It is
private, per-user data that <span class="command">sfsauthd</span> will return to users who
successfully complete the SRP protocol.  Currently, <span class="command">sfskey</span>
users this field to store an encrypted copy of a user's private key,
allowing the user to retrieve the private key over the network.

     <br><dt><var>srvprivkey</var><dd>If a user has chosen 2-Schnorr proactive signatures, the server's half
of the private key is kept in this field.

     <br><dt><var>audit</var><dd><var>audit</var> contains the time, source IP address, and description of the
last update to this field.  Useful in recovering from a compromised key.

   </dl>

<p class="noindent">Each group in <span class="file">sfs_users</span> is specified by a line with the
following format:

<pre class="example">     GROUP:<var>group</var>:<var>gid</var>:<var>version</var>:<var>owners</var>:<var>members</var>:<var>properties</var>:<var>audit</var>
</pre>
   <p class="noindent">Here again the first <span class="samp">GROUP</span> is just the literal string
<span class="samp">GROUP</span>, while the remaining fields have the following meanings:

     <dl>
<dt><var>group</var><dd>The name of the group.

     <br><dt><var>gid</var><dd>The numeric group ID.

     <br><dt><var>version</var><dd><var>version</var> is the version number of this record in the database. 
The number increments when people edit groups through the
<span class="command">sfskey</span> interface.

     <br><dt><var>owners</var><dd>List of users who are allowed to edit the group membership list.

     <br><dt><var>members</var><dd>List of users who are in the group.

     <br><dt><var>properties</var><dd>Properties of the group, mostly of use with <span class="command">sfsaclsd</span>, an
experimental server that is not part of the mainline SFS distribution
yet.

     <br><dt><var>audit</var><dd>Information about the last time this record was modified through the
<span class="command">sfskey</span> interface. 
</dl>

   <p><span class="file">sfs_users</span> files can be stored in one of three formats:  plain
ASCII, database directories, and database files.  (The latter two
require SFS to have been compiled with Sleepycat BerkeleyDB support.) 
The format is determined by the extension of the file name.  File
names ending <span class="file">.db/</span> are considered database directories; file
names ending <span class="file">.db</span> are considered database files; everything else
is considered ASCII.  Only read-only and exported public databases can
be database files; read-write databases must be directories, ending
<span class="file">.db/</span>. 
<!-- It is highly recommended that administrators -->
<!-- @emph{not} use database files (as opposed to directories) for anything -->
<!-- other than public, read-only @file{sfs_users} files shared amongst -->
<!-- machines. -->
(The reason is that read-write database files require write-ahead
logging, which relies on auxiliary files.) 
<!-- stored in -->
<!-- @file{@value{SFSDIR}@dslash{}dbenv}.  It is easy to forget this and -->
<!-- rename or delete database files stored elsewhere, with the disastrous -->
<!-- result that old log records may get applied to different files.) -->

   <p>You should always edit <span class="file">sfs_users</span> files using the
<!-- @mp @ignore -->
<span class="command">vidb</span> command (see <a href="#vidb">vidb</a>),
<!-- @mp @end ignore -->
for two reasons.  First, whenever editing files by hand, you run the
risk of overwriting concurrent updates by <span class="command">sfsauthd</span>. 
<span class="command">vidb</span> acquires the necessary locks to prevent this from
happening.  Second, when editing a database directory or file,
<span class="command">vidb</span> translates from the binary database format into the
ASCII format described above; when committing updates, it also
atomically modifies various secondary indexes that SFS relies upon. 
<!-- @mp @end description -->
<!-- @mp @end conffile -->
<!-- @mp @end -->

<p><a name="sfssd_005fconfig"></a>

<!-- node-name,  next,  previous,  up -->
<h3 class="section">5.6 <span class="file">sfssd_config</span>&mdash;Meta-server configuration</h3>

<p><a name="index-_0040file_007bsfssd_005fconfig_007d-19"></a>
<!-- @mp -->
<!-- @mp @conffile{sfssd_config}{meta-server configuration} -->
<!-- @mp @description -->
<span class="file">sfssd_config</span> configures <span class="command">sfssd</span>, the server that accepts
connections for <span class="command">sfsrwsd</span> and <span class="command">sfsauthd</span>. 
<span class="file">sfssd_config</span> can be used to run multiple &ldquo;virtual servers&rdquo;, or
to run several versions of the server software for compatibility with
old clients.

   <p>Directives are:

     <dl>
<dt><span class="samp">BindAddr </span><var>ip-addr</var><span class="samp"> [</span><var>port</var><span class="samp">]</span><dd><a name="BindAddr"></a>

     <p>Explicitly specifies the IP address and port on which <span class="command">sfssd</span>
should listen for TCP connections.  To listen on <code>INADDR_ANY</code>,
use the value <span class="samp">0.0.0.0</span> for <var>ip-addr</var>.  If <var>port</var> is not
specified, <span class="command">sfssd</span> will use the value of the <span class="env">SFS_PORT</span>
environment variable, if it exists and is non-zero, or else fall back
to the default port number of 4.

     <p>It is important to note the difference between specifying a port
number with the <span class="env">SFS_PORT</span> environment variable, and with a
<span class="samp">BindAddr</span>
<!-- @mp @ignore -->
directive (see <a href="#SFS_005fPORT">SFS_PORT</a>). 
<!-- @mp @end ignore -->

     <p>When no <span class="samp">BindAddr</span> directive is specified, <span class="command">sfssd</span>
attempts to figure out the appropriate port number(s) to bind to
automatically.  It does so by looking for DNS SRV records for the
current hostname (or <span class="env">SFS_HOSTNAME</span> environment variable).  This
is quite different from specifying <span class="samp">BindAddr 0.0.0.0 0</span>, which
would always bind port 4 or whatever is specified with the
<span class="env">SFS_PORT</span> environment variable.

     <!-- A port number of 0 means to check DNS for port numbers specified in -->
<!-- SRV records, and to use port 4 in the common case that no SRV records -->
<!-- are employed.  @samp{BindAddr} can be specified multiple times to -->
<!-- listen on multiple addresses and/or ports. -->
<br><dt><span class="samp">RevocationDir </span><var>path</var><dd>Specifies the directory in which <span class="command">sfssd</span> should search for
revocation/redirection certificates when clients connect to unknown
(potentially revoked) self-certifying pathnames.  The default value is
<span class="file">/var/sfs/srvrevoke</span>.  Use the command <span class="samp">sfskey
revokegen</span> to generate revocation certificates.

     <br><dt><span class="samp">HashCost </span><var>bits</var><dd><a name="HashCost"></a>
Specifies that clients must pay for connections by burning CPU time. 
This can help reduce the effectiveness of denial-of-service attacks. 
The default value is 0.  The maximum value is 22.

     <br><dt><span class="samp">Server {* | @</span><var>Location</var><span class="samp">[,</span><var>HostID</var><span class="samp">]}</span><dd>Specifies a section of the file that applies connection requests for the
self-certifying pathname @<var>Location</var><span class="samp">,</span><var>HostID</var>.  If
<span class="samp">,</span><var>HostID</var> is omitted, then the following lines apply to any
connection that does not match an explicit <var>HostID</var> in another
<span class="samp">Server</span>.  The argument <span class="samp">*</span> applies to all clients who do not
have a better match for either <var>Location</var> or <var>HostID</var>.

     <br><dt><span class="samp">Release {* | </span><var>sfs-version</var><span class="samp">}</span><dd>Begins a section of the file that applies to clients running SFS release
<var>sfs-version</var> or older.  <span class="samp">*</span> signifies arbitrarily large SFS
release numbers.  The <span class="samp">Release</span> directive does not do anything on
its own, but applies to all subsequent <span class="samp">Service</span> directives until
the next <span class="samp">Release</span> or <span class="samp">Server</span> directive.

     <br><dt><span class="samp">Extensions </span><var>ext1</var><span class="samp"> [</span><var>ext2</var><span class="samp"> ...]</span><dd>Specifies that subsequent <span class="samp">Service</span> directives apply only to
clients that supply all of the listed extension strings (<var>ext1</var>,
<small class="dots">...</small>).  <span class="samp">Extensions</span> applies until the next <span class="samp">Extensions</span>,
<span class="samp">Release</span> or <span class="samp">Server</span> directive

     <br><dt><span class="samp">Service </span><var>srvno</var> <var>daemon</var><span class="samp"> [</span><var>arg</var><span class="samp"> ...]</span><dd>Specifies the daemon that should handle clients seeking service number
<var>srvno</var>.  SFS defines the following values of <var>srvno</var>:

     <pre class="display">          1. File server
          2. Authentication server
          3. Remote execution
          4. SFS/HTTP (not yet released)
     </pre>
     <br><dt><span class="samp">Service </span><var>srvno</var><span class="samp"> -u </span><var>path</var><dd>Operates as the above syntax of <span class="samp">Service</span>, only instead of
spawning a daemon, connects to the unix-domain socket specified by
<span class="samp">path</span> to communicate with an already running daemon.  This
option may be useful when debugging SFS servers, as the server for a
particular service on a particular self-certifying pathname can be run
under the debugger and receive connections on the usual SFS port
without interfering with other servers on the same machine.

     <br><dt><span class="samp">Service </span><var>srvno</var><span class="samp"> -t </span><var>host</var><span class="samp"> [</span><var>port</var><span class="samp">]</span><dd>Specifies that <span class="command">sfssd</span> should act as a &ldquo;TCP proxy&rdquo; for this
particular service, relaying any incoming connections to TCP port
<var>port</var> on <var>host</var>.  If unspecified, <var>port</var> is the default
SFS TCP port 4.

     <p>This syntax is useful in a NATted environment.  For instance, suppose
you have two SFS servers with addresses 10.0.0.2 and 10.0.0.3 on a
private network, and one machine 10.0.0.1 with an externally visible
interface 4.3.2.1.  You can use this proxy syntax to export the
internal file systems.  The easiest way is to pick two DNS names for
the new servers, but point them at your outside server.  For example:

     <pre class="example">          server-a.mydomain.com.  IN A    4.3.2.1
          server-b.mydomain.com.  IN A    4.3.2.1
     </pre>
     <p>Then, on your outside machine, you might have the following
<span class="file">sfssd_config</span> file:

     <pre class="example">          Server server-a.mydomain.com
            Release *
                Service 1 -t 10.0.0.2
                Service 2 -t 10.0.0.2
                Service 3 -t 10.0.0.2
          Server server-b.mydomain.com
            Release *
                Service 1 -t 10.0.0.3
                Service 2 -t 10.0.0.3
                Service 3 -t 10.0.0.3
     </pre>
     <p>Then on each of the internal machines, be sure to specify
<span class="samp">Hostname server-A.mydomain.com</span> and <span class="samp">Hostname
server-B.mydomain.com</span> in <span class="file">sfsrwsd_config</span>.

   </dl>

<p class="noindent">The default contents of <span class="file">sfssd_config</span> is:

<pre class="example">     Server *
       Release *
           Service 1 sfsrwsd
           Service 2 sfsauthd
           Service 3 rexd
</pre>
   <p class="noindent">To disable the file server, you can copy this file to
<span class="file">/etc/sfs/sfssd_config</span> and comment out the
line <span class="samp">Service 1 sfsrwsd</span>.  To disable the remote login server,
comment out the line for <span class="samp">rexd</span>.

<p class="noindent">To run a different server for sfs-0.6 and older clients, you could add
the lines:

<pre class="example">       Release 0.6
         Service 1 /usr/local/lib/sfs-0.6/sfsrwsd
</pre>
   <!-- @mp @end description -->
<!-- @mp @end conffile -->
<!-- @mp @end -->
<p><a name="sfs_005fsrp_005fparams"></a>

<!-- node-name,  next,  previous,  up -->
<h3 class="section">5.7 <span class="file">sfs_srp_params</span>&mdash;Default parameters for SRP protocol</h3>

<p><a name="index-_0040file_007bsfs_005fsrp_005fparams_007d-20"></a>
<!-- @mp -->
<!-- @mp @conffile{sfs_srp_params}{default parameters for SRP protocol} -->
<!-- @mp @description -->
Specifies a &ldquo;strong prime&rdquo; and a generator for use in the SRP
protocol.  SFS ships with a particular set of parameters because
generating new ones can take a considerable amount of CPU time.  You can
replace these parameters with randomly generated ones using the
<span class="samp">sfskey srpgen -b </span><var>bits</var> command.

   <p>Note that SRP parameters can afford to be slightly shorter than Rabin
public keys, both because SRP is based on discrete logs rather than
factoring, and because SRP is used for authentication, not secrecy.

   <p>The format of the file is a single line of the form:

<pre class="display">     <span class="samp">N=0x</span><var>Modulus</var><span class="samp">,g=0x</span><var>Generator</var>
</pre>
   <p><var>Modulus</var> is a prime number, represented in hexadecimal, which
must satisfy the property that (<var>Modulus</var>-1)/2 is also prime. 
<var>Generator</var> is an element of the multiplicative group of integers
modulo <var>Modulus</var> such that <var>Generator</var> has order
(<var>Modulus</var>-1)/2.

<!-- @mp @end description -->
<!-- @mp @end conffile -->
<!-- @mp @end -->
<p><a name="sfscd_005fconfig"></a>

<!-- node-name,  next,  previous,  up -->
<h3 class="section">5.8 <span class="file">sfscd_config</span>&mdash;Meta-client configuration</h3>

<p><a name="index-_0040file_007bsfscd_005fconfig_007d-21"></a>
<!-- @mp -->
<!-- @mp @conffile{sfscd_config}{meta-client configuration} -->
<!-- @mp @description -->
The <span class="file">sfscd_config</span> is really part of the SFS protocol
specification.  If you change it, you will no longer be executing the
SFS protocol.  Nonetheless, you need to do this to innovate, and SFS was
designed to make implementing new kinds of file systems easy.

   <p><span class="file">sfscd_config</span> takes the following directives:

     <dl>
<dt><span class="samp">Extension </span><var>string</var><dd>Specifies that <span class="command">sfscd</span> should send <var>string</var> to all servers
to advertise that it runs an extension of the protocol.  Most servers
will ignore <var>string</var>, but those that support the extension can
pass off the connection to a new &ldquo;extended&rdquo; server daemon.  You can
specify multiple <span class="samp">Extension</span> directives.

     <br><dt><span class="samp">Protocol </span><var>name</var> <var>daemon</var><span class="samp"> [</span><var>arg</var><span class="samp"> ...]</span><dd>Specifies that pathnames of the form
<span class="file">/sfs/</span><var>name</var><span class="file">:</span><var>anything</var> should be handled by the
client daemon <var>daemon</var>.  <var>name</var> may not contain any
non-alphanumeric characters.  The <span class="samp">Protocol</span> directive is useful
for implementing file systems that are not mounted on self-certifying
file systems.

     <br><dt><span class="samp">Release {* | </span><var>sfs-version</var><span class="samp">}</span><dd>Begins a section of the file that applies to servers running SFS release
<var>sfs-version</var> or older.  <span class="samp">*</span> signifies arbitrarily large SFS
release numbers.  The <span class="samp">Release</span> directive does not do anything on
its own, but applies to all subsequent <span class="samp">Program</span> directives until
the next <span class="samp">Release</span> directive.

     <br><dt><span class="samp">Libdir </span><var>path</var><dd>Specifies where SFS should look for daemon programs when their
pathnames do not begin with <span class="file">/</span>.  The default is
<span class="file">/usr/local/lib/sfs-0.8pre</span>.  The <span class="samp">Libdir</span>
directive does not do anything on its own, but applies to all
subsequent <span class="samp">Program</span> directives until the next <span class="samp">Libdir</span> or
<span class="samp">Release</span> directive.

     <br><dt><span class="samp">Program </span><var>prog</var><span class="samp">.</span><var>vers</var> <var>daemon</var><span class="samp"> [</span><var>arg</var><span class="samp"> ...]</span><dd>Specifies that connections to servers running Sun RPC program number
<var>prog</var> and version <var>vers</var> should be handed off to the the local
daemon <var>daemon</var>.  SFS currently defines two RPC program numbers. 
Ordinary read-write servers use program number 344444, version 3 (a
protocol very similar to NFS3), while read-only servers use program
344446, version 1.  The read-only code has not been released yet.  The
<span class="samp">Program</span> directive must be preceded by a <span class="samp">Release</span> directive. 
</dl>

<p class="noindent">The default <span class="file">sfscd_config</span> file is:

<pre class="example">     Release *
       Program 344444.3 sfsrwcd
</pre>
   <p class="noindent">To run a different set of daemons when talking to sfs-0.3 or older
servers, you could add the following lines:

<pre class="example">     Release 0.3
       Libdir /usr/local/lib/sfs-0.3
       Program 344444.3 sfsrwcd
</pre>
   <!-- @mp @end description -->
<!-- @mp @end conffile -->
<!-- @mp -->
<p><a name="Command-reference"></a>

<!-- node-name,  next,  previous,  up -->
<h2 class="chapter">6 Command reference guide</h2>

<p><a name="sfsagent"></a>

<!-- node-name,  next,  previous,  up -->
<h3 class="section">6.1 <span class="command">sfsagent</span> reference guide</h3>

<!-- @mp -->
<!-- @mp @command{sfsagent}{SFS authentication agent}{1} -->
<!-- @mp @description -->
<p><span class="command">sfsagent</span> is the program users run to authenticate themselves
to remote file servers, to create symbolic links in <span class="file">/sfs</span> on the
fly, and to look for revocation certificates.  Many of the features in
<span class="command">sfsagent</span> are controlled by the <span class="command">sfskey</span> program and
described in the <span class="command">sfskey</span> documentation.

   <p>Ordinarily, a user runs <span class="command">sfsagent</span> at the start of a session. 
<span class="command">sfsagent</span> runs <span class="command">sfskey add</span> to obtain a private key. 
As the user touches each SFS file server for the first time, the agent
authenticates the user to the file server transparently using the
private key it has.  At the end of the session, the user should run
<span class="command">sfskey kill</span> to kill the agent. 
<!-- @mp @end description -->

<!-- @mp @ignore -->
<p>The usage is as follows:
<!-- @mp @end ignore -->

<!-- @mp @synopsis -->
<pre class="example">     sfsagent [-dnkF] -S <var>sock</var> [-c [<var>prog</var> [<var>arg</var> ...]] | <var>keyname</var>]
</pre>
   <!-- @mp @end synopsis -->
<!-- @mp @options -->
<dl>
<dt><span class="option">-d</span><dd>Stay in the foreground rather than forking and going into the background

     <br><dt><span class="option">-n</span><dd>Do not attempt to communicate with the SFS file system.  This can be
useful for debugging, or for running an agent on a machine that is not
running an SFS client.  If you specify <span class="option">-n</span>, you must also use
the <span class="option">-S</span> option, otherwise your agent will be useless as there
will be no way to communicate with it.

     <br><dt><span class="option">-k</span><dd>Atomically kill and replace any existing agent.  Otherwise, if your
agent is already running, <span class="command">sfsagent</span> will refuse to run again.

     <br><dt><span class="option">-F</span><dd>Turn off forwarding.  By default programs other than the file system
can ask the agent to authenticate the user.  Specifying this option
disables this functionality.

     <br><dt><span class="option">-S </span><var>sock</var><dd>Listen for connections from programs like <span class="command">sfskey</span> on the Unix
domain socket <var>sock</var>.  Ordinarily <span class="command">sfskey</span> connects to the
agent through the client file system software, but it can use a named
Unix domain socket as well.

     <br><dt><span class="option">-c [</span><var>prog</var><span class="option"> [</span><var>arg</var><span class="option"> ...]]</span><dd>By default, <span class="command">sfsagent</span> on startup runs the command <span class="samp">sfskey
add</span> giving it whatever <span class="option">-t</span> option and <var>keyname</var> you
specified.  This allows you to fetch your first key as you start or
restart the agent.  If you wish to run a different program, you can
specify it using <span class="option">-c</span>.  You might, for instance, wish to run a
shell-script that executes a <span class="samp">sfskey add</span> followed by several
<span class="samp">sfskey certprog</span> commands.

     <p><span class="command">sfsagent</span> runs the program with the environment variable
<span class="env">SFS_AGENTSOCK</span> set to <span class="samp">-0</span> and a Unix domain socket on
standard input.  Thus, when atomically killing and restarting the agent
using <span class="option">-k</span>, the commands run by <span class="command">sfsagent</span> talk to the
new agent and not the old.

     <p>If you don't wish to run any program at all when starting
<span class="command">sfsagent</span>, simply supply the <span class="option">-c</span> option with no
<var>prog</var>.  This will start an new agent that has no private keys. 
</dl>
   <!-- @mp @end options -->
<!-- @mp @end command -->
<!-- @mp -->

<p><a name="sfskey"></a>

<!-- node-name,  next,  previous,  up -->
<h3 class="section">6.2 <span class="command">sfskey</span> reference guide</h3>

<!-- @mp -->
<!-- @mp @command{sfskey}{SFS key manager}{1} -->
<!-- @mp @synopsis -->
<!-- @mpp sfskey [-S @var{sock}] [-p @var{pwfd}] -->
<!-- @mpp @var{command} [@var{arg} @dots{}] -->
<!-- @mp @end synopsis -->
<!-- @mp @description -->
<p>The <span class="command">sfskey</span> command performs a variety of key management tasks,
from generating and updating keys to controlling users' SFS agents.  The
general usage for <span class="command">sfskey</span> is:

<pre class="example">     sfskey [-S <var>sock</var>] [-p <var>pwfd</var>] <var>command</var> [<var>arg</var> ...]
</pre>
   <p class="noindent"><span class="option">-S</span> specifies a UNIX domain socket <span class="command">sfskey</span> can use to
communicate with your <span class="command">sfsagent</span> socket.  If <var>sock</var> begins
with <span class="samp">-</span>, the remainder is interpreted as a file descriptor number. 
The default is to use the environment variable <span class="env">SFS_AGENTSOCK</span> if
that exists.  If not, <span class="command">sfskey</span> asks the file system for a
connection to the agent.

   <p>The <span class="option">-p</span> option specifies a file descriptor from which
<span class="command">sfskey</span> should read a passphrase, if it needs one, instead of
attempting to read it from the user's terminal.  This option may be
convenient for scripts that invoke <span class="command">sfskey</span>.  For operations
that need multiple passphrases, you must specify the <span class="option">-p</span> option
multiple times, once for each passphrase.

   <p>In SFS 0.7, two-party proactive Schnorr signatures (2-Schnorr for short)
are supported in addition to Rabin signatures.  One half of the  2-Schnorr
key is stored on the designated signature sever, while the other is stored
locally to file, or remotely via SRP.  Unlike Rabin keys, 2-Schnorr keys
can fail to load when a signature server becomes unavailable.  For this
reason, <span class="command">sfskey</span> supports multiple private-key shares that correspond
to the same public key; this way, a user can maintain a series of backup
signature servers in case his primary server becomes unavailable.  By
default, <span class="command">sfskey</span> never stores both halves of a 2-Schnorr key
to the same machine, so as to enforce key sharing.  To this effect,
2-Schnorr employs special <span class="command">sfskey</span> commands&mdash;<span class="command">sfskey 2gen</span>
and <span class="command">sfskey 2edit</span>.

   <p>As of SFS 0.7, there is a new convention for saving and naming private
keys.  By default, keys will be stored locally in <span class="file">$HOME/.sfs/authkeys</span>,
and will be in the following forms:

<pre class="example">         <var>user</var>@<var>host1</var>#<var>n</var>
         <var>user</var>@<var>host1</var>#<var>n</var>,<var>p</var>.<var>host2</var>,<var>m</var>
</pre>
   <p>The first form is for standard Rabin keys.  The second is for 2-Schnorr
proactive signature keys.  In the above examples, <var>host1</var> is the
the full hostname of the generating host, <var>n</var> is the public key
version, <var>p</var> is the priority of the signing host (1 is the highest)
<var>host2</var> is the full hostname of the signing host, and <var>m</var> is the
private key version.

   <p>In general, these details can remain hidden, in that the symbolic link
<span class="file">$HOME/.sfs/identity</span> points to the most recent key generated in
<span class="file">$HOME/.sfs/authkeys</span>, and most <span class="command">sfskey</span> commands have
reasonable defaults.  However, there is a command-line system for
accessing and generating specific keys.  A blank keyname and the
special keyname <span class="file">#</span> refer to the default key
<span class="file">$HOME/.sfs/identity</span> during key access and the next available
key during key generation.  Keynames containing a <span class="file">#</span> character
but not containing a <span class="file">/</span> character are assumed to refer to keys
in the <span class="file">$HOME/.sfs/authkeys</span> directory.  When given files of the
form <var>prefix</var><span class="file">#</span>, <span class="command">sfskey</span> looks in the default
directory for the most recent key with the given <var>prefix</var> during key
access, and the next available key with the given <var>prefix</var> during key
generation.  For keys of the form <var>name</var><span class="file">#</span><var>suffix</var>,
<span class="command">sfskey</span> will look in the <span class="file">$HOME/.sfs/authkeys</span> directory
for keys that match the given name exactly. <span class="command">sfskey</span> treats
keys with <span class="file">/</span> characters as regular files; it treats keys that
contain <span class="file">@</span> characters but no <span class="file">#</span> characters as keys stored
on remote machines.

   <p>Finally, one should note that SFS keys have both a <var>keyname</var>
and also a <var>keylabel</var>.  <span class="command">sfskey</span> uses the former to
retrieve keys from the local file system or from remote servers.  The latter
is less important; the <var>keylabel</var> is stored internally in the
private key, and is shown in the output of the <span class="command">sfskey list</span>
command.

<!-- @mp @end description -->
<!-- @mp @options -->
<dl>
<dt><span class="samp">sfskey add [-t [hrs:]min] [</span><var>keyname</var><span class="samp">]</span><dt><span class="samp">sfskey add [-t [hrs:]min] [</span><var>user</var><span class="samp">]@</span><var>hostname</var><dd>The <span class="command">add</span> command loads and decrypts a private key, and gives
the key to your agent.  Your agent will use it to try to authenticate
you to any file systems you reference.  The <span class="option">-t</span> option specifies
a timeout after which the agent should forget the private key.

     <p>In the first form of the command, the key indicated by <var>keyname</var>
is loaded.  If <var>keyname</var> is omitted, or <var>#</var> is supplied, then
the default key is <span class="file">$HOME/.sfs/identity</span>. If the
key supplied is a 2-Schnorr key, then <span class="command">sfskey add</span> will
attempt to load backup keys should the primary key fail due to an
unavailable signature server.

     <p><a name="index-SRP-22"></a><a name="SRP"></a> The second form of the command fetches a private key over
the network using the
<a href="http://srp.stanford.edu/">SRP</a> protocol.  SRP
lets users establish a secure connection to a server without remembering
its public key.  Instead, to prove their identities to each other, the
user remembers a secret password and the server stores a one-way
function of the password (also a secret).  SRP addresses the fact that
passwords are often poorly chosen; it ensures that an attacker
impersonating one of the two parties cannot learn enough information to
mount an off-line password guessing attack&mdash;in other words, the
attacker must interact with the server or user on every attempt to guess
the password.

     <p>The <span class="command">sfskey update</span>, <span class="command">sfskey register</span>,
<span class="command">sfskey 2gen</span> and <span class="command">sfskey 2edit</span> commands let users
store their private keys on servers, and retrieve them using the
<span class="command">add</span> command.  The private key is stored in encrypted form,
using the same password as the SRP protocol (a safe design as the server
never sees any password-equivalent data).

     <p>Because the second form of <span class="command">sfskey add</span> establishes a secure
connection to a server, it also downloads the servers HostID securely
and creates a symbolic link from <span class="file">/sfs/</span><var>hostname</var> to the
server's self-certifying pathname.

     <p>When invoking <span class="command">sfskey add</span> with the SRP syntax, <span class="command">sfskey</span>
will ask for the user's password with a prompt of the following form:

     <pre class="example">          Passphrase for <var>user</var>@<var>servername</var>/<var>nbits</var>:
     </pre>
     <p><var>user</var> is simply the username of the key being fetched from the
server.  <var>servername</var> is the name of the server on which the user
registered his SRP information.  It may not be the same as the
<var>hostname</var> argument to <span class="command">sfskey</span> if the user has supplied a
hostname alias (or CNAME) to <span class="command">sfskey add</span>.  Finally, <var>nbits</var>
is the size of the prime number used in the SRP protocol.  Higher values
are more secure; 1,024 bits should be adequate.  However, users should
expect always to see the same value for <var>nbits</var> (otherwise, someone
may be trying to impersonate the server).

     <br><dt><span class="samp">sfskey certclear</span><dd>Clears the list of certification programs the agent runs. 
See <a href="#certprog">certprog</a>, for more details on certification programs.

     <br><dt><span class="samp">sfskey certlist [-q]</span><dd>Prints the list of certification programs the agent runs. 
See <a href="#certprog">certprog</a>, for more details on certification programs.

     <p><a name="index-Dynamic-server-authentication-23"></a><a name="certprog"></a>
<br><dt><span class="samp">sfskey certprog [-p </span><var>prefix</var><span class="samp">] [-f </span><var>filter</var><span class="samp">] [-e </span><var>exclude</var><span class="samp">] </span><var>prog</var><span class="samp"> [</span><var>arg</var><span class="samp"> ...]</span><dd>The <span class="command">certprog</span> command registers a command to be run to lookup
<var>HostID</var>s on the fly in the <span class="file">/sfs</span> directory.  This mechanism can be
used for <dfn>dynamic server authentication</dfn>&mdash;running code to lookup
<var>HostID</var>s on-demand.  When you reference the file
<span class="file">/sfs/</span><var>prefix</var><span class="file">/</span><var>name</var>, your agent will run the command:

     <pre class="example">          <var>prog</var> <var>arg</var> ... <var>name</var>
     </pre>
     <p>If the program succeeds and prints <var>dest</var> to its standard output,
the agent will then create a symbolic link:

     <pre class="example">          /sfs/<var>prefix</var>/<var>name</var> -&gt; <var>dest</var>
     </pre>
     <p>The <span class="option">-p</span> flag can be omitted, and the link is
<span class="samp">/sfs/</span><var>name</var><span class="samp"> -&gt; </span><var>dest</var>.  <var>prefix</var> can be more than one
directory deep (i.e., a series of path components separated by
<span class="samp">/</span>).  If so, the first certification program whose prefix matches
at the beginning of <var>prefix</var> is run.  The remaining path components
are passed to <var>prog</var>.  For example:

     <pre class="example">          NEED EXAMPLE
     </pre>
     <p><var>filter</var> is a perl-style regular expression.  If it is specified,
then <var>name</var> must contain it for the agent to run <var>prog</var>. 
<var>exclude</var> is another regular expression, which, if specified,
prevents the agent from running <var>prog</var> on <var>name</var>s that contain
it (regardless of <var>filter</var>).

     <p><a name="index-Certification-paths-24"></a><a name="index-_0040command_007bdirsearch_007d-25"></a>The program <span class="command">dirsearch</span> can be used with <span class="command">certprog</span> to
configure <dfn>certification paths</dfn>&mdash;lists of directories in which to
look for symbolic links to <var>HostID</var>s.  The usage is:

     <pre class="example">          dirsearch [-clpq] <var>dir1</var> [<var>dir2</var> ...] <var>name</var>
     </pre>
     <p><span class="command">dirsearch</span> searches through a list of directories <var>dir1</var>,
<var>dir2</var>, <small class="dots">...</small> until it finds one containing a file called
<var>name</var>, then prints the pathname <var>dir</var><span class="samp">/</span><var>name</var>.  If it
does not find a file, <span class="command">dirsearch</span> exits with a non-zero exit
code.  The following options affect <span class="command">dirsearch</span>'s behavior:

          <dl>
<dt><span class="option">-c</span><dd>Print the contents of the file to standard output, instead of its
pathname.

          <br><dt><span class="option">-l</span><dd>Require that <var>dir</var><span class="samp">/</span><var>name</var> be a symbolic link, and print
the path of the link's destination, rather than the path of the link
itself.

          <br><dt><span class="option">-p</span><dd>Print the path <var>dir</var><span class="samp">/</span><var>name</var>.  This is the default
behavior anyway, so the option <span class="option">-p</span> has no effect.

          <br><dt><span class="option">-q</span><dd>Do not print anything.  Exit abnormally if <var>name</var> is not found in
any of the directories. 
</dl>

     <p>As an example, to lookup self-certifying pathnames in the directories
<span class="file">$HOME/.sfs/known_hosts</span> and <span class="file">/mit</span>, but only accepting links
in <span class="file">/mit</span> with names ending <span class="file">.mit.edu</span>, you might execute the
following commands:

     <pre class="example">          % sfskey certprog dirsearch $HOME/.sfs/known_hosts
          % sfskey certprog -f '\.mit\.edu$' /mnt/links
     </pre>
     <br><dt><span class="samp">sfskey confclear</span><dd>Clears the confirmation program that the agent runs. 
See <a href="#confprog">confprog</a>, for more details on confirmation programs.

     <br><dt><span class="samp">sfskey conflist [-q]</span><dd>Prints the confirmation program that the agent runs. 
See <a href="#confprog">confprog</a>, for more details on confirmation programs.

     <p><a name="confprog"></a>
<br><dt><span class="samp">sfskey confprog </span><var>prog</var><span class="samp"> [</span><var>arg</var><span class="samp"> ...]</span><dd>The <span class="command">confprog</span> command registers a command to be run by the agent
when it receives an authentication request.  The agent provides the program
with the following command line arguments: the machine making the request,
the machine that the requestor wants to access, the service (e.g., file
system, remote execution facility), the current key that the agent will try
signing with, and a list of all of the keys that the agent has available. 
If the confirmation program returns a zero exit status, the agent will
sign with the current key; otherwise, it will refuse to sign with that key
and will try the next available one.

     <p>The confirmation program can be very simple (always answer yes, for
example), or quite complex.  SFS comes with an example confirmation program
written in Python/GTK2 (<span class="file">confirm.py</span>).  When called, the script can pop
up a dialog box which asks the user what he wants to do with the request. 
The user has several options: reject, accept, accept and allow all futures
request from the requesting machine to access the named machine, accept and
allow access from requestor to any machine in the named machine's domain,
or accept and allow access from requestor to any machine.  The script saves
the user's preferences in a data file which it consults on subsequent
invocations.  If the user has chosen to accept a particular request
automatically, the script returns zero (success) without popping up a dialog
box.

     <p>Confirmation programs allow the user to manage trust policies when working
with machines that are trusted to different degrees.  For example, a user
might trust the machine on his lan but want to manually confirm requests
from machines in a shared compute cluster.

     <br><dt><span class="samp">sfskey delete </span><var>keyname</var><dd>Deletes private key <var>keyname</var> from the agent (reversing the effect
of an <span class="command">add</span> command).

     <br><dt><span class="samp">sfskey deleteall</span><dd>Deletes all private keys from the agent.

     <br><dt><span class="samp">sfskey edit [-LP] [-o </span><var>keyname</var><span class="samp">] [-c </span><var>cost</var><span class="samp">] [-l </span><var>label</var><span class="samp">] [</span><var>keyname</var><span class="samp">]</span><dd>Changes the passphrase, passphrase &ldquo;cost&rdquo;, or name of a public key. 
Can also download a key from a remote server via SRP and store it in a
file.

     <p><var>keyname</var> can be a file name, or it can be of the form
<span class="samp">[</span><var>user</var><span class="samp">]@</span><var>server</var>, in which case <span class="command">sfskey</span> will
fetch the key remotely and <var>outfile</var> must be specified.  If
<var>keyname</var> is unspecified the default is <span class="file">$HOME/.sfs/identity</span>. 
If <var>keyname</var> is <span class="file">#</span>, then <span class="command">sfskey edit</span> will search
for the next appropriate keyname in <span class="file">$HOME/.sfs/authkeys</span>.  In this case,
<span class="command">sfskey edit</span> will update <span class="file">$HOME/.sfs/identity</span> to point to
this new key by default.

     <p>The options are:

          <dl>
<dt><span class="option">-L</span><dd>Does not set symlink in the case that <var>keyname</var> is <span class="file">#</span>.

          <br><dt><span class="option">-P</span><dd>Removes any password from the key, so that the password is stored on
disk in unencrypted form.

          <br><dt><span class="option">-o </span><var>keyname</var><dd>Specifies the file to which the edited key should be written.  A
<var>keyname</var> of <span class="file">#</span> implies that <span class="command">sfskey edit</span> should
generate the next available default key in <span class="file">$HOME/.sfs/authkeys</span>. 
A <var>keyname</var> of the form <var>prefix</var><span class="file">#</span> implies that
<span class="command">sfskey edit</span> should generate the next available key in
<span class="file">$HOME/.sfs/authkeys</span> with the prefix <var>prefix</var>.  A <var>keyname</var>
of the form <var>prefix</var><span class="file">#</span><var>suffix</var> implies that
<span class="command">sfskey edit</span> should make a key named
<span class="file">$HOME/.sfs/authkeys/</span><var>prefix</var><span class="file">#</span><var>suffix</var>.

          <br><dt><span class="option">-c </span><var>cost</var><dd>Override the default computational cost of processing a password, or
<span class="samp">PwdCost</span>, <a href="#pwdcost">pwdcost</a>.

          <br><dt><span class="option">-l </span><var>label</var><dd>Specifies the label of the key that shows up in <span class="command">sfskey list</span>. 
</dl>

     <br><dt><span class="samp">sfskey 2edit -[Smp] [-l </span><var>label</var><span class="samp">] [-S | -s </span><var>srpfile</var><span class="samp">] [</span><var>keyname1</var> <var>keyname2</var><span class="samp"> ...]</span><dd>Refreshes a 2-Schnorr key by re-sharing a secret between a server
and a client. In the case of a compromised client or server, it is
recommended to refresh a 2-Schnorr key with this command.  If both
the client and the server have been compromised, a refresh will be
of little use.

     <p>Use <span class="command">sfskey 2edit</span> by supplying the keys that you wish to have
updated.  Keynames are given in standard <span class="command">sfskey</span> style.  Keynames
must be either remote keynames (i.e., contain a <span class="file">@</span> but no <span class="file">#</span>
character) or stored in the standard keys directory (i.e., contain a <span class="file">#</span>
but no <span class="file">/</span> character).  For remote keys, SRP will be used to
download the key from the server, and the updated, encrypted client private
keyhalf will be written back to the server along with the new server
keyhalf.  No file will be saved locally.  For keys stored in
<span class="file">$HOME/.sfs/authkeys</span>, <span class="command">sfskey 2edit</span> will update the
server private keyhalf, and write the corresponding client private
keyhalf out to <span class="file">$HOME/.sfs/authkeys</span> under a new filename.  By default,
<span class="command">sfskey 2edit</span> will also write the new encrypted client private
keyhalf back to the server for later SRP retrieval.

     <p>If no key is specified, the default key, <span class="file">$HOME/.sfs/identity</span> is
assumed.

          <dl>
<dt><span class="option">-E</span><dd>Do not update the encrypted private client key stored on the server.

          <br><dt><span class="option">-S</span><dd>Do not update SRP information on the server.  This option cannot be used
if some of the keynames specified are for remote keys.

          <br><dt><span class="option">-m</span><dd>Refresh multiple keys.  If you have multiple private splits of the same
private key, this flag will automatically update them all, given that
you've specified one of them.  If you run <span class="command">sfskey 2edit -m</span>,
with no additional arguments or keynames, <span class="command">sfskey</span> will refresh
all current default keys.

          <br><dt><span class="option">-p</span><dd>Change password before writing keys out to disk or server.

          <br><dt><span class="option">-l </span><var>label</var><dd>Specifies the label of the key that shows up in <span class="command">sfskey list</span>.

          <br><dt><span class="option">-s </span><var>srpfile</var><dd>Get SRP parameters from the file <var>srpfile</var>. 
</dl>

     <br><dt><span class="samp">sfskey gen [-KP] [-b </span><var>nbits</var><span class="samp">] [-c </span><var>cost</var><span class="samp">] [-l </span><var>label</var><span class="samp">] [</span><var>keyname</var><span class="samp">]</span><dd>Generates a new Rabin public/private key pair and stores it in <var>keyname</var>. 
It omitted <var>keyname</var> defaults to the next available Rabin key
in <span class="file">$HOME/.sfs/authkeys</span>.  If <var>keyname</var> contains a <span class="file">/</span>
character, it will be treated as a regular Unix file.  If <var>keyname</var>
is of the form <var>prefix</var><span class="file">#</span>, <span class="command">sfskey gen</span> will look for
the next available Rabin key in <span class="file">$HOME/.sfs/authkeys</span> with the
prefix <var>prefix</var>.  If <var>keyname</var> contains a non-terminal <span class="file">#</span>
character, it will be treated as a fully-specified keyname to be saved in
<span class="file">$HOME/.sfs/authkeys</span>.

     <p>Note that <span class="command">sfskey gen</span> is only useful for generating Rabin keys. 
Use either <span class="command">sfskey register</span> or <span class="command">sfskey 2gen</span> to
generate 2-Schnorr keys.

          <dl>
<dt><span class="option">-K</span><dd>By default, <span class="command">sfskey gen</span> asks the user to type random text with
which to seed the random number generator.  The <span class="option">-K</span> option
suppresses that behavior.

          <br><dt><span class="option">-P</span><dd>Specifies that <span class="command">sfskey gen</span> should not ask for a passphrase and
the new key should be written to disk in unencrypted form.

          <br><dt><span class="option">-b </span><var>nbits</var><dd>Specifies that the public key should be <var>nbits</var> long.

          <br><dt><span class="option">-c </span><var>cost</var><dd>Override the default computational cost of processing a password, or
<span class="samp">PwdCost</span>, <a href="#pwdcost">pwdcost</a>.

          <br><dt><span class="option">-l </span><var>label</var><dd>Specifies the label of the key that shows up in <span class="command">sfskey list</span>. 
Otherwise, the user will be prompted for a name. 
</dl>

     <br><dt><span class="samp">sfskey 2gen [-BEKP] [-a {</span><var>hostid</var><span class="samp"> | -}] [-b </span><var>nbits</var><span class="samp">] [-c </span><var>cost</var><span class="samp">] [-k </span><var>okeyname</var><span class="samp">] [-l </span><var>label</var><span class="samp">] [-S | -s </span><var>srpfile</var><span class="samp">] [-w </span><var>wkeyfile</var><span class="samp">] [</span><var>nkeyname</var><span class="samp">]</span><dd>Generates a new 2-Schnorr keypair for each of the servers specified by
the <span class="option">-a</span> flag.  All keypairs will correspond to the same
public key.  The new keys will be saved locally to the files given
by <var>nkeyname</var> in the usual fashion: if <var>nkeyname</var> is of the
form <var>prefix</var>#, then <span class="command">sfskey 2gen</span> will look for the next
available 2-Schnorr key in <span class="file">$HOME/.sfs/authkeys</span> with the prefix
<var>prefix</var>.  If no <var>nkeyname</var> is given, it will find the next
available keyname in <span class="file">$HOME/.sfs.authkeys</span> with the default
prefix (<var>user</var>@<var>host</var>).

     <p>Note that by default, this operation will update the public key, the
encrypted private key, the SRP information, and the server private key
share on all of the servers given.  Specify <span class="option">-BES</span> to suppress
updates of these fields.

          <dl>
<dt><span class="option">-a -</span><br><dt><span class="option">-a </span><var>hostid</var><dd>Can be specified arbitrarily many times, once for each server that will
accept the server private half of the 2-Schnorr key being generated.  Note
that the same public key will be used for all servers.  To specify the local
host, use the first syntax.  If SRP is used to download a key from host
<var>host</var> (e.g., <span class="option">-k </span><var>user</var><span class="option">@</span><var>host</var>), then you can specify
that host by its simple hostname (e.g., <span class="option">-a </span><var>host</var>).  If SRP
was not used to connect to a host <var>host</var>, then <span class="option">-a</span> requires
a complete SFS host identifier (i.e., @<var>Location</var>,<var>HostID</var>).

          <br><dt><span class="option">-B</span><dd>Do not update the public key on the given servers.

          <br><dt><span class="option">-E</span><dd>Do not update the encrypted private key field on the given servers.

          <br><dt><span class="option">-K</span><dt><span class="option">-P</span><dt><span class="option">-c </span><var>cost</var><dt><span class="option">-l </span><var>label</var><dt><span class="option">-s </span><var>srpfile</var><dd>See <span class="command">sfskey gen</span>.  These options behave similarly.

          <br><dt><span class="option">-S</span><dd>Do not update the SRP information on the server.

          <br><dt><span class="option">-b </span><var>nbits</var><dd>Specifies the number of bits for the 2-Schnorr modulus p.  The security of
2-Schnorr is related to the discrete log problem over Z_p*; values over 1024
are suggested for this parameter, and reasonable defaults are chosen if
this parameter is not specified.

          <br><dt><span class="option">-k </span><var>keyname</var><dd>Specify this option arbitrarily many times to keys into memory for
<span class="command">sfskey</span>.  By default, all keys from <span class="file">$HOME/.sfs/authkeys</span>
are loaded and hashed.  Remote keys and local keys in non-standard
locations can be loaded into the hash with this option.  The keys
will in turn be used to authenticate you to the servers that you
intend to update.

          <br><dt><span class="option">-w </span><var>wkeyfile</var><dd>Save the complete Schnorr key (both halves) to the file given.  Note
that it is possible to non-interactively sign with this key, so it is
advised that it not be stored on network-accessible media.  The
intended use for this option is to allow saving of both halves to a
floppy disk or to a CD-R, so that in a worst case scenario, the original
key is still recoverable. 
</dl>

     <br><dt><span class="samp">sfskey gethash [-6p] </span><var>keyname</var><dd>Retrieves a public key specified by <var>keyname</var>, which can be local (from
a local file) or remote (from an authentication server).  Remote <var>keyname</var>s
can contain fully-specified self-certifying hostnames, or simple DNS names.  In
the latter case, <span class="command">sfskey</span> uses SRP to establish a secure connection to
the authentication server.

          <dl>
<dt><span class="option">-6</span><dd>Display the hash in base-64 encoding. 
</dl>

     <br><dt><span class="samp">sfskey group [-a </span><var>key</var><span class="samp">] [-E] [-C] [-L </span><var>version</var><span class="samp">] [-m {+|-}</span><var>membername</var><span class="samp">] [-o {+|-}</span><var>ownername</var><span class="samp">] </span><var>groupname</var><dd>Retrieves, creates, and modifies group lists on an authentication server. 
<var>groupname</var> is the name of the group, which can take an optional DNS
hostname or self-certifying hostname.  Given a simple DNS hostname, the
server will attempt SRP to retrieve the server's public key.  Using the
<span class="option">-a</span> is another way to retrieve the key.

     <p>With no options, <span class="command">sfskey</span> will query the authentication server for
the group and print out the result.  The group owners and members listed
will be exactly as they appear in the authentication server's database. 
The various options are described below.

          <dl>
<dt><span class="option">-a </span><var>key</var><dd>This option can be supplied arbitrarily many times, once for each key that
should be loaded into <span class="command">sfskey</span> for this session.  Keynames are
specified as described above, and can be remote (via SRP) or the path to a
local file.  Usually it will not be necessary to specify keys in the keys
directory (<span class="file">$HOME/.sfs/authkeys</span>) as they are considered automatically.

          <br><dt><span class="option">-E</span><dd>With this option, <span class="command">sfskey</span> will ask the authentication
server to &ldquo;expand&rdquo; the owners and members lists first by computing the
transitive closure of all groups and remote users.  The expanded group
will contain only public key hashes and user names (local to the remote
authentication server).

          <br><dt><span class="option">-C</span><dd>This option tells <span class="command">sfskey</span> to create a new group called
<var>groupname</var>.  If the group already exists, <span class="command">sfskey</span> returns
an error.

          <br><dt><span class="option">-L</span><dd>This option tells <span class="command">sfskey</span> to retrieve a group's changelog beginning
at version <var>version</var> up through the most recent version.  The changelog
contains the updates made to the group's members list, plus the group's
current refresh and timeout values.

          <br><dt><span class="option">-m {+|-}</span><var>membername</var><dt><span class="option">-o {+|-}</span><var>ownername</var><dd>This option tells <span class="command">sfskey</span> to add (+) or subtract (-) the given
member or owner name to or from the given group.  <var>membername</var>s and
<var>ownername</var>s must be of the form "u=&lt;user&gt;", "g=&lt;group&gt;" or
"p=&lt;pkhash&gt;".  The "&lt;user&gt;" and "&lt;group&gt;" names can be local or remote,
but remote names must contain the fully-qualified self-certifying hostname. 
Duplicate member names and owner names are removed from the group before
it is updated.  Removals of names that don't exists on the given list
are ignored.  This option may be given more than once. 
</dl>

     <br><dt><span class="samp">sfskey help</span><dd>Lists all of the various <span class="command">sfskey</span> commands and their usage.

     <br><dt><span class="samp">sfskey hostid </span><var>Location</var><dt><span class="samp">sfskey hostid </span><var>Location</var><tt>%</tt><var>port</var><dt><span class="samp">sfskey hostid -</span><dd>Retrieves a self-certifying pathname insecurely over the network and
prints <span class="samp">@</span><var>Location</var><span class="samp">,</span><var>HostID</var>
or <span class="samp">@</span><var>Location</var><tt>%</tt><var>port</var><span class="samp">,</span><var>HostID</var> to standard output.  If
<var>Location</var> is simply <span class="samp">-</span>, returns the name of the current
machine, which is not insecure.

          <dl>
<dt><span class="option">-s </span><var>service</var><dd>The default service is file service, <span class="samp">sfs</span> (except when using
<span class="samp">-</span>).  This option selects a different SFS service.  Possible
values for <var>service</var> are <span class="samp">sfs</span>, <span class="samp">authserv</span>, and
<span class="samp">rex</span>. 
</dl>

     <br><dt><span class="samp">sfskey kill</span><dd>Kill the agent.

     <br><dt><span class="samp">sfskey list [-ql]</span><dd>List the public keys whose private halves the the agent holds.

          <dl>
<dt><span class="option">-q</span><dd>Suppresses the banner line explaining the output.

          <br><dt><span class="option">-l</span><dd>Lists the actual value of public keys, in addition the the names of the
keys. 
</dl>

     <br><dt><span class="samp">sfskey norevokeset </span><var>HostID</var><span class="samp"> ...</span>
<br><dt><span class="samp">sfskey norevokelist</span>
<br><dt><span class="samp">sfskey passwd [-Kp] [-S | -s </span><var>srpfile</var><span class="samp">] [-b </span><var>nbits</var><span class="samp">] [-c </span><var>cost</var><span class="samp">] [-l </span><var>label</var><span class="samp">] [</span><var>arg1</var><span class="samp">] [</span><var>arg2</var><span class="samp">] ...</span><dd><a name="sfskey-passwd"></a>
The <span class="command">sfskey passwd</span> command is a high-level command for &ldquo;changing
passwords&rdquo; in SFS.  In the case of proactive keys, <span class="command">sfskey passwd</span>
will simply refresh keys via <span class="command">sfskey 2edit</span> functionality.  In
the case of Rabin keys, <span class="command">sfskey passwd</span> generates a new Rabin
key and updates the given servers. By default, <span class="command">sfskey passwd</span>
assumes standard Rabin keys, and thus treats <var>arg-i</var> as
[<var>user</var>][@]<var>host</var> arguments.  If <var>host</var> is a regular
hostname, then SRP will be required to authenticate the host.  If <var>host</var>
is a full SFS pathname, then <span class="command">sfskey passwd</span> will look for keys
in <span class="file">$HOME/.sfs/authkeys</span> that can authenticate the user to that particular
server.  In the case of proactive 2-Schnorr keys, <span class="command">sfskey passwd</span>
will treat <var>arg-i</var> as local or remote keynames.

     <p>If no options or arguments are given, <span class="command">sfskey passwd</span> will look
to the default key given by <span class="file">$HOME/.sfs/identity</span>.  If the default key
is a proactive 2-Schnorr key, then all current 2-Schnorr keys in
<span class="file">.sfs/authkeys</span> are refreshed.  If the default key is a Rabin key,
then the users key on the local machine is updated.

          <dl>
<dt><span class="option">-p</span><dd>Specifies proactive mode.  Will treat arguments <var>arg1</var> through
<var>arg-n</var> as keynames, whether local or remote.  By default,
<span class="command">sfskey passwd</span> operates under the assumption that the key to
update is a Rabin key.

          <br><dt><span class="option">-K</span><dt><span class="option">-S</span><dt><span class="option">-s </span><var>srpfile</var><dt><span class="option">-b </span><var>nbits</var><dt><span class="option">-c </span><var>cost</var><dt><span class="option">-l </span><var>label</var><dd>These options are the same as for <span class="command">sfskey gen</span>.  Briefly,
<span class="option">-S</span> turns of SRP, <span class="option">-K</span> disables keyboard randomness
query, <span class="option">-s</span> is used to supply an SRP parameters file and is
mutually exclusive with <span class="option">-S</span>, <span class="option">-b</span> specifies the
size of the key in bits, <span class="option">-c</span> specifies the secret key
encryption cost, and <span class="option">-l</span> specifies the label for the key,
as seen in <span class="command">sfskey list</span>. 
</dl>

     <br><dt><span class="samp">sfskey register [-fgpPK] [-S | -s </span><var>srpfile</var><span class="samp">] [-b </span><var>nbits</var><span class="samp">] [-c </span><var>cost</var><span class="samp">] [-u </span><var>user</var><span class="samp">] [-l </span><var>label</var><span class="samp">] [-w </span><var>filename</var><span class="samp">] [</span><var>keyname</var><span class="samp">]</span><dd><a name="sfskey-register"></a>
The <span class="command">sfskey register</span> command lets users who are logged into an
SFS file server register their public keys with the file server for the
first time.  Subsequent changes to their public keys can be
authenticated with the old key, and must be performed using
<span class="command">sfskey update</span> or <span class="command">sfskey 2gen</span>.  The superuser can also use
<span class="command">sfskey register</span> when creating accounts.

     <p><var>keyname</var> is the private key to use.  If <var>keyname</var> does not exist and
is a pathname, <span class="command">sfskey</span> will create it.  The default <var>keyname</var> is
<span class="file">$HOME/.sfs/identity</span>, unless <span class="option">-u</span> is used, in which case
the default is to generate a new key in the current directory.  For keys
that contain the special trailing character <span class="file">#</span>, <span class="command">sfskey</span>
will implicitly determine whether the user intends to generate or access
a key.  If the command is invoked as root with the <span class="option">-u</span> flag, then
generation is assumed.  Similarly, if any of the options <span class="option">-bcgp</span>
are used, generation is assumed.  Otherwise, <span class="command">sfskey</span> will first
attempt to access the most recent key matching <var>keyname</var>, and then will
revert to generation if the access fails.

     <p>If a user wishes to reuse a public key already registered with another
server, the user can specify <var>user</var><span class="samp">@</span><var>server</var> for
<var>keyname</var>.

          <dl>
<dt><span class="option">-f</span><dd>Force reregistration.  Ordinarily, <span class="command">sfskey gen</span> will fail if a
record for the given user already exists on the server.

          <br><dt><span class="option">-g</span><dd>Force key generation.  When using keynames of the form
<var>prefix</var><span class="file">#</span>, <span class="command">sfskey register</span> will always generate
then next available key with the prefix <var>prefix</var> in the standard
keys directory (<span class="file">$HOME/.sfs/authkeys</span>).  If <span class="command">sfskey
register</span> is being run as root with the <span class="option">-u</span> option, then
access to the standard keys directory <span class="file">$HOME/.sfs/authkeys</span> will
not be allowed.  Hence, the key will simply be generated in the
current directory.

          <br><dt><span class="option">-p</span><dd>Generate a new proactive 2-Schnorr key.  Implies the <span class="option">-g</span> flag.

          <br><dt><span class="option">-K</span><dt><span class="option">-P</span><dt><span class="option">-l </span><var>label</var><dt><span class="option">-b </span><var>nbits</var><dt><span class="option">-c </span><var>cost</var><dt><span class="option">-s </span><var>srpfile</var><dd>These options are the same as for <span class="command">sfskey gen</span>.  <span class="option">-K</span> and
<span class="option">-b</span> have no effect if the key already exists.  They all imply the
<span class="option">-g</span> flag. If <span class="option">-p</span> is given, then <var>-b</var> will specify
the size of the modulus <var>p</var> used in 2-Schnorr.  Without <span class="option">-p</span>,
<span class="option">-b</span> will specify the size of <var>pq</var> in Rabin.

          <br><dt><span class="option">-S</span><dd>Do not register any SRP information with the server&mdash;this will prevent
the user from using SRP to connect to the server, but will also prevent
the server from gaining any information that could be used by an
attacker to mount an off-line guessing attack on the user's password.

          <br><dt><span class="option">-u </span><var>user</var><dd>When <span class="command">sfskey register</span> is run as root, specifies a particular
user to register.

          <br><dt><span class="option">-w </span><var>filename</var><dd>When generating a proactive key, saves the complete key out to
the given file.  Will raise an error if supplied without the <span class="option">-p</span>
flag.  For security reasons, this should only be used when saving to
removable media (e.g., <span class="file">/floppy/complete-key-2</span>).  It is a substantial
security risk to leave the complete key on a file system that might
be compromised. 
</dl>

     <p><span class="file">sfsauthd_config</span> must have a <span class="samp">Userfile</span> with the
<span class="option">-update</span> and <span class="option">-passwd</span> options to enable use of the
<span class="command">sfskey register</span>, <a href="#sfsauthd_005fconfig">sfsauthd_config</a>.

     <br><dt><span class="samp">sfskey reset</span><dd>Clear the contents of the <span class="file">/sfs</span> directory, including all symbolic
links created by <span class="command">sfskey certprog</span> and <span class="command">sfskey add</span>, and
log the user out of all file systems.

     <p>Note that this is not the same as deleting private keys held by the
agent (use <span class="command">deleteall</span> for that).  In particular, the effect of
logging the user out of all file systems will likely not be
visible&mdash;the user will automatically be logged in again on-demand.

     <br><dt><span class="samp">sfskey revokegen [-r </span><var>newkeyfile</var><span class="samp"> [-n </span><var>newhost</var><span class="samp">]] [-o </span><var>oldhost</var><span class="samp">] </span><var>oldkeyfile</var>
<br><dt><span class="samp">sfskey revokelist</span>
<br><dt><span class="samp">sfskey revokeclear</span>
<br><dt><span class="samp">sfskey revokeprog [-b [-f </span><var>filter</var><span class="samp">] [-e </span><var>exclude</var><span class="samp">]] </span><var>prog</var><span class="samp"> [</span><var>arg</var><span class="samp"> ...]</span>
<br><dt><span class="samp">sfskey select [-f] </span><var>keyname</var><dd>Select the given key as the default key; set <span class="file">$HOME/.sfs/identity</span>
to point to the key given by <var>keyname</var>.  It cannot be an SRP key.

          <dl>
<dt><span class="option">-f</span><dd>Force overwrite.  If current <span class="file">$HOME/.sfs/identity</span> is a regular
file, <span class="command">sfskey select</span> will overwrite it. 
</dl>

     <br><dt><span class="samp">sfskey sesskill </span><var>remotehost</var><dd>Kill the <span class="command">rex</span> session to the server specified by <var>remotehost</var>,
where <var>remotehost</var> is any unique prefix of the remote host's
self-certifying hostname (found under the "TO" column in the output to
<span class="command">sfskey sesslist</span>).

     <br><dt><span class="samp">sfskey sesslist</span><dd>List the <span class="command">rex</span> sessions that the agent is maintaining.

     <br><dt><span class="samp">sfskey srpgen [-b </span><var>nbits</var><span class="samp">] file</span><dd>Generate a new <span class="file">sfs_srp_params</span> file, <a href="#sfs_005fsrp_005fparams">sfs_srp_params</a>.

     <br><dt><span class="samp">sfskey srpclear</span><dd>Clears the in-memory cache of server self-certifying hostnames built
from SRP results.  See <a href="#srplist">srplist</a>, for more details on this cache.

     <p><a name="srplist"></a>
<br><dt><span class="samp">sfskey srplist</span><dd>Prints the in-memory cache of server self-certifying hostnames
built from SRP results.  This cache maps SRP names to self-certifying
hostnames.  SRP names are of the form <span class="file">user@host</span>.  Sample output
of the <span class="command">sfskey srplist</span> command might be

     <pre class="example">          % sfskey srplist
          alice@pdos.lcs.mit.edu      @amsterdam.lcs.mit.edu,bkfce6jdbmdbzfbct36qgvmpfwzs8exu
          alice@redlab.lcs            @redlab.lcs.mit.edu,gnze6vwxtwssr8mc5ibae7mtufhphzsk
          alice@ludlow.scs.cs.nyu.edu @ludlow.scs.cs.nyu.edu,hcbafipmin3eqmsgak2m6heequppitiz
     </pre>
     <p>Currently, the agent consults this cache and adds new mappings to it
when a user invokes REX with a DNS (SRP) name.  If the name is in the
agent's cache, REX will use the corresponding self-certifying hostname
to authenticate the server.  If not, REX will use SRP to fetch the
server's public key and then add a new mapping to the agent's cache.

     <br><dt><span class="samp">sfskey srpcacheprogclear</span><dd>Clears the SRP cache management program that the agent runs. 
See <a href="#srpcacheprog">srpcacheprog</a>, for more details on cache management programs.

     <br><dt><span class="samp">sfskey srpcacheproglist [-q]</span><dd>Prints the SRP cache management program that the agent runs. 
See <a href="#srpcacheprog">srpcacheprog</a>, for more details on confirmation programs.

     <p><a name="srpcacheprog"></a>
<br><dt><span class="samp">sfskey srpcacheprog </span><var>prog</var><span class="samp"> [</span><var>arg</var><span class="samp"> ...] The</span><dd><span class="command">srpcacheprog</span> command registers a command to be run by the agent in
order to manage an on-disk copy of the in-memory SRP name cache (described
above; see <a href="#srplist">srplist</a>).  The agent will invoke the SRP cache management
program with zero arguments when it wants to load the on-disk cache into
memory and exactly one argument when it wants to add a new entry to the
on-disk cache.  If no SRP cache management program is set, the agent will
simply maintain an in-memory version which will be lost when the agent
is restarted.

     <p>In the first case (load), the program output must consist of one
mapping per line.  Each mapping must consist of the SRP name followed
by a single space followed by the self-certifying
hostname. See <a href="#srplist">srplist</a>, for an example of what each of these fields
might look like.  In the second case (store), the agent's argument to
the program will consist of a single mapping, to be added to the
on-disk cache.  The mapping will have the same format described above:
the SRP name followed by a single space followed by the
self-certifying hostname (no trailing newline).

     <br><dt><span class="samp">sfskey update [-fE] [-S | -s </span><var>srp_params</var><span class="samp">] [-r </span><var>srpkey</var><span class="samp">] [-a </span><var>okeyname</var><span class="samp">] [-k </span><var>nkeyname</var><span class="samp">] </span><var>server1</var> <var>server2</var><span class="samp"> ...</span><dd>Change a user's public key and SRP information on an SFS file server. 
To change public keys, typically you should generate a new public key
and store it in <span class="file">$HOME/.sfs/identity</span>.  Then you can run
<span class="samp">sfskey update [</span><var>user</var><span class="samp">]@</span><var>host</var> for each server on which
you need to change your public key.

     <p>To authenticate you to the servers on which updates are requested,
<span class="command">sfskey update</span> will first use the keys given via <span class="option">-a</span>
arguments; it will then search keys in the standard key
directory&mdash;<span class="file">$HOME/.sfs/authkeys</span>.

     <p>At least one <var>server</var> argument is required.  As usual, the string
&ldquo;-&rdquo; denotes the localhost. The servers specified can be either
full SFS hostnames of the form [<var>user</var>]@<var>Location</var>,<var>HostId</var>,
or standard hostnames of the form [<var>user</var>@]<var>Location</var>.  In the
latter case, SRP is assumed, and the corresponding private key is
automatically loaded into <span class="command">sfskey</span>.

     <p>The new key that is being pushed to the server is given by the
<span class="option">-k</span> flag.  If this is not provided, the default key
<span class="file">$HOME/.sfs/identity</span> will be assumed.

     <p>The <span class="option">-r</span> provides a shortcut for updating SRP information, if,
for instance, the authserver has changed its realm information.  Invoking
<span class="command">sfskey update -r [</span><var>user</var><span class="command">]@</span><var>host</var> is
equivalent to <span class="command">sfskey update -k [</span><var>user</var><span class="command">]@</span><var>host</var> <var>host</var>.

     <p>Several options control <span class="command">sfskey update</span>'s behavior:

          <dl>
<dt><span class="option">-E</span><dd>Do not send encrypted secret key information to the server.

          <br><dt><span class="option">-S</span><dd>Do not send SRP information to the server&mdash;this will prevent the user
from using SRP to connect to the server, but will also prevent the
server from gaining any information that could be used by an attacker to
mount an off-line guessing attack on the user's password.  Implies
<span class="option">-E</span>

          <br><dt><span class="option">-a </span><var>okeyname</var><dd>This option can be supplied arbitrarily many times, once for each key that
should be loaded into <span class="command">sfskey</span> for this session.  Keynames are
specified as described above, and can be remote (via SRP) or the path to a
local file.  Usually it will not be necessary to specify keys in the keys
directory (<span class="file">$HOME/.sfs/authkeys</span>) as they are considered automatically.

          <br><dt><span class="option">-f</span><dd>If there is a change in SRP realm information, the <span class="option">-f</span> flag
will force an update.  Normally, the user is prompted to verify.

          <br><dt><span class="option">-k </span><var>nkeyname</var><dd>Specifies the new key to push to the server. Can be an SRP key,
a local file, or a keyname with a '#' sign, signifying a key
stored in the keys directory, <span class="file">$HOME/.sfs/authkeys</span>. If this
flag is not specified, <span class="file">$HOME/.sfs/identity</span> is assumed. 
Note that the <span class="option">-k</span> flag can be specified only once.

          <br><dt><span class="option">-r [</span><var>user</var><span class="option">][@]</span><var>host</var><dd>Update SRP information of a key on a remote host. Equivalent to
<span class="command">sfskey update -k [</span><var>user</var><span class="command">]@</span><var>host</var><span class="command"> [</span><var>user</var><span class="command">@]</span><var>host</var>. 
Cannot be used with the <span class="option">-akS</span> options.

          <br><dt><span class="option">-s</span><dd><var>srp_params</var> is the path of a file generated by <span class="command">sfskey
srpgen</span>, and specifies the parameters to use in generating SRP
information for the server.  The default is to get SRP parameters from
the server, or look in
<span class="file">/usr/local/share/sfs/sfs_srp_params</span>. 
</dl>

     <br><dt><span class="samp">sfskey user [-a </span><var>key</var><span class="samp">] </span><var>username</var><dd>Retrieves a user record from an authentication server. 
<var>username</var> is the name of the user, which can take an optional DNS
hostname or self-certifying hostname.  Given a simple DNS hostname, the
server will attempt SRP to retrieve the server's public key.  Using the
<span class="option">-a</span> is another way to retrieve the key.

     <p><span class="command">sfskey</span> will query the authentication server for the user and
print out the result.

          <dl>
<dt><span class="option">-a </span><var>key</var><dd>This option can be supplied arbitrarily many times, once for each key that
should be loaded into <span class="command">sfskey</span> for this session.  Keynames are
specified as described above, and can be remote (via SRP) or the path to a
local file.  Usually it will not be necessary to specify keys in the keys
directory (<span class="file">$HOME/.sfs/authkeys</span>) as they are considered automatically. 
</dl>

   </dl>
   <!-- @mp @end options -->
<!-- @mp @end command -->
<!-- @mp -->

<p><a name="rex"></a>

<!-- node-name,  next,  previous,  up -->
<h3 class="section">6.3 <span class="command">rex</span> reference guide</h3>

<!-- @mp -->
<!-- @mp @command{rex}{remote execution}{1} -->
<!-- @mp @synopsis -->
<!-- @mpp rex [-TAXpv] [-R @var{port}:@var{lport}] -->
<!-- @mpp @var{destination} [@var{command}] -->
<!-- @mp @end synopsis -->
<!-- @mp @description -->
<p><span class="command">rex</span> is a remote execution facility which is integrated with
SFS.  The program allows users run to run programs on a remote machine
or obtain a shell.  Like SFS file systems, remote execution servers can
be named by self-certifying path names.

<p class="noindent">The usage is as follows:

<pre class="example">     rex [-TAXpv] [-R <var>port</var>:<var>lport</var>] <var>destination</var> [<var>command</var>]
</pre>
   <p class="noindent"><var>destination</var> is one of the following:
     <ul>
<li>a self-certifying hostname (location:hostid)
<li>a self-certifying pathname (/sfs/... or /symlink-to-sfs/...) 
<li>any identifier which when processed through certification programs
will yield a self-certifying pathname
</ul>
   <!-- @mp @end description -->

<!-- @mp @options -->
<dl>
<dt><span class="option">-T</span><dd>Disable pseudo-tty allocation.

     <br><dt><span class="option">-A</span><dd>Disable SFS agent forwarding.  By default, if there is no
<span class="command">sfsagent</span> running on the remote machine, <span class="command">rex</span> will
forward agent requests back to the <span class="command">sfsagent</span> running on the
local machine (e.g., when a user accesses an SFS file system or runs
<span class="command">sfskey</span>).

     <br><dt><span class="option">-X</span><dd>Disable X forwarding.  By default, the <span class="command">rex</span> client will set up
a dummy X server which receives connections from clients on the remote
machine.  These connections are forwarded over the encrypted
<span class="command">rex</span> channel to the local X server.  <span class="command">rex</span> sets the
<span class="env">DISPLAY</span> environment variable appropriately on the remote side. 
Furthermore, X connections are authenticated using a `spoofed'
<var>MIT-MAGIC-COOKIE-1</var>.

     <br><dt><span class="option">-p</span><dd>Force <span class="command">rex</span> to connect to the <var>destination</var> even if
it cannot be resolved into a valid self-certifying path name.

     <br><dt><span class="option">-v</span><dd>Verbose mode.

     <br><dt><span class="option">-R </span><var>port</var><span class="option">:</span><var>lport</var><dd>Forward TCP connections made to <var>port</var> on the remote host to
<var>lport</var> on the local machine. 
</dl>

   <p>The <span class="command">rex</span> command supports the escape sequences listed below. 
Rex only recognizes the escape character `~' after a newline.
     <ul>
<li>. terminate connection
<li>^Z suspend connection
<li>? help message
<li>~ send the escape character
</ul>
   <!-- @mp @end options -->
<!-- @mp @end command -->
<!-- @mp @end -->

<p><a name="dirsearch"></a>

<!-- node-name,  next,  previous,  up -->
<h3 class="section">6.4 <span class="command">dirsearch</span> command</h3>

<p><a name="index-_0040command_007bdirsearch_007d-26"></a>
<!-- @mp -->
<!-- @mp @command{dirsearch}{search for file in directories}{1} -->
<!-- @mp @description -->
<span class="command">dirsearch</span> looks for a file name in one or more directories. 
<!-- @mp @end description -->
<!-- @mp @ignore -->
The usage is as follows:
<!-- @mp @end ignore -->

<!-- @mp @synopsis -->
<pre class="example">     dirsearch [-c | -l | -p | -q] <var>dir1</var> [<var>dir2</var> ...] <var>name</var>
</pre>
   <!-- @mp @end synopsis -->
<!-- @mp @description -->
<p>Starting with <var>dir1</var>, the command searches each directory
specified for a file called <var>name</var>.  If such a file is found,
<span class="command">dirsearch</span> exits with code 0 and, depending on its options,
may print the file's pathname, contents, or expanded symbolic link
contents.  If none of the directories specified contain a file
<var>name</var>, <span class="command">dirsearch</span> exits with code 1 and prints no
output. 
<!-- @mp @end description -->

<!-- @mp @examples -->
<p><span class="command">dirsearch</span> is particularly useful for SFS certification
see <a href="#certprog">certprog</a> and revocation programs.  As an example, suppose you
have a directory of symbolic links in your home directory called
<span class="file">.sfs/bookmarks</span>.  The directory might contain the
following links:
<pre class="example">     sfs.fs.net -&gt; /sfs/@sfs.fs.net,uzwadtctbjb3dg596waiyru8cx5kb4an
     sfs.nyu.edu -&gt; /sfs/@sfs.nyu.edu,hcbafipmin3eqmsgak2m6heequppitiz
</pre>
   <p class="noindent">If you execute the command:
<pre class="example">     sfskey certprog dirsearch -l ~/.sfs/bookmarks
</pre>
   <p class="noindent">Then the next time you access <span class="file">/sfs/sfs.fs.net</span>, that
pathname will automatically become a symbolic link to your bookmark. 
Moreover, the same will happen on remote machines to which you log in
with the <span class="command">rex</span> command. 
<!-- @mp @end examples -->

<!-- @mp @options -->
<p>The following mutually exclusive options affect the behavior of
<span class="command">dirsearch</span>.  If more than one option is specified, only the
last will have an effect.

     <dl>
<dt><span class="option">-c</span><dd>This option prints the contents of the file when it is found, instead
of its pathname.

     <br><dt><span class="option">-l</span><dd>This option looks for symbolic links.  The file <var>name</var> will be
ignored if it is not a symbolic link.  Furthermore, in its output
<span class="command">dirsearch</span> will expand the symbolic link.

     <br><dt><span class="option">-p</span><dd>This option says to print the pathname, which is the default anyway. 
Thus, the only effect of <span class="option">-p</span> is to undo any previous
<span class="option">-c</span>, <span class="option">-l</span>, or <span class="option">-q</span> option.

     <br><dt><span class="option">-q</span><dd>This option suppresses any output <span class="command">dirsearch</span> would print. 
The exit code still indicates whether or not the file exists. 
</dl>
   <!-- @mp @end options -->

<!-- @mp @end command -->
<!-- @mp @end -->
<p><a name="newaid"></a>

<!-- node-name,  next,  previous,  up -->
<h3 class="section">6.5 <span class="command">newaid</span> command</h3>

<!-- @mp -->
<!-- @mp @command{newaid}{Run processes with different sfsagents}{1} -->
<!-- @mp @description -->
<p>The <span class="command">newaid</span> command allows root-owned processes to access SFS
file systems using the <span class="command">sfsagent</span> of a non-root user. 
Additionally, if a system is configured to allow this,
<span class="command">newaid</span> permits non-root users to run multiple
<span class="command">sfsagent</span> processes, so that different processes owned by
that user access the SFS file system with different agents.  (When
used in The latter mode, <span class="command">newaid</span> is similar in function to
the AFS program <span class="command">pagsh</span>.)

   <p><a name="index-aid-27"></a>SFS maps file system requests to particular <span class="command">sfsagent</span>
processes using the notion of agent ID, or <dfn>aid</dfn>.  Every process
has a 64-bit aid associated with it.  Ordinarily, a process's aid is
simply its 32-bit user ID.  Thus, when a user runs <span class="command">sfsagent</span>,
both the agent and all of the users' processes have the same aid.

   <p>To allow different processes owned by the same user to have different
agents, a system administrator can reserve a range of group IDs for
the purpose of flagging different aids, <a href="#resvgids">resvgids</a>. 
(Note that after changing <span class="samp">ResvGids</span>, you must kill and restart
<span class="command">sfscd</span> for things to work properly.)  If the range of
reserved group IDs is <var>min</var><small class="dots">...</small><var>max</var>, and the <em>first</em>
element of a process's grouplist, <var>g0</var>, is at least <var>min</var> and
not more than <var>max</var>, then a process's aid is computed as
((<var>g0</var> - <var>min</var> + 1) &lt;&lt; 32) | <var>uid</var>).  The <span class="command">newaid</span>
command therefore lets people insert any of the reserved group IDs at
the start of a process's group list.

   <p>For root-owned processes, it is also possible for processes to be
associated with a non-root agent.  In this case, the reserved
<var>sfs-group</var> (as a marker) and target user's uid are actually
placed in the process's grouplist, as well as any reserved group ID to
select amongst multiple agents of the same user. 
<!-- @mp @end description -->

<!-- @mp @ignore -->
<p>The usage is:
<!-- @mp @end ignore -->

<!-- @mp @synopsis -->
<pre class="example">     newaid [-l] [-{u|U} <var>uid</var>] [-G | -g <var>gid</var>] [-C <var>dir</var>] [<var>program</var> <var>arg</var> ...]
</pre>
   <!-- @mp @end synopsis -->
<!-- @mp @description -->
<p>After making appropriate changes to its user ID and/or grouplists,
<span class="command">newaid</span> executes the <var>program</var> specified on the command
line.  If no <var>program</var> is specified, the program specified by the
environment variable <span class="env">SHELL</span> is used by default. 
<!-- @mp @end description -->

<!-- @mp @options -->
<dl>
<dt><span class="option">-l</span><dd>Run the command as a login shell.  This argument simply prepends a
<span class="samp">-</span> character to <code>argv[0]</code> when executing <var>program</var>. 
Command shells interpret this to mean that they are being being run as
login shells, and usually exhibit slightly different behavior.  (For
example <span class="command">csh</span> will execute the commands in a user's
<span class="file">.login</span> file.)

     <br><dt><span class="option">-u </span><var>uid</var><dd>For root-owned process, specifies that the <var>program</var> should be run
as root, but should be associated with the non-root agent of user
<var>uid</var>.

     <br><dt><span class="option">-U </span><var>uid</var><dd>When <span class="command">newaid</span> is invoked by a root-owned processes, this
option sets the real uid to <var>uid</var> to run <var>program</var>, instead of
running it with uid 0.  This is in itself is not sufficient to &ldquo;drop
privileges.&rdquo;  In particular, <span class="command">newaid</span> still does not make any
changes to the process gid or grouplist, beyond manipulating
aid-specific groups.  Since many root-owned processes also have
privileged groups in their grouplist, it is in general
<strong>insecure</strong> to use <span class="option">-U</span> unless you set both the gid and
the whole grouplist to something sensible (i.e., appropriately
unprivileged) before invoking <span class="command">newaid</span>.

     <p>This option is mostly of use for <span class="command">login</span>-like programs that
wish to create a session with a new aid, and do not wish to make the
<code>setuid</code> system call themselves.  As an example, the
<span class="command">rexd</span> daemon has the server's private key, yet must spawn the
<span class="command">proxy</span> program as an unprivileged user.  If it dropped
privileges before executing <span class="command">proxy</span>, unprivileged users could
send it signals, risking core dumps.  Moreover, attackers might be
able to exploit weaknesses in the operating system's <code>ptrace</code>
system call or <span class="file">/proc</span> file system to learn the private key. 
<span class="command">rexd</span> therefore runs <span class="command">proxy</span> through
<span class="command">newaid</span>, giving it the <span class="option">-U</span> option.

     <br><dt><span class="option">-g </span><var>gid</var><dt><span class="option">-G</span><dd>By default <span class="command">newaid</span> simply picks the first aid under which no
agent is yet running.  The <span class="option">-g</span> option explicitly specifies
that <var>gid</var> should be added to the start of the process's group
list (and any previous reserved gid should be removed).  <span class="option">-G</span>
says to remove any reserved gid, so that the aid of the resulting
process will just be the user's uid.

     <br><dt><span class="option">-C </span><var>dir</var><dd>Changes directory to <var>dir</var> before running <var>program</var>. 
</dl>
   <!-- @mp @end options -->

<!-- @mp @end command -->
<!-- @mp @end -->
<p><a name="ssu"></a>

<!-- node-name,  next,  previous,  up -->
<h3 class="section">6.6 <span class="command">ssu</span> command</h3>

<!-- @mp -->
<!-- @mp @command{ssu}{allow unprivileged user to become root}{1} -->
<!-- @mp @description -->
<p>The <span class="command">ssu</span> command allows an unprivileged user to become root
on the local machine without changing his SFS credentials. 
<span class="command">ssu</span> invokes the command <span class="command">su</span> to become root.  Thus,
the access and password checks needed to become root are identical to
those of the local operating system's <span class="command">su</span> command. 
<span class="command">ssu</span> also runs <span class="file">/usr/local/lib/sfs-0.8pre/newaid</span> to
alter the group list so that SFS can recognize the root shell as
belonging to the original user. 
<!-- @mp @end description -->

<!-- @mp @ignore -->
<p>The usage is as follows:
<!-- @mp @end ignore -->

<!-- @mp @synopsis -->
<pre class="example">     ssu [-f | -m | -l | -c <var>command</var>]
</pre>
   <!-- @mp @end synopsis -->
<!-- @mp @options -->
<dl>
<dt><span class="option">-f</span><dt><span class="option">-m</span><dd>These options are passed through to the <span class="command">su</span> command.

     <br><dt><span class="option">-l</span><dd>This option causes the newly spawned root shell to behave like a login
shell.

     <br><dt><span class="option">-c </span><var>command</var><dd>Tells <span class="command">ssu</span> to tell <span class="command">su</span> to run <var>command</var> rather
than running a shell. 
</dl>
   <!-- @mp @end options -->

<!-- @mp @bugs -->
<p>Note, <span class="command">ssu</span> does not work on some versions of Linux because of a
bug in Linux.  To see if this bug is present, run the command <span class="samp">su
root -c ps</span>.  If this command stops with a signal, your <span class="command">su</span>
command is broken and you cannot use <span class="command">ssu</span>. 
<!-- @mp @end bugs -->
<!-- @mp @end command -->
<!-- @mp @end -->

<p><a name="sfscd"></a>

<!-- node-name,  next,  previous,  up -->
<h3 class="section">6.7 <span class="command">sfscd</span> command</h3>

<!-- @mp -->
<!-- @mp @command{sfscd}{SFS client daemon}{8} -->
<!-- @mp @synopsis -->
<pre class="example">     sfscd [-d] [-l] [-L] [-f <var>config-file</var>]
</pre>
<!-- @mp @end synopsis -->
<!-- @mp @description -->
<p><span class="command">sfscd</span> is the program to create and serve the <span class="file">/sfs</span>
directory on a client machine.  Ordinarily, you should not need to
configure <span class="command">sfscd</span> or give it any command-line options. 
<!-- @mp @end description -->

<!-- @mp @options -->
<dl>
<dt><span class="option">-d</span><dd>Stay in the foreground and print messages to standard error rather than
redirecting them to the system log.

     <br><dt><span class="option">-l</span><dd><a name="index-_0040code_007bEDEADLK_007d-28"></a><a name="index-_0040code_007bResource-deadlock-avoided_007d-29"></a>Ordinarily, <span class="command">sfscd</span> will disallow access to a server running on
the same host.  If the <var>Location</var> in a self-certifying pathname
resolves to an IP address of the local machine, any accesses to that
pathname will fail with the error <code>EDEADLK</code> (&ldquo;Resource deadlock
avoided&rdquo;).

     <p>The reason for this behavior is that SFS is implemented using NFS.  Many
operating systems can deadlock when there is a cycle in the mount
graph&mdash;in other words when two machines NFS mount each other, or, more
importantly when a machine NFS mounts itself.  To allow a machine to
mount itself, you can run <span class="command">sfscd</span> with the <span class="option">-l</span> flag. 
This may in fact work fine and not cause deadlock on non-BSD systems.

     <br><dt><span class="option">-L</span><dd>On Linux, the <span class="option">-L</span> option disables a number of kludges that work
around bugs in the kernel.  <span class="option">-L</span> is useful for people interested
in improving Linux's NFS support.

     <br><dt><span class="option">-f </span><var>config-file</var><dd>Specify an alternate <span class="command">sfscd</span> configuration file,
<a href="#sfscd_005fconfig">sfscd_config</a>.  The default, if <span class="option">-f</span> is unspecified, is
first to look for <span class="file">/etc/sfs/sfscd_config</span>, then
<span class="file">/usr/local/share/sfs/sfscd_config</span>. 
</dl>
   <!-- @mp @end options -->
<!-- @mp @end command -->
<!-- @mp @end -->

<p><a name="sfssd"></a>

<!-- node-name,  next,  previous,  up -->
<h3 class="section">6.8 <span class="command">sfssd</span> command</h3>

<!-- @mp -->
<!-- @mp @command{sfssd}{SFS server daemon}{8} -->
<!-- @mp @synopsis -->
<pre class="example">     sfssd [-d] [-S <var>sfs-config-file</var>] [-f <var>config-file</var>]
</pre>
<!-- @mp @end synopsis -->
<!-- @mp @description -->
<p><span class="command">sfssd</span> is the main server daemon run on SFS servers. 
<span class="command">sfssd</span> itself does not serve any file systems.  Rather, it acts
as a meta-server, accepting connections on TCP port 4 and passing them
off to the appropriate daemon.  Ordinarily, <span class="command">sfssd</span> passes all
file system connections to <span class="command">sfsrwsd</span>, and all user-key
management connections to <span class="command">sfsauthd</span>.  However, the
<span class="file">sfssd_config</span> file (see <a href="#sfssd_005fconfig">sfssd_config</a>) allows a great deal of
customization, including support for &ldquo;virtual servers,&rdquo; multiple
versions of the SFS software coexisting, and new SFS-related services
other than the file system and user authentication. 
<!-- @mp @end description -->

<!-- @mp @options -->
<dl>
<dt><span class="option">-d</span><dd>Stay in the foreground and print messages to standard error rather than
redirecting them to the system log.

     <br><dt><span class="option">-f </span><var>config-file</var><dd>Specify an alternate <span class="command">sfssd</span> configuration file,
<a href="#sfssd_005fconfig">sfssd_config</a>.  The default, if <span class="option">-f</span> is unspecified, is
first to look for <span class="file">/etc/sfs/sfssd_config</span>, then
<span class="file">/usr/local/share/sfs/sfssd_config</span>.

     <br><dt><span class="option">-S </span><var>sfs-config-file</var><dd>Specify an alternate name for the <span class="file">sfs_config</span> file,
<a href="#sfssd_005fconfig">sfssd_config</a>.  If <var>sfs-config-file</var> begins with a <span class="file">/</span>,
then only this file is parsed.  Otherwise, all the directories
<span class="file">/usr/local/share/sfs</span> and <span class="file">/etc/sfs</span> are searched in
order, and if no file named <var>sfs-config-file</var> is found but a file
<span class="file">sfs_config</span> is found, that file is parsed.  However, the process
does not look in <span class="file">/etc/sfs</span> if <var>sfs-config-file</var> is
found in <var>/usr/local/share/sfs</var>.  Thus, if you create a file
<span class="file">/etc/sfs/</span><var>sfs-config-file</var>, it will override
<span class="file">/etc/sfs/sfs_config</span> while still incorporating the
defaults from <var>/usr/local/share/sfs/sfs_config</var>.

   </dl>
   <!-- @mp @end options -->
<!-- @mp @end command -->
<!-- @mp @end -->

<p><a name="vidb"></a>

<!-- node-name,  next,  previous,  up -->
<h3 class="section">6.9 <span class="command">vidb</span> command</h3>

<!-- @mp -->
<!-- @mp @command{vidb}{manually edit SFS user-authentication database file}{8} -->
<!-- @mp @description -->
<p><span class="command">vidb</span> manually edits an SFS user-authentication file
see <a href="#sfs_005fusers">sfs_users</a>, acquiring locks to prevent concurrent updates from
overwriting each other.  If <span class="command">sfsauthd</span> has been compiled with
<a href="http://www.sleepycat.com/">Sleepycat database</a> support, and the
name of the file ends in <span class="file">.db/</span>, <span class="command">vidb</span> will consider the
user authentication file to be a database directory, and convert the
contents into regular ASCII text for editing.  If the name of the file
ends in <span class="file">.db</span>, <span class="file">vidb</span> assumes the user authentication file
is database file (unless the pathname corresponds to an existing
directory).  Note that database files (as opposed to directories) are
required to be read-only, and thus cannot be updated by vidb.

<!-- For database files, the supporting database files are in -->
<!-- directory @file{@value{SFSDIR}@dslash{}dbenv}. -->
<!-- Note that database files use write-ahead logging, with the logs stored -->
<!-- in the directory for supporting files.  In particular, simply -->
<!-- @emph{moving or deleting a database file can have disastrous -->
<!-- consequences} when the logs do not reflect the changes.  For instance -->
<!-- old log entries can get applied to a new file, confusingly -->
<!-- resurrecting entries from what you might think was a deleted database. -->
<!-- For this reason, we highly recommend that administrators @emph{not} -->
<!-- use database files (ending @file{.db}) for read-write user databases. -->
<!-- (For read-only ``public'' databases, it should be fine.)  Instead, -->
<!-- administrators who want something more efficient than flat text files -->
<!-- should use database directories (ending @file{.db/}), which provide a -->
<!-- better intuition for what renaming or deleting the database does. -->
<!-- @mp @end description -->
<!-- @mp @ignore -->
<p>The usage is:
<!-- @mp @end ignore -->

<!-- @mp @synopsis -->
<pre class="example">     vidb [-w] [-R] {-S | -a [-f <var>file</var>] | [-e <var>editor</var>]} <var>sfs-users-file</var>
</pre>
   <!-- @mp @end synopsis -->
<!-- @mp @options -->
<p><span class="command">vidb</span> has the following options:

     <dl>
<!-- @item -r -->
<!-- Recovers from a previous edit session.  @command{vidb} makes a copy of -->
<!-- of @var{sfs-users-file} to be edited, named by appending @file{.tmp} -->
<!-- to the file name.  If an editing session crashes, vidb will refuse to -->
<!-- run, as the old temporary file may contain useful data that should -->
<!-- not be deleted.  With @option{-r}, however, @command{vidb} removes any -->
<!-- old temporary file. -->

     <dt><span class="option">-a [-f </span><var>file</var><span class="option">]</span><dd>The <span class="option">-a</span> option <em>adds</em> SFS user records in text form to a
database.  The records are taken from standard input, or from
<var>file</var> if specified.  Records for an existing user or group will
replace the values already in the database.  Unlike <span class="command">vidb</span>'s
ordinary mode of operation, <span class="option">-a</span> does not add all records
atomically.  In the event of a system crash, some but not all of the
records may have been added to the database.  Simply re-running the
same <span class="command">vidb</span> command after a crash is perfectly safe, however,
since previously added entries will just be overwritten (by
themselves) the second time through.  For database files, because
<span class="option">-a</span> does not accumulate records into one large transaction, it
can be significantly more efficient than simply adding the records in
an editor, using <span class="command">vidb</span>'s ordinary mode of operation.

     <br><dt><span class="option">-e </span><var>editor</var><dd>Specifies the editor to use for editing the file.  The default is to
use the command specified by the environment variable <span class="env">EDITOR</span>. 
If there is no environment variable and <span class="option">-e</span> is not specified,
<span class="command">vidb</span> uses <span class="command">vi</span>.

     <br><dt><span class="option">-w</span><dd>One of the points of <span class="command">vidb</span> is to avoid concurrent edits to
the database and the corresponding inconsistencies that might result. 
Ordinarily, if the database is already being edited, <span class="command">vidb</span>
will just exit with an error message.  The <span class="option">-w</span> flag tells
<span class="command">vidb</span> to wait until it can acquire the lock on the database
before launching the editor.

     <br><dt><span class="option">-R</span><dd>Runs <em>catastrophic recovery</em> on the database environment.  (For
those familiar with Sleepycat database software, this corresponds to
the <span class="option">-c</span> flag of the <span class="command">db_recover</span> utility, or the
<code>DB_RECOVER_FATAL</code> flag of the API.)  Essentially, <span class="option">-R</span>
replays all of the database log records present in the supporting
files directory.  You may need to use this, for example, when
restoring a database from backup tapes if the log files were backed up
more recently than the entire database.  The <span class="option">-R</span> has no effect
on flat text databases, or if the <span class="option">-S</span> has been specified. 
<strong>Warning:</strong>  The authors have encountered bugs in the
catastrophic recovery code of at least some versions of the Sleepycat
database package.  As a precaution, before attempting to use
<span class="option">-R</span>, we strongly recommend salvaging whatever records possible
from the database file itself using <span class="samp">vidb -S</span>
<var>sfs-users-file</var><span class="samp">&gt;</span><span class="samp">saved_sfs_users</span>.  If, subsequently,
the <span class="option">-R</span> option corrupts the database, you can at least salvage
some of the records from the <span class="file">saved_sfs_users</span> file.

     <br><dt><span class="option">-S</span><dd>Attempt to <em>salvage</em> a database file with corrupt or lost logs by
dumping the contents of the database itself.  Ordinarily, databases
use write-ahead logging.  Before opening a database file, both
<span class="command">vidb</span> and <span class="command">sfsauthd</span> attempt to recover from any
previous incomplete transactions using the log.  The <span class="option">-S</span>
option opens and prints out the contents of a database without regard
to the log files.  This is useful if you have lost the log files or
are worried that they are corrupt, or if you wish to examine the
contents of a database you have read but not write permission to. 
Ordinarily, however, if you wish to dump the contents of a database to
standard output, use the command <span class="samp">vidb -e cat</span>
<var>sfs-users-file</var>.

   </dl>
   <!-- @mp @end options -->

<p class="noindent">Note:
<!-- @mp @bugs -->
<span class="command">vidb</span> should really recreate any publicly-readable versions
of user authentication databases (either by parsing
<span class="file">sfsauthd_config</span> for <span class="option">-pub=...</span> options to
<span class="samp">Userfile</span> directives or signaling <span class="command">sfsauthd</span>). 
Currently you must manually kill <span class="command">sfssd</span> or <span class="command">sfsauthd</span>
for this to happen.

   <p>While <span class="command">vidb</span> attempts to make the smallest number of changes
to a database, editing sessions that add or remove a large number of
records can potentially exhaust resources such as locks.  Sites with
large user databases can tune the database by creating a file called
<span class="file">DB_CONFIG</span> in the database directory. 
<!-- with supporting files (the directory -->
<!-- itself for @file{.db/} databases, and -->
<!-- @file{@value{SFSDIR}@dslash{}dbenv} for database files). -->
The specifics of the configuration file are documented in the
Sleepycat database documentation.  As an example, if performance is
slow and you run out of locks, you can set the cache size to 128MB and
increase the number of locks with the following <span class="file">DB_CONFIG</span> file:

<pre class="example">     set_cachesize 0 134217728 1
     set_lk_max_locks 50000
     set_lk_max_objects 50000
</pre>
   <p>When editing a database, <span class="command">vidb</span> creates a temporary text file
in the <span class="file">/tmp</span> directory.  For huge databases, it is conceivable
that <span class="file">/tmp</span> does not have enough space.  If this happens,
<span class="file">/tmp</span> can be overridden with the <span class="env">TMPDIR</span> environment
variable. 
<!-- @mp @end bugs -->

<!-- @mp @end command -->
<!-- @mp @end -->
<p><a name="funmount"></a>

<!-- node-name,  next,  previous,  up -->
<h3 class="section">6.10 <span class="command">funmount</span> command</h3>

<!-- @mp -->
<!-- @mp @command{funmount}{forcibly unmount a file system}{8} -->
<!-- @mp @ignore -->
<p>The <span class="command">funmount</span> command is executed as follows:
<!-- @mp @end ignore -->

<!-- @mp @synopsis -->
<pre class="example">     funmount <var>path</var>
</pre>
   <!-- @mp @end synopsis -->
<!-- @mp @description -->
<p><span class="command">funmount</span> forcibly attempts to unmount the file system
mounted on <var>path</var>.  It is roughly equivalent to running
<span class="samp">umount -f </span><var>path</var>.  However, on most operating systems the
<span class="command">umount</span> command does a great deal more than simply execute
the <code>unmount</code> system call&mdash;for instance it may attempt to read
the attributes of the file system being unmounted and/or contact a
remote NFS server to notify it of the unmount operation.  These extra
actions make <code>umount</code> hang when a remote NFS server is
unavailable or a loopback server has crashed, which in turn causes the
client to become ever more wedged.  <span class="command">funmount</span> can avoid such
situations when you are trying to salvage a machine with bad NFS
mounts without rebooting it. 
<!-- @mp @end description -->

<!-- @mp @caveats -->
<p>SFS will get very confused if you ever unmount file systems from
beneath it.  SFS's <span class="command">nfsmounter</span> program tries to clean up the
mess if the client software ever crashes.  Running <span class="command">funmount</span>
will generally only make things worse by confusing
<span class="command">nfsmounter</span>. 
<!-- @mp @end caveats -->

<!-- @mp @bugs -->
<p>If <span class="file">/a</span> is a mount point, and <span class="file">/a/b</span> is another mount point,
unmounting <span class="file">/a</span> before <span class="file">/a/b</span> will cause the latter file
system to become &ldquo;lost.&rdquo;  Once a file system is lost, there is no
way to unmount it without rebooting.  Worse yet, on some operating
systems, commands such as <span class="command">df</span> may hang because of a lost file
system.

   <p>Many operating systems will not let you unmount a file system (even
forcibly) if a process is using the file system's root directory (for
instance as a current working directory).  Under such circumstances,
<span class="command">funmount</span> may fail.  To unmount the file system you must find
and kill whatever process is using the directory.  Utilities such as
<span class="command">fstat</span> and <span class="command">lsof</span> may be helpful for identifying
processes with a particular file system open. 
<!-- @mp @end bugs -->
<!-- @mp @end command -->
<!-- @mp @end -->

<p><a name="sfsrwsd"></a>

<!-- node-name,  next,  previous,  up -->
<h3 class="section">6.11 <span class="command">sfsrwsd</span> daemon</h3>

<!-- @mp -->
<!-- @mp @command{sfsrwsd}{SFS read-write server}{8} -->
<!-- @mp @synopsis -->
<pre class="example">     /usr/local/lib/sfs-0.8pre/sfsrwsd [-f <var>config-file</var>]
</pre>
<!-- @mp @end synopsis -->
<!-- @mp @description -->
<p><span class="command">sfsrwsd</span> is the program implementing the SFS read-write server. 
Ordinarily, you should never run <span class="command">sfsrwsd</span> directly, but rather
have <span class="command">sfssd</span> do so.  Nonetheless, you must create a
configuration file for <span class="command">sfsrwsd</span> before running an SFS server. 
See <a href="#sfsrwsd_005fconfig">sfsrwsd_config</a>, for what to put in your <span class="file">sfsrwsd_config</span>
file. 
<!-- @mp @end description -->

<!-- @mp @options -->
<dl>
<dt><span class="option">-f </span><var>config-file</var><dd>Specify an alternate <span class="command">sfsrwsd</span> configuration file,
<a href="#sfsrwsd_005fconfig">sfsrwsd_config</a>.  The default, if <span class="option">-f</span> is unspecified, is
<span class="file">/etc/sfs/sfsrwsd_config</span>. 
</dl>
   <!-- @mp @end options -->
<!-- @mp @end command -->
<!-- @mp @end -->

<p><a name="sfsrosd"></a>

<!-- node-name,  next,  previous,  up -->
<h3 class="section">6.12 <span class="command">sfsrosd</span> daemon</h3>

<!-- @mp -->
<!-- @mp @command{sfsrosd}{SFS read-only server}{8} -->
<!-- @mp @synopsis -->
<pre class="example">     /usr/local/lib/sfs-0.8pre/sfsrosd [-f <var>config-file</var>]
</pre>
<!-- @mp @end synopsis -->
<!-- @mp @description -->
<p><span class="command">sfsrosd</span> is the program implementing the SFS read-only server. 
Ordinarily, you should never run <span class="command">sfsrwsd</span> directly, but rather
have <span class="command">sfssd</span> do so.  Nonetheless, you must create a
configuration file for <span class="command">sfsrosd</span> before running an SFS server. 
See <a href="#sfsrosd_005fconfig">sfsrosd_config</a>, for what to put in your <span class="file">sfsrosd_config</span>
file. 
<!-- @mp @end description -->

<!-- @mp @options -->
<dl>
<dt><span class="option">-f </span><var>config-file</var><dd>Specify an alternate <span class="command">sfsrosd</span> configuration file,
<a href="#sfsrosd_005fconfig">sfsrosd_config</a>.  The default, if <span class="option">-f</span> is unspecified, is
<span class="file">/etc/sfs/sfsrosd_config</span>. 
</dl>
   <!-- @mp @end options -->
<!-- @mp @end command -->
<!-- @mp @end -->

<p><a name="sfsauthd"></a>

<!-- node-name,  next,  previous,  up -->
<h3 class="section">6.13 <span class="command">sfsauthd</span> daemon</h3>

<!-- @mp -->
<!-- @mp @command{sfsauthd}{SFS authentication daemon}{8} -->
<!-- @mp @synopsis -->
<pre class="example">     /usr/local/lib/sfs-0.8pre/sfsauthd [-u <var>sockfile</var>] [-f <var>config-file</var>]
</pre>
<!-- @mp @end synopsis -->
<!-- @mp @description -->
<p><span class="command">sfsauthd</span> is the program responsible for authenticating
users.  <span class="command">sfsrwsd</span> and other daemons communicate with
<span class="command">sfsauthd</span>, forwarding it authentication requests from
<span class="command">sfsagent</span> processes on remote client machines. 
<span class="command">sfsauthd</span> informs requesting daemons of whether
authentication requests are valid, and if so what local credentials to
associate with the remote user agent.  The <span class="command">sfskey</span> program
also communicates directly with remote <span class="command">sfsauthd</span> processes
when retrieving and updating users keys (with <span class="command">sfskey add</span>,
<span class="command">update</span>, <span class="command">register</span>, and more). 
<!-- @mp @end description -->

<!-- @mp @options -->
<dl>
<dt><span class="option">-f </span><var>config-file</var><dd>Specify an alternate <span class="command">sfssauthd_config</span> configuration file,
<a href="#sfsauthd_005fconfig">sfsauthd_config</a>.  The default, if <span class="option">-f</span> is unspecified, is
<span class="file">/etc/sfs/sfsauthd_config</span>. 
<br><dt><span class="option">-u </span><var>path</var><dd>Bind unix domain socket <var>path</var>, and accept TCP connections passed
over connections to that socket.  This option allows <span class="command">sfssd</span>
to communicate with already running <span class="command">sfsauthd</span> commands using
a directive like <span class="samp">Service 2 -u </span><var>path</var> in <span class="file">sfssd_config</span>
<a href="#sfssd_005fconfig">sfssd_config</a>. 
</dl>
   <!-- @mp @end options -->
<!-- @mp @end command -->
<!-- @mp @end -->

<p><a name="sfsrwcd"></a>

<!-- node-name,  next,  previous,  up -->
<h3 class="section">6.14 <span class="command">sfsrwcd</span> daemon</h3>

<!-- @mp -->
<!-- @mp @command{sfsrwcd}{SFS read-write protocol client daemon}{8} -->
<!-- @mp @synopsis -->
<pre class="example">     /usr/local/lib/sfs-0.8pre/sfsrwcd [-u <var>unknown-user</var>]
</pre>
<!-- @mp @end synopsis -->
<!-- @mp @description -->
<p><span class="command">sfsrwcd</span> is the daemon that implements the client side of the
SFS read-write file system protocol.  <span class="command">sfsrwcd</span> acts as an NFS
loopback server to the local machines's in-kernel NFS client, and as a
client to a remote SFS server speaking the read-write protocol.  Most
SFS servers use the read-write file system protocol, though several
research projects have implemented other protocols.

   <p>The SFS read-write protocol has RPC program number 344444 and version
number 3.  It closely resembles NFS3, but additionally supports leases
on attributes:  for a short period after returning file attributes to
a client, the server commits to notifying the client when the
attributes change.  Leases enable clients to cache file attributes
more aggressively.  In addition, the SFS protocol is encrypted and
authenticated (via a message authentication code), and supports user
authentication via opaque messages, so that users' local
<span class="command">sfsagent</span> processes can cryptographically authenticate them
to remote servers.

   <p>Ordinarily, <span class="command">sfsrwcd</span> is launched by <span class="command">sfscd</span>.  The
file <span class="file">/usr/local/share/sfs/sfscd_config</span>
<!-- @mp @ignore -->
(see <a href="#sfscd_005fconfig">sfscd_config</a>)
<!-- @mp @end ignore -->
contains a configuration directive instructing <span class="command">sfscd</span> to run
<span class="command">sfsrwcd</span> for the read-write file system protocol (program
344444, version 3):

<pre class="example">       Program 344444.3 sfsrwcd
</pre>
   <p>You never need to run <span class="command">sfsrwcd</span> directly (in fact,
<span class="command">sfsrwcd</span> won't work without the <span class="command">sfscd</span> automounter). 
However, you might wish to change the options with which
<span class="command">sfsrwcd</span> runs.  To do so, create an alternate
<span class="file">sfscd_config</span> file in <span class="file">/etc/sfs/</span>.  For instance, you
might use the line:

<pre class="example">       Program 344444.3 sfsrwcd -u unknown
</pre>
   <!-- @mp @end description -->
<!-- @mp @options -->
<dl>
<dt><span class="option">-u </span><var>unknown-user</var><dd>The <var>-u</var> option enables user- and group-ID mapping. 
<span class="command">sfsrwcd</span> will attempt to map remote user IDs to local user
IDs of authenticated users.  Moreover, when a user belongs to a file's
group on a remote machine, <span class="command">sfsrwcd</span> will map the file's gid
to the user's local gid.

     <p><var>unknown-user</var> must be the name of a user in the local password
file.  When none of the local users have remote credentials
corresponding to a remote file's owner, <span class="command">sfsrwcd</span> maps the
file's uid to the numeric uid of <var>unknown-user</var>.  Moreover, when a
user is not in the file's remote group, <span class="command">sfsrwcd</span> maps the
file's uid to the numeric gid of <var>unknown-user</var> in the password
file.

     <p>Note that even with the <span class="option">-u</span> option, if a local user's uid and
gid are the same as on the remote machine, no ID mapping occurs, as
the client and server are assumed to be in the same administrative
realm (though of course this might not be true).

     <p>ID mapping is not completely reliable, and may result in odd behavior. 
In particular for group IDs, no single mapping may work for all local
users.  Thus, one user may see a file belonging to one group, and
another user may see the same file as belonging to
<var>unknown-user</var>'s group.  Worse yet, the kernel may cache file
attributes, so that if the two users look at the same file at roughly
the same time, one user may see the other user's mapping.

     <p>Despite odd attributes that might result from kernel cache consistency
problems, ID mapping never changes the actual file permissions users
have on files.  Nor does it affect the results of the <code>access</code>
system call.  The primary reason for the <var>-u</var> flag is that the
Macintosh finder attempts to second-guess file permissions based on
numeric user and group ID, even when these values do not make sense on
the local machine.  Thus, users can be denied access to files they
have legitimate access to (and which the <code>access</code> system call
would show they had access to).

     <p>Note that when ID mapping is in effect, the <code>chown</code> system call
(used by the <span class="command">chown</span> and <span class="command">chgrp</span> commands) is
disallowed, because its potentially confusing effects would be
concealed by the ID mapping. 
</dl>
   <!-- @mp @end options -->
<!-- @mp @end command -->
<!-- @mp @end -->

<p><a name="nfsmounter"></a>

<!-- node-name,  next,  previous,  up -->
<h3 class="section">6.15 <span class="command">nfsmounter</span> daemon</h3>

<p><a name="index-_0040command_007bnfsmounter_007d-30"></a>
<!-- @mp -->
<!-- @mp @command{nfsmounter}{NFS mount/unmount daemon}{8} -->
<!-- @mp @synopsis -->
<pre class="example">     /usr/local/lib/sfs-0.8pre/nfsmounter [-F] [-P] /<var>prefix</var>
</pre>
   <!-- @mp @end synopsis -->
<!-- @mp @description -->
<p><span class="command">nfsmounter</span> is a program that calls the <code>mount</code> and
<code>unmount</code> (or <span class="command">umount</span>, depending on the operating
system) system calls to create NFS mount points for NFS loopback
servers.  An NFS loopback server is a user-level program that speaks
the NFS file system protocol, effectively pretending to be a remote
file server even though it is just a process on the local machine. 
SFS is implemented as an NFS loopback server to gain portability,
since most operating systems have built-in NFS clients.  Other file
systems built using the SFS file system toolkit also use
<span class="command">nfsmounter</span>.

   <p>The only thing you really need to know about nfsmounter is that you
should <em>never send </em><span class="command">nfsmounter</span><em> a </em><code>SIGKILL</code><em> signal,
e.g., using the </em><span class="samp">kill -9</span><em> command</em>.  If an NFS loopback server
seems to be misbehaving, you can find the corresponding
<code>nfsmounter</code> process through <span class="command">ps</span> (the <var>prefix</var>
argument will tell you which directory a particular
<span class="command">nfsmounter</span> process is handling, if there are multiple
loopback servers on your machine) and send it a <code>SIGTERM</code> signal
(<span class="samp">kill -15</span>).  Upon receiving a <code>SIGTERM</code>,
<span class="command">nfsmounter</span> will drop its connection to the NFS loopback
server, take over the UDP sockets corresponding to the mount point,
and do its best to unmount all the file systems.

   <p>The rest of this <span class="command">nfsmounter</span> description is mostly of
interest to people who are developing NFS loopback servers themselves.

   <p><span class="command">nfsmounter</span> must be run as root.  It expects its standard
input (file descriptor 0) to be a Unix-domain socket.  The program
that spawned <span class="command">nfsmounter</span> communicates over that socket using
an RPC protocol defined in <span class="file">/usr/local/include/sfs/nfsmounter.x</span>. 
As part of the mount process, the program that invoked
<span class="command">nfsmounter</span> must send it a copy of the server socket for the
NFS loopback server.  When <span class="command">nfsmounter</span> detects an end of file
on standard input, it takes over these sockets so as to avoid having
processes hang (which would happen if the NFS loopback server simply
died) and attempts to unmount all file systems.  Thus, it is safe for
NFS loopback servers simply to exit.

   <p>If the <span class="env">SFS_RUNINPLACE</span> environment variable is set to a directory
and <span class="command">nfsmounter</span> detects that its standard input is not a
Unix-domain socket, <span class="command">nfsmounter</span> will instead bind Unix-domain
socket <span class="file">$SFS_RUNINPLACE/runinplace/.nfsmounter</span> and wait for a
single connection.  The <span class="command">sfscd</span> program knows to check for
this socket when <span class="env">SFS_RUNINPLACE</span> is set.  This option makes it
easy to run <span class="command">sfscd</span> as a non-root user by starting
<span class="command">nfsmounter</span> first, which in turn facilitates debugging with
emacs (without having to run everything as root). 
<!-- @mp @end description -->

<!-- @mp @options -->
<dl>
<dt><span class="option">-F</span><dd>Disables forcible unmounting of file systems.  Forcible unmounting is
the system call flag that corresponds to the <span class="option">-f</span> flag of the
<span class="command">umount</span> command.  If you are developing an NFS loopback
server that seems to panic the kernel a lot on exit, running
<span class="command">nfsmounter</span> with <span class="option">-F</span> might help.

     <br><dt><span class="option">-P</span><dd>Always pass absolute pathnames to the <code>mount</code> system call. 
Ordinarily, as a defensive measure, <span class="command">nfsmounter</span> changes
directory to the point where the mount is happening.  This is to avoid
accidentally following a symbolic link and creating a mountpoint on a
directory not under <var>prefix</var>.  However, calling <code>mount</code> with
a relative pathname cause the <span class="file">/proc</span> file system or system
calls like <code>getfsstat</code> to return relative pathnames, which can
confuse some applications.

     <p>To fix the problem, after creating a mount point, <span class="command">nfsmounter</span>
attempts to re-mount or update the mountpoint using the absolute
pathname.  Unfortunately, this trick does not work on some BSD-derived
operating systems, including MacOS.  Moreover, on the Macintosh in
particular, the finder gets very confused by relative mountpoint
names.  Thus, SFS uses the <span class="option">-P</span> option to nfsmounter on the
Macintosh. 
</dl>
   <!-- @mp @end options -->

<!-- @mp @bugs -->
<p><span class="command">nfsmounter</span> gets very confused if you unmount file systems
out from under it.

   <p>On some versions of Linux, if you attempt to create an NFS loopback
mount but are not running <span class="command">portmap</span>, it appears to wedge the
mountpoint in way that requires a reboot to recover.  The reason is
that the Linux kernel's NFS client checks to see if the server is
running various auxiliary daemons used for locking, and gets into a
bad state if it cannot map the port.  There should be a way to recover
from this situation, but the author of <span class="command">nfsmounter</span> does not
know how.  Running <span class="command">portmap</span> after the fact does not help. 
Perhaps <span class="command">nfsmounter</span> should have its own built-in portmap to
use in the event that port 111 is not yet bound by any process. 
<!-- @mp @end bugs -->
<!-- @mp @end command -->
<!-- @mp @end -->

<p><a name="Environment-variables"></a>

<!-- node-name,  next,  previous,  up -->
<h2 class="chapter">7 Environment variables</h2>

<!-- @mp -->
<!-- @mp @command{sfs_environ}{SFS environment variables}{7} -->
<!-- @mp @description -->
<p>The following environment variables affect many of SFS's component
programs.  (Note that for security reasons, the setuid programs
<span class="command">suidconnect</span> and <span class="command">newaid</span> interpret some of these
slightly differently&mdash;ignoring some and dropping privilege if others
are set.)

     <dl>
<dt><var>ACLNT_TRACE</var><dd>Used mostly for debugging, <var>ACLNT_TRACE</var> causes most SFS commands
to print a trace of all the RPCs they make.  The environment variable
must be set to an integer.  The higher the value, the more trace
information.  The value 1 causes only anomalous situations such as
retransmissions to be reported.  2 causes every RPC to be printed.  4
causes both RPC calls and replies to be printed.  Arguments over 5
cause the actual RPC argument and result data structures to be
pretty-printed&ndash;the higher the number the greater the depth to which
recursive data structures will be expanded.  A value of 10 is
generally sufficient to get a very complete RPC trace.

     <br><dt><var>ACLNT_TIME</var><dd>A boolean value.  When this environment variable and <var>ACLNT_TRACE</var>
are both set, the trace includes timestamps as well, which can be
useful in debugging.

     <br><dt><var>ASRV_TRACE</var><dt><var>ASRV_TIME</var><dd>These perform an analogous function to <span class="env">ACLNT_TRACE</span> and
<span class="env">ACLNT_TIME</span>, but print out RPCs received (as a server), rather
than ones made.

     <br><dt><var>BINDADDR</var><dd>If set, must contain an IPv4 address.  Whenever SFS creates a socket
that would be bound to <code>INADDR_ANY</code>, it will be bound to
<var>BINDADDR</var> instead (unless <var>BINDADDR</var> is no longer a valid
local address).

     <br><dt><var>FDLIM_HARD</var><dt><var>FDLIM_SOFT</var><dd>Most of the daemons that comprise SFS use asynchronous I/O to handle
multiple network connections concurrently.  In order to be able to
handle as many concurrent connections as possible, the library raises
the per-process file descriptor limit to the maximum allowable value. 
For privileged processes, this additionally means raising the
so-called &ldquo;hard&rdquo; file descriptor limit.  When raising these values,
if the <span class="env">FDLIM_SOFT</span> and <span class="env">FDLIM_HARD</span> environment variables are
not set, SFS saves their the old limit values in the environment
variables.

     <p>An example of how this is used is by <span class="command">rexd</span>, the remote
execution daemon.  <span class="command">rexd</span> reduces the file descriptor limits
to the original values specified by these environment variables before
spawning an unprivileged user program.  These variables ordinarily
should not be of concern to users of SFS, and are documented here
mostly for people who notice them and are curious.

     <br><dt><var>SFS_AGENTSOCK</var><dd>Ordinarily <span class="command">sfskey</span> connects to <span class="command">sfsagent</span> through the
SFS client daemon, <span class="command">sfscd</span>.  However, by passing the
<span class="option">-S</span> option to <span class="command">sfsagent</span>, it is possible to have
<span class="command">sfsagent</span> bind an arbitrary Unix domain socket for
connections.  <span class="command">SFS_AGENTSOCK</span> can be set to such a pathname,
and <span class="command">sfskey</span> will then connect to that socket.

     <p>As a special case, if <span class="env">SFS_AGENTSOCK</span> is set to a negative number,
this is interpreted to mean a file descriptor number already connected
to the agent.  This feature is particularly useful when atomically
killing and starting <span class="command">sfsagent</span> with the <span class="option">-k</span> flag.  In
this case, and program specified on the command line, or the default
<span class="file">/usr/local/share/sfs/agentrc</span> script, will be run with
<span class="env">SFS_AGENTSOCK</span> set to a file descriptor.  Thus, if the script
loads keys into the agent by running <span class="command">sfskey</span>, these keys will
be loaded into the new agent (before it takes over), rather than into
the old agent.

     <br><dt><var>SFS_CONFIG</var><dd>The location in which to find the <span class="file">sfs_config</span> file.  By default,
SFS uses configuration files in
<span class="file">/usr/local/share/sfs/sfs_config</span> and
<span class="file">/etc/sfs/sfs_config</span>.  <span class="command">sfssd</span> sets this
environment variable when given the <span class="option">-S</span> option, so that
subsidiary daemons read the same configuration file.

     <br><dt><var>SFS_HOSTNAME</var><dd><a name="SFS_005fHOSTNAME"></a>
Overrides SFS's default algorithm for figuring out the local hostname. 
Several SFS programs must know the machine's fully-qualified hostname. 
In particular, this name constitutes the official <var>Location</var> in a
server's self-certifying pathname (since a given file system should
have only one self-certifying hostname).  The hostname of an SFS
server must exist in the DNS (as opposed to just
<span class="file">/etc/hosts</span>) for many of the servers to work.

     <p>The algorithm used by SFS is to determine a host's name is as follows. 
It checks the system's name with the <code>gethostname</code> system call,
and if it is fully-qualified (i.e., has a &ldquo;.domain&rdquo; at the end) uses
that.  Otherwise, it appends the default domain name to the system
name.

     <p>Sometimes SFS's algorithm will not produce the correct hostname.  In
that case, you can specify the real hostname for each individual
daemon such as <span class="command">sfsrwsd</span> and <span class="command">sfsauthd</span> in their
confiruation files.  Or, you can just set the environment variable
<span class="env">SFS_HOSTNAME</span> before running <span class="command">sfssd</span>.  Note that if you
do not have a DNS name, you can also set <span class="env">SFS_HOSTNAME</span> to the
numeric IPv4 address of your host, and then use the IP address as the
<var>Location</var> in self-certifying pathnames.

     <br><dt><var>SFS_PORT</var><dd><a name="SFS_005fPORT"></a>
This variable, if set, specifies official port number of an SFS
server&mdash;i.e. the <span class="file">%</span><var>port</var> that clients must append to the
hostname in the <var>Location</var> of the self-certifying pathname.  By
default (or if <span class="env">SFS_PORT</span> is set to 0), the self-ceritying
pathname contains no port number, which means to check DNS for SRV
records, and if none are found to use port 4.

     <p>Because servers have only one canonical self-certifying pathname,
setting <span class="env">SFS_PORT</span> to 4 is not the same thing as setting it to 0,
even without SRV records.  If you set <span class="env">SFS_PORT</span> to 4, then
clients who do not specify <span class="samp">%4</span> in the self-certifying pathname
will need to be redirected to a pathname containing <span class="file">%4</span> via a
symbolic link, and <span class="command">pwd</span> run on a client will show the
<span class="samp">%4</span> as part of the self-certifying pathname.

     <p>Note further that the effects of this environment variable should not
be confused with the <span class="samp">BindAddr</span> option in <span class="file">sfssd_config</span>,
<a href="#BindAddr">BindAddr</a>.  For example, if you set up SRV records pointing to
TCP port 5 on your server, you might want to specify <span class="samp">BindAddr
0.0.0.0 5</span> in <span class="file">sfssd_config</span>, but you almost certainly would not
want to set the <span class="env">SFS_PORT</span> environment variable to 5, as setting
<span class="env">SFS_PORT</span> to anything other than 0 means the self-certifying
pathname contains <span class="file">%5</span>, which in turn means DNS SRV records
should not be used.  (I.e., a client accessing
<span class="file">@host.domain,</span><var>hostid</var> would be redirected to
<span class="file">@host.domain%5,</span><var>hostid</var>, which would bypass any SRV
records for <span class="file">host.domain</span> and, depending on DNS data, might not
even resolve to the same IP address as the pathname without a
<span class="file">%</span>.)

     <br><dt><var>SFS_ROOT</var><dd>Sets the root directory of the SFS file system, which is usually
<span class="file">/sfs</span>.  Changing this for anything other than debugging purposes
is not recommended, as many symbolic links will break.

     <br><dt><var>SFS_RUNINPLACE</var><dd>SFS consists of a large number of interacting daemons.  Ordinarily,
these are launched by <span class="command">sfscd</span> and <span class="command">sfssd</span>.  If you
wish to run SFS without installing it, however, these commands will
not be able to find the subsidiary daemons they are supposed to
launch.  Setting <span class="env">SFS_RUNINPLACE</span> to the root of your build
directory allows SFS to be run without installing it.  Because this
option is mainly used for development, however, several programs
behave slightly differently when it is set.  <span class="command">sfscd</span> and
<span class="command">sfssd</span> both remain in the forground and send their output to
standard error, rather than to the system log.  Moreover,
<span class="command">sfsagent</span> does take steps to protect itself from the
<code>ptrace</code> system call, so that you can attach to it with the
debugger when running in place.

     <br><dt><var>TMPDIR</var><dd>Some SFS programs need to create temporary files or Unix-domain
sockets in the local file system.  By default, these programs use the
<span class="file">/tmp</span> directory or created protected subdirectories of
<span class="file">/tmp</span>.  However, you can override the location by setting the
<span class="env">TMPDIR</span> environment variable.

     <br><dt><var>USER</var><dd>In various places SFS needs a default username&mdash;for example, when
running <span class="samp">sfskey login</span>.  SFS looks first at the <span class="env">USER</span>
environment variable, then uses the <code>getlogin</code> system call, and
if that fails, looks up the current user ID in the system password
file. 
</dl>
   <!-- @mp @end description -->
<!-- @mp @end command -->
<!-- @mp @end -->

<p><a name="Security"></a>

<!-- node-name,  next,  previous,  up -->
<h2 class="chapter">8 Security considerations</h2>

<p>SFS shares files between machines using cryptographically protected
communication.  As such, SFS can help eliminate security holes
associated with insecure network file systems and let users share files
where they could not do so before.

   <p>That said, there will very likely be security holes attackers can
exploit because of SFS, that they could not have exploited otherwise. 
This chapter enumerates some of the security consequences of running
SFS.  The first section describes vulnerabilities that may result from
the very existence of a global file system.  The next section lists bugs
potentially present in your operating system that may be much easier for
attackers to exploit if you run SFS.  Finally the last section attempts
to point out weak points of the SFS implementation that may lead to
vulnerabilities in the SFS software itself.

<p><a name="new-vulnerabilities"></a>

<!-- node-name,  next,  previous,  up -->
<h3 class="section">8.1 Vulnerabilities created by SFS</h3>

<h4 class="subheading">Facilitating exploits</h4>

<p>Many security holes can be exploited much more easily if the attacker
can create an arbitrary file on your system.  As a simple example, if a
bug allows attackers to run any program on your machine, SFS allows them
to supply the program somewhere under <span class="file">/sfs</span>.  Moreover, the file
can have any numeric user and group (though of course, SFS disables
setuid and devices).

<h4 class="subheading"><span class="file">.</span> in <span class="env">path</span></h4>

<p>Another potential problem users putting the current working directory
<span class="file">.</span> in their <var>PATH</var> environment variables.  If you are browsing
a file system whose owner you do not trust, that owner can run arbitrary
code as you by creating programs named things like <span class="command">ls</span> in the
directories you are browsing.  Putting <span class="file">.</span> in the <var>PATH</var> has
always been a bad idea for security, but a global file system like SFS
makes it much worse.

<h4 class="subheading">symbolic links from untrusted servers</h4>

<p>Users need to be careful about using untrusted file systems as if they
were trusted file systems.  Any file system can name files in any other
file system by symbolic links.  Thus, when randomly overwriting files in
a file system you do not trust, you can be tricked, by symbolic links,
into overwriting files on the local disk or another SFS file system.

   <p>As an example of a seemingly appealing use of SFS that can cause
problems, consider doing a <span class="command">cvs</span> checkout from an untrusted CVS
repository, so as to peruse someone else's source code.  If you run
<span class="command">cvs</span> on a repository you do not trust, the person hosting the
repository could replace the <span class="file">CVSROOT/history</span> with a symbolic
link to a file on some other file system, and cause you to append
garbage to that file.

   <p>This <span class="command">cvs</span> example may or may not be a problem.  For instance,
if you are about to compile and run the software anyway, you are placing
quite a bit of trust in the person running the CVS repository anyway. 
The important thing to keep in mind is that for most uses of a file
system, you are placing some amount of trust in in the file server.

   <p>See <a href="#resvgids">resvgids</a>, to see how users can run multiple agents with the
<span class="command">newaid</span> command.  One way to cut down on trust is to access
untrusted file servers under a different agent with different private
keys.  Nonetheless, this still allows the remote file servers to serve
symbolic links to the local file system in unexpected places.

<h4 class="subheading">Leaking information</h4>

<p>Any user on the Internet can get the attributes of a
<var>local-directory</var> listed in an <span class="samp">Export</span> directive
(see <a href="#export">export</a>).  This is so users can run commands like <span class="samp">ls -ld</span>
on a self-certifying pathname in <span class="file">/sfs</span>, even if they cannot change
directory to that pathname or list files under it.  If you wish to keep
attribute information secret on a <var>local-directory</var>, you will need
to export a higher directory.  We may later reevaluate this design
decision, though allowing such anonymous users to get attributes
currently simplifies the client implementation.

<p><a name="exposed-vulnerabilities"></a>

<!-- node-name,  next,  previous,  up -->
<h3 class="section">8.2 Vulnerabilities exploitable because of SFS</h3>

<h4 class="subheading">NFS server security</h4>

<p><a name="index-NFS-security-31"></a><a name="NFS-security"></a>

   <p>The SFS read-write server software requires each SFS server to run an
NFS server.  Running an NFS server at all can constitute a security
hole.  In order to understand the full implications of running an SFS
server, you must also understand NFS security.

   <p>NFS security relies on the secrecy of file handles.  Each file on an
exported file system has associated with it an NFS file handle
(typically 24 to 32 bytes long).  When mounting an NFS file system, the
<span class="command">mount</span> command on the client machine connects to a program
called <span class="command">mountd</span> on the server and asks for the file handle of
the root of the exported file system.  <span class="command">mountd</span> enforces access
control by refusing to return this file handle to clients not authorized
to mount the file system.

   <p>Once a client has the file handle of a directory on the server, it sends
NFS requests directly to the NFS server's kernel.  The kernel performs
no access control on the request (other than checking that the user the
client claims to speak for has permission to perform the requested
operation).  The expectation is that all clients are trusted to speak
for all users, and no machine can obtain a valid NFS file handle without
being an authorized NFS client.

   <p>To prevent attackers from learning NFS file handles when using SFS, SFS
encrypts all NFS file handles with a 20-byte key using the Blowfish
encryption algorithm.  Unfortunately, not all operating systems choose
particularly good NFS file handles in the first place.  Thus, attackers
may be able to guess your file handles anyway.  In general, NFS file
handles contain the following 32-bit words:

     <ul>
<li>A file system ID (containing the device number)
<li>The inode number (i-number) of the file
<li>A generation number that changes when the i-number is recycled
</ul>

<p class="noindent">In addition NFS file handles can contain the following words:

     <ul>
<li>A second file system ID word (for a 64-bit fsid)
<li>The length of the file handle data
<li>The i-number of the exported directory
<li>The generation number of the exported directory
<li>Another copy of the file system ID (for the exported directory?) 
<li>One or more unused 0 words
</ul>

<p class="noindent">Many of these words can be guessed outright by attackers without their
needing to interact with any piece of software on the NFS server.  For
instance, the file system ID is often just the device number on which
the physical file system resides.  The i-number of the root directory in
a file system is always 2.  The i-number and generation number of the
root directory can also be used as the i-number and generation number of
the &ldquo;exported directory&rdquo;.

   <p>On some operating systems, then, the only hard thing for an attacker to
guess is the 32-bit generation number of some directory on the system. 
Worse yet, the generation numbers are sometimes not chosen with a good
random number generator.

   <p>To minimize the risks of running an NFS server, you might consider
taking the following precautions:

     <ul>
<li>Many operating systems ship with a program called <span class="command">fsirand</span> that
re-randomizes all generation numbers in a file system.  Running
<span class="command">fsirand</span> may result in much better generation numbers than,
say, a factory install of an operating system.

     <li>In general, you should try to block all external NFS traffic from
reaching your machine.  If you have a firewall, consider filtering ports
111 and 2049 for both TCP and UDP.  If your server's operating system
comes with some sort of IP filtering, you might filter any traffic to
port 2049 that does not come from the loopback interface (though on some
OSes, this could prevent you from acting as an NFS client if you are
still using NFS on your local network&mdash;try it to see).

     <li>Most operating systems allow you to export NFS file systems
&ldquo;read-mostly&rdquo;&mdash;i.e. read-write to a small number of servers and
read-only to everyone else.  The read-only requirement typically is
enforced by the kernel.  Thus, if you can export file systems read-write
to <span class="samp">localhost</span> for SFS, but read-only to any client on which an
attacker may have learned an NFS file handle, you may be able to protect
the integrity of your file system under attack.  (Note, however, that
unless you filter forged packets at your firewall, the attacker can put
whatever source address he wants on an NFS UDP packet.)  See the
<span class="command">mountd</span> or <span class="command">exports</span> manual page for more detail. 
<strong>Note:  under no circumstances should you make your file system
&ldquo;read-only to the world,&rdquo; as this will let anyone find out NFS file
handles.  You want the kernel to think of the file system as read-only
for the world, but </strong><span class="command">mountd</span><strong> to refuse to give out file handles
to anybody but </strong><span class="samp">localhost</span><strong>.</strong>
</ul>

<h4 class="subheading"><span class="samp">mountd -n</span>.</h4>

<p>The <span class="command">mountd</span> command takes a flag <span class="option">-n</span> meaning &ldquo;allow
mount requests from unprivileged ports.&rdquo;  <strong>Do not ever run use
this flag</strong>.  Worse yet, some operating systems (notably HP-UX 9) always
exhibit this behavior regardless of whether they <span class="option">-n</span> flag has
been specified.

   <p>The <span class="option">-n</span> option to <span class="command">mountd</span> allows any user on an NFS
client to learn file handles and thus act as any other user.  The
situation gets considerably worse when exporting file systems to
<span class="samp">localhost</span>, however, as SFS requires.  Then everybody on the
Internet can learn your NFS file handles.  The reason is that the
<span class="command">portmap</span> command will forward mount requests and make them
appear to come from <span class="samp">localhost</span>.

<h4 class="subheading"><span class="command">portmap</span> forwarding</h4>

<p>In order to support broadcast RPCs, the <span class="command">portmap</span> program will
relay RPC requests to the machine it is running on, making them appear
to come from <span class="samp">localhost</span>.  That can have disastrous consequences in
conjunction with <span class="samp">mountd -n</span> as described previously.  It can also
be used to work around &ldquo;read-mostly&rdquo; export options by forwarding NFS
requests to the kernel from <span class="samp">localhost</span>.

   <p>Operating systems are starting to ship with <span class="command">portmap</span> programs
that refuse to forward certain RPC calls including mount and NFS
requests.  Wietse Venema has also written a <span class="command">portmap</span>
replacement that has these properties, available from
<a href="ftp://ftp.porcupine.org/pub/security/index.html">ftp://ftp.porcupine.org/pub/security/index.html</a>.  It is also a
good idea to filter TCP and UDP ports 111 (<span class="command">portmap</span>) at your
firewall, if you have one.

<h4 class="subheading">Bugs in the NFS implementation</h4>

<p>Many NFS implementations have bugs.  Many of those bugs rarely surface
when clients and servers with similar implementation talk to each other. 
Examples of bugs we've found include servers crashing when the receive a
write request for an odd number of bytes, clients crashing when they
receive the error <code>NFS3ERR_JUKEBOX</code>, and clients using
uninitialized memory when the server returns a <code>lookup3resok</code> data
structure with <code>obj_attributes</code> having <code>attributes_follow</code> set
to false.

   <p>SFS allows potentially untrusted users to formulate NFS requests (though
of course SFS requires file handles to decrypt correctly and stamps the
request with the appropriate Unix uid/gid credentials).  This may let
bad users crash your server's kernel (or worse).  Similarly, bad servers
may be able to crash a client.

   <p>As a precaution, you may want to be careful about exporting any portion
of a file system to anonymous users with the <span class="samp">R</span> or <span class="samp">W</span>
options to <span class="samp">Export</span> (see <a href="#export">export</a>).  When analyzing your NFS code
for security, you should know that even anonymous users can make the
following NFS RPC's on a <var>local-directory</var> in your
<span class="file">sfsrwsd_config</span> file:  <code>NFSPROC3_GETATTR</code>,
<code>NFSPROC3_ACCESS</code>, <code>NFSPROC3_FSINFO</code>, and
<code>NFSPROC3_PATHCONF</code>.

   <p>On the client side, a bad, non-root user in collusion with a bad file
server can possibly crash or deadlock the machine.  Many NFS client
implementations have inadequate locking that could lead to race
conditions.  Other implementations make assumptions about the
hierarchical nature of a file system served by the server.  By violating
these assumptions (for example having two directories on a server each
contain the other), a user may be able to deadlock the client and create
unkillable processes.

<h4 class="subheading"><span class="command">logger</span> buffer overrun</h4>

<p>SFS pipes log messages through the <span class="command">logger</span> program to get them
into the system log.  SFS can generate arbitrarily long lines.  If your
<span class="command">logger</span> does something stupid like call <span class="command">gets</span>, it may
suffer a buffer overrun.  We assume no one does this, but feel the point
is worth mentioning, since not all logger programs come with source.

   <p>To avoid using <span class="command">logger</span>, you can run <span class="command">sfscd</span> and
<span class="command">sfssd</span> with the <span class="option">-d</span> flag and redirect standard error
wherever you wish manually.

<p><a name="implementation-vulnerabilities"></a>

<!-- node-name,  next,  previous,  up -->
<h3 class="section">8.3 Vulnerabilities in the SFS implementation</h3>

<h4 class="subheading">Resource exhaustion</h4>

<p>The best way to attack the SFS software is probably to cause resource
exhaustion.  You can try to run SFS out of file descriptors, memory, CPU
time, or mount points.

   <p>An attacker can run a server out of file descriptors by opening many
parallel TCP connections.  Such attacks can be detected using the
<span class="command">netstat</span> command to see who is connecting to SFS (which
accepts connections on port 4).  Users can run the client (also
<span class="command">sfsauthd</span>) out of descriptors by connecting many times using
the setgid program <span class="file">/usr/local/lib/sfs-0.8pre/suidconnect</span>. 
These attacks can be traced using a tool like lsof, available from
<a href="ftp://vic.cc.purdue.edu/pub/tools/unix/lsof">ftp://vic.cc.purdue.edu/pub/tools/unix/lsof</a>.

   <p>SFS enforces a maximum size of just over 64 K on all RPC requests. 
Nonetheless, a client could connect 1000 times, on each connection send
the first 64 K of a slightly larger message, and just sit there.  That
would obviously consume about 64 Megabytes of memory, as SFS will wait
patiently for the rest of the request.

   <p>A worse problem is that SFS servers do not currently flow-control
clients.  Thus, an attacker could make many RPCs but not read the
replies, causing the SFS server to buffer arbitrarily much data and run
out of memory.  (Obviously the server eventually flushes any buffered
data when the TCP connection closes.)

   <p>Connecting to an SFS server costs the server tens of milliseconds of CPU
time.  An attacker can try to burn a huge amount of the server's CPU
time by connecting to the server many times.  The effects of such
attacks can be mitigated using hashcash, <a href="#HashCost">HashCost</a>.

   <p>Finally, a user on a client can cause a large number of file systems to
be mounted.  If the operating system has a limit on the number of mount
points, a user could run the client out of mount points.

<h4 class="subheading">Non-idempotent operations</h4>

<p>If a TCP connection is reset, the SFS client will attempt to reconnect
to the server and retransmit whatever RPCs were pending at the time the
connection dropped.  Not all NFS RPCs are idempotent however.  Thus, an
attacker who caused a connection to reset at just the right time could,
for instance, cause a <span class="command">mkdir</span> command to return <code>EEXIST</code>
when in fact it did just create the directory.

<h4 class="subheading">Injecting packets on the loopback interface</h4>

<p>SFS exchanges NFS traffic with the local operating system using the
loopback interface.  An attacker with physical access to the local
Ethernet may be able to inject arbitrary packets into a machine,
including packets to 127.0.0.1.  Without packet filtering in place, an
attacker can also send packets from anywhere making them appear to come
from 127.0.0.1.

   <p>On the client, an attacker can forge NFS requests from the kernel to
SFS, or forge replies from SFS to the kernel.  The SFS client encrypts
file handles before giving them to the operating system.  Thus, the
attacker is unlikely to be able to forge a request from the kernel to
SFS that contain a valid file handle.  In the other direction however,
the reply does not need to contain a file handle.  The attacker may well
be able to convince the kernel of a forged reply from SFS.  The attacker
only needs to guess a (possibly quite predictable) 32-bit RPC XID
number.  Such an attack could result, for example, in a user getting the
wrong data when reading a file.

   <p>On the server side, you also must assume the attacker cannot guess a
valid NFS file handle (otherwise, you already have no
security&mdash;see <a href="#NFS-security">NFS security</a>).  However, the attacker might again
forge NFS replies, this time from the kernel to the SFS server software.

   <p>To prevent such attacks, if your operating system has IP filtering, it
would be a good idea to block any packets either from or to 127.0.0.1 if
those packets do not come from the loopback interface.  Blocking traffic
"from" 127.0.0.1 at your firewall is also a good idea.

<h4 class="subheading">Causing deadlock</h4>

<p>On BSD-based systems (and possibly others) the buffer reclaiming policy
can cause deadlock.  When an operation needs a buffer and there are no
clean buffers available, the kernel picks some particular dirty buffer
and won't let the operation complete until it can get that buffer.  This
can lead to deadlock in the case that two machines mount each other.

<h4 class="subheading">Getting private file data from public workstations</h4>

<p>An attacker may be able to read the contents of a private file shortly
after you log out of a public workstation if the he can then become root
on the workstation.  There are two attacks possible.

   <p>First, the attacker may be able to read data out of physical memory or
from the swap partition of the local disk.  File data may still be in
memory if the kernel's NFS3 code has cached it in the buffer cache. 
There may also be fragments of file data in the memory of the
<span class="command">sfsrwcd</span> process, or out on disk in the swap partition (though
<span class="command">sfsrwcd</span> does its best to avoid getting paged out).  The
attacker can read any remaining file contents once he gains control of
the machine.

   <p>Alternatively, the attacker may have recorded encrypted session traffic
between the client and server.  Once he gains control of the client
machine, he can attach to the <span class="command">sfsrwcd</span> process with the
debugger and learn the session key if the session is still open.  This
will let him read the session he recorded in encrypted form.

   <p>To minimize the risks of these attacks, you must kill and restart
<span class="command">sfscd</span> before turning control of a public workstation over to
another user.  Even this is not guaranteed to fix the problem.  It will
flush file blocks from the buffer cache by unmounting all file systems,
for example, but the contents of those blocks may persist as
uninitialized data in buffers sitting on the free list.  Similarly, any
programs you ran that manipulated private file data may have gotten
paged out to disk, and the information may live on after the processes
exit.

   <p>In conclusion, if you are paranoid, it is best not to use public
workstations.

<h4 class="subheading">Setuid programs and devices on remote file systems</h4>

<p>SFS does its best to disable setuid programs and devices on remote file
servers it mounts.  However, we have only tested this on operating
systems we have access to.  When porting SFS to new platforms, It is
worth testing that both setuid programs and devices do not work over
SFS.  Otherwise, any user of an SFS client can become root.

<p><a name="Contacts"></a>

<!-- node-name,  next,  previous,  up -->
<h2 class="chapter">9 How to contact people involved with SFS</h2>

<p>Please report any bugs you find in SFS to
<a href="mailto:sfsbug@redlab.lcs.mit.edu">sfsbug@redlab.lcs.mit.edu</a>.

   <p>You can send mail to the authors of SFS at
<a href="mailto:sfs-dev@pdos.lcs.mit.edu">sfs-dev@pdos.lcs.mit.edu</a>.

   <p>There is also a mailing list of SFS users and developers at
<a href="mailto:sfs@sfs.fs.net">sfs@sfs.fs.net</a>.  To subscribe to the list, send mail to
<a href="mailto:sfs-subscribe@sfs.fs.net">sfs-subscribe@sfs.fs.net</a>.

<p><a name="Concept-Index"></a>

<!-- node-name,  next,  previous,  up -->
<h2 class="unnumbered">Concept Index</h2>

<ul class="index-cp" compact>
<li><a href="#index-_0040file_007b_002fetc_002fexports_007d-9"><span class="file">/etc/exports</span></a>: <a href="#Quick-server-setup">Quick server setup</a></li>
<li><a href="#index-_0040code_007b_005f_005f_005fgmp_005fdefault_005fallocate_007d-8"><code>___gmp_default_allocate</code></a>: <a href="#Build-Problems">Build Problems</a></li>
<li><a href="#index-aid-27">aid</a>: <a href="#newaid">newaid</a></li>
<li><a href="#index-Caffeine-3">Caffeine</a>: <a href="#Overview">Overview</a></li>
<li><a href="#index-Certification-paths-24">Certification paths</a>: <a href="#sfskey">sfskey</a></li>
<li><a href="#index-_0040command_007bconfigure_007d-4"><span class="command">configure</span></a>: <a href="#Building">Building</a></li>
<li><a href="#index-_0040command_007bdirsearch_007d-26"><span class="command">dirsearch</span></a>: <a href="#dirsearch">dirsearch</a></li>
<li><a href="#index-_0040command_007bdirsearch_007d-25"><span class="command">dirsearch</span></a>: <a href="#sfskey">sfskey</a></li>
<li><a href="#index-Disk-Full-6">Disk Full</a>: <a href="#Build-Problems">Build Problems</a></li>
<li><a href="#index-Dynamic-server-authentication-23">Dynamic server authentication</a>: <a href="#sfskey">sfskey</a></li>
<li><a href="#index-_0040code_007bEDEADLK_007d-28"><code>EDEADLK</code></a>: <a href="#sfscd">sfscd</a></li>
<li><a href="#index-_0040var_007bHostID_007d-1"><var>HostID</var></a>: <a href="#Overview">Overview</a></li>
<li><a href="#index-Internal-compiler-error-5">Internal compiler error</a>: <a href="#Build-Problems">Build Problems</a></li>
<li><a href="#index-NFS-security-31">NFS security</a>: <a href="#exposed-vulnerabilities">exposed vulnerabilities</a></li>
<li><a href="#index-_0040command_007bnfsmounter_007d-30"><span class="command">nfsmounter</span></a>: <a href="#nfsmounter">nfsmounter</a></li>
<li><a href="#index-_0040command_007bnfsmounter_007d-10"><span class="command">nfsmounter</span></a>: <a href="#System-overview">System overview</a></li>
<li><a href="#index-realms-16">realms</a>: <a href="#sfsauthd_005fconfig">sfsauthd_config</a></li>
<li><a href="#index-realms-11">realms</a>: <a href="#Administrative-realms">Administrative realms</a></li>
<li><a href="#index-_0040code_007bResource-deadlock-avoided_007d-29"><code>Resource deadlock avoided</code></a>: <a href="#sfscd">sfscd</a></li>
<li><a href="#index-Self_002dcertifying-pathname-2">Self-certifying pathname</a>: <a href="#Overview">Overview</a></li>
<li><a href="#index-_0040file_007bsfs_005fconfig_007d-13"><span class="file">sfs_config</span></a>: <a href="#sfs_005fconfig">sfs_config</a></li>
<li><a href="#index-_0040file_007bsfs_005fhosts_007d-17"><span class="file">sfs_hosts</span></a>: <a href="#sfs_005fhosts">sfs_hosts</a></li>
<li><a href="#index-_0040file_007bsfs_005fsrp_005fparams_007d-20"><span class="file">sfs_srp_params</span></a>: <a href="#sfs_005fsrp_005fparams">sfs_srp_params</a></li>
<li><a href="#index-_0040file_007bsfs_005fusers_007d-18"><span class="file">sfs_users</span></a>: <a href="#sfs_005fusers">sfs_users</a></li>
<li><a href="#index-_0040file_007bsfsauthd_005fconfig_007d-15"><span class="file">sfsauthd_config</span></a>: <a href="#sfsauthd_005fconfig">sfsauthd_config</a></li>
<li><a href="#index-_0040file_007bsfscd_005fconfig_007d-21"><span class="file">sfscd_config</span></a>: <a href="#sfscd_005fconfig">sfscd_config</a></li>
<li><a href="#index-_0040file_007bsfsrwsd_005fconfig_007d-14"><span class="file">sfsrwsd_config</span></a>: <a href="#sfsrwsd_005fconfig">sfsrwsd_config</a></li>
<li><a href="#index-_0040file_007bsfssd_005fconfig_007d-19"><span class="file">sfssd_config</span></a>: <a href="#sfssd_005fconfig">sfssd_config</a></li>
<li><a href="#index-SRP-22">SRP</a>: <a href="#sfskey">sfskey</a></li>
<li><a href="#index-SRP-12">SRP</a>: <a href="#Sharing-_003cspan-class_003d_0022file_0022_003esfs_005fusers_003c_002fspan_003e-files">Sharing &lt;span class=&quot;file&quot;&gt;sfs_users&lt;/span&gt; files</a></li>
<li><a href="#index-Virtual-memory-exhausted-7">Virtual memory exhausted</a>: <a href="#Build-Problems">Build Problems</a></li>
   </ul></body></html>

